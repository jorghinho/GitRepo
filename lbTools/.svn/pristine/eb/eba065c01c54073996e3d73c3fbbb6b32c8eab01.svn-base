------------------------------------------------------------------------------------------------------------------------------------------------
--Descripcion: Herramienta de setup de opciones para los previos.
------------------------------------------------------------------------------------------------------------------------------------------------
(
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollMain | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollMainDef "Preset Manager" width:550 height:390
	(
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual
		
		local minRollWidth = 705	--@var: minRollWidth | Ancho mínimo de la herramienta.
		local minRollHeight = 390	--@var: minRollHeight | Alto mínimo de la herramienta.
		local dialogWidth = rollMainDef.width
		local dialogHeight = rollMainDef.height
		
		local editingValues = false
		local mousePos = [0,0]
		local oldValue = 0
		local currentVariations = #()
		
		local okColor = (dotNetClass "System.Drawing.Color").fromargb 80 255 80
		local errorColor = (dotNetClass "System.Drawing.Color").fromargb 255 80 80

		local selectionBackcolor = (dotnetclass "System.Drawing.Color").white
		local selectionForecolor = (dotnetclass "System.Drawing.Color").black

		local clipboardObj = dotNetClass "System.Windows.Forms.Clipboard"  -- crea un clipboard de puntonet	

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		button btnLoad "Load" pos:[5,5] width:40 height:25
		button btnSave "Save" pos:[45,5] width:45 height:25
		button btnRefresh "Refresh" pos:[100,5] width:50 height:25
		button btnRandomizeAsset "Randomize asset" pos:[160,5] width:95 height:25
			
		checkbox chkRenameParts "Rename Parts" pos:[270,15] width:95 checked:true
		checkbox chkRenamePartsMaterials "Rename Parts Materials" pos:[365,15] width:150 checked:true
		checkbox chkLoadSkins "Load skinData" pos:[515,15] width:100 checked:true

		button btnLoadVariations "Load Variations" pos:[620,5] width:80 height:25

		
		--listbox lbxFileList "File List" pos:[5,40] width:540 height:7
		
		label lblVariations "Node Variations" pos:[10,165] width:95 height:15
		
		button btnRandomizeNode "Randomize Node" pos:[440,160] width:105 height:20
		
		dotNetControl dgNodes "System.Windows.Forms.DataGridView" pos:[5,180] width:220 height:200
		dotNetControl dgVariations "System.Windows.Forms.DataGridView" pos:[230,180] width:315 height:200
		dotNetControl dgFileList "System.Windows.Forms.DataGridView" pos:[5,40] width:690 height:110
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		
		---------------------------------------------------------------------------
		--@fn: undefined | initUI | inicia todos los controles gráficos del interface
		---------------------------------------------------------------------------
		fn initUI =
		(
			--dgNodes y Variations
			_dataGridViews = #(dgNodes, dgVariations, dgFileList)
			for _dg in _dataGridViews do
			(
				_dg.allowUsertoaddRows = false
				_dg.allowUserToResizeRows = false
				_dg.allowUserToResizeColumns = false 
				_dg.AllowUserToOrderColumns = false
				_dg.columnHeadersHeightSizeMode = (dotNetClass "System.Windows.Forms.dataGridViewColumnHeadersHeightSizeMode").disableResizing
				_dg.AdvancedColumnHeadersBorderStyle.all = (dotnetclass "System.Windows.Forms.DataGridViewAdvancedCellBorderStyle").outset
				
				_dg.columnHeadersVisible = true									--para que las columnas no tengan titulo
				_dg.rowheadersvisible = false									--para que las filas no tengan titulo
				
				_dg.foreColor = (dotNetClass "System.Drawing.Color").black
				
				_dg.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 7.5					
				
				_dg.readonly = true
				_dg.multiSelect = false
				_dg.showCellTooltips = false
				_dg.selectionMode = (dotnetClass "System.Windows.Forms.DataGridViewSelectionMode").FullRowSelect
				
			)
			--DataGridView de listado de archivos
			dgFileList.allowUserToResizeColumns = true

			--Icono
			_column = (dotnetobject "System.Windows.Forms.DataGridViewImageColumn")
			_column.width = 25	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = ""
			dgFileList.columns.add _column

			--Ruta
			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = 305	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "File"
			dgFileList.columns.add _column

			--Info
			_column = (dotnetobject "System.Windows.Forms.DataGridViewImageColumn")
			_column.width = 25	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = ""
			dgFileList.columns.add _column

			--Variaciones de Nodos
			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = 55	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "N. Vars"
			dgFileList.columns.add _column

			--Variaciones de Asset
			_column = (dotnetobject "System.Windows.Forms.DataGridViewComboBoxColumn")
			_column.width = 95	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "Asset Vars"
			dgFileList.columns.add _column

			--Tipo de carga
			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = 110	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "LoadMode"
			dgFileList.columns.add _column

			--Checkeado o no
			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = 75	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "Checked"
			dgFileList.columns.add _column

			--Los demás
			_rowStyle = (dotnetObject "System.Windows.Forms.DataGridViewCellStyle")
			_rowStyle.selectionBackcolor = selectionBackcolor
			_rowStyle.selectionForecolor = selectionForecolor
			dgVariations.rowsDefaultCellStyle = _rowStyle

			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = dgNodes.width - 3	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "Node"
			dgNodes.columns.add _column
			
			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = 50		
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "Type"
			dgVariations.columns.add _column
			
			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = 60
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "Name"
			dgVariations.columns.add _column

			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = 100	
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "Value"
			dgVariations.columns.add _column
			
			_column = (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
			_column.width = 40		
			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = "Total"
			_column.ReadOnly = false
			dgVariations.columns.add _column
			
			_column = (dotnetobject "System.Windows.Forms.DataGridViewButtonColumn")
			_column.width = 50
			--_column.defaultCellStyle.backcolor = (dotnetclass "System.Drawing.Color").lightgray
 			_column.sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
			_column.HeaderText = ""
			_column.ReadOnly = false
			dgVariations.columns.add _column
		)
		
		----------------------------------------------------------------------------------------------
		-- @fn: undefined | createCallbacks | inicia todos callbacks y changeHandlers
		----------------------------------------------------------------------------------------------
		fn createSceneEvents = 
		(
			callbacks.addscript #filePostOpenProcess 	"lb.presetManager.rollMain.refreshUI()" id:#presetManager
			callbacks.addscript #filePostMerge 			"lb.presetManager.rollMain.refreshUI()" id:#presetManager
		)
		
		----------------------------------------------------------------------------------------------
		-- @fn: undefined | createCallbacks | inicia todos callbacks y changeHandlers
		----------------------------------------------------------------------------------------------
		fn removeSceneEvents = 
		(
			callbacks.removescripts id:#presetManager
			deleteAllChangeHandlers id:#presetManager
		)
		
		---------------------------------------------------------------------------
		--@fn: array | getFilesInScene | rellena el listado de ficheros que componen el asset
		---------------------------------------------------------------------------
		fn getFilesInScene =
		(
			_filesInScene = #()
			
			for _node in objects where lb.nodeInfo.hasNodeInfo _node do appendIfUnique _filesInScene _node.nodeInfo.fileHistory[1]
			
			_filesInScene
		)		
		
		---------------------------------------------------------------------------
		--@fn: boolean | isPresetFilenameOK | indica si el nombre de fichero es correcto para el preset
		--@gets: string | filename | 
		---------------------------------------------------------------------------
		fn isPresetFilenameOK filename =
		(
			_presetFileNameOK = false
			_notAssetPreset = false
			
			_presetFileName = getFilenameFile filename
			_presetFilePath = getFilenamePath filename
			
			_assetFolderParts = (filterString (getFileNamePath filename) "\\")
			
			-- Obtenemos directamente el primer archivo del file list, y de ahí capturamos el assetFolder. (Por ejemplo si guardamos en sequence)			
			_assetFolderMaxParts = (filterString (getFileNamePath ((getFilesInScene())[1])) "\\")
		
			_assetName = if _assetFolderParts.count > 2 then _assetFolderParts[_assetFolderParts.count-2] else ""
			
			if (_assetFolderParts[_assetFolderParts.count] == lb.nc.NC_presetFolderName) then
			(
				_presetFileNameOK = (matchpattern (getFileNameFile filename) pattern:(_assetName + "{*}_*_v??"))
					
 				--excepcion para spr
				if not _presetFileNameOK and (MatchPattern _assetName pattern:(lb.nc.NC_setPrefix + "_*")) then
				(
					_assetName = substituteString _assetName (lb.nc.NC_setPrefix + "_") (lb.nc.NC_sprPrefix + "_")
					_presetFileNameOK = (matchpattern (getFileNameFile filename) pattern:(_assetName + "{*}_*_v??"))	
				)
			)
			else
			(
				-- Como guardamos en sequence, se ha determinado que no tengamos carpeta preset, buscamos la de asset
				if (_assetFolderParts[2] == lb.nc.NC_seqFolderName) and _assetFolderParts[_assetFolderParts.count] == lb.nc.NC_assetFolderName then
				(
					_assetName = if _assetFolderMaxParts.count > 2 then _assetFolderMaxParts[_assetFolderMaxParts.count-2] else ""
					_presetFileNameOK = (matchpattern (getFileNameFile filename) pattern:(_assetName + "{*}_*_v??"))
				)
			)
			
			_presetFileNameOK
		)
		
		


		---------------------------------------------------------------------------
		--@fn: undefined | fillFileList | rellena el listado de ficheros que componen el asset
		---------------------------------------------------------------------------
		fn fillFileList =
		(
			dgFileList.rows.clear()

			_assets = lb.asset.getSceneAssets()
			_assetsFiles = for ast in _assets collect lb.asset.getAssetNodeInfoFiles ast
			
			-------------------------------------
			--rellena la informacion de archivos y assets de cada archivo

			_allFiles = #()
			_allFilesAssets = #()

			for i=1 to _assets.count do
				for _file in _assetsFiles[i] do
					if appendIfUnique _allFiles _file then append _allFilesAssets _assets[i]
			-------------------------------------

			_variations = #()
			
			_cont = 1

			
			for i=1 to _allFiles.count do
			(
				--lvFileList.items.add _allFiles[i]

				--dgFileList.items
				_row = (dotnetobject "System.Windows.Forms.DataGridViewRow") 
				_row.height = 23
				dgFileList.rows.add _row

				--Agregamos el icono
				_icon = lb.asset.getAssetIconFromPath _allFiles[i]
				--Celda de icono
				if _icon != undefined then
				(
					_row.cells.item[0].value = _icon
				)
				else
				(
					setClipboardBitmap (bitmap 20 20 color:(color 220 220 220 0))
					_row.cells.item[0].value = clipboardObj.GetImage() -- recupera la imagen del clipboard y la pone en el control
					clipboardObj.clear() --limpia el portapapeles
				)

				--Agregamos la ruta del fichero
				_row.cells.item[1].value = _allFiles[i]

				--Agregamos el botón de info (solo si es preset)
				if (getFilenameType _allFiles[i]) == ".prt" then
				(
					_icon = dotnetObject "System.Drawing.bitmap" ((dotnetclass "system.drawing.image").fromFile (lb.config.getToolsIconsPath() + "presetManager\\presetinfo_on.tif")) 20 20
				)
				else
				(
					_icon = dotnetObject "System.Drawing.bitmap" ((dotnetclass "system.drawing.image").fromFile (lb.config.getToolsIconsPath() + "presetManager\\presetinfo_off.tif")) 20 20
				)
				_row.cells.item[2].value = _icon

				--Agregamos las variaciones de asset al comboBox

				if (filterString (getFilenameFile _allFiles[i]) "(){}")[2] == undefined then 
				(
					_comboVars = undefined
				)
				else
				(
					_comboVars = (filterString (filterString (getFilenameFile _allFiles[i]) "(){}")[2] "-")[2]
				)

				if _comboVars == undefined then _comboVars = ""
				
				_row.cells.item[4].items.Add _comboVars
				_row.cells.item[4].Value = _comboVars

				--Agregamos el método de carga
				_row.cells.item[5].value = (_allFilesAssets[i].loadMode as string)

				--Agregamos si está checkeado
				if (getFilenameType _allfiles[i]) == ".max" then
				(
					_testChecked = if lb.fileInfo.isFileChecked _allFiles[i] then "CHECKED" else "UNCHECKED"
				)
				else
				(
					_testChecked = toUpper ((lb.presets.getPresetCheckedState _allFiles[i]) As String)
				)

				_row.cells.item[6].value = _testChecked
				_style = (dotNetObject "System.Windows.Forms.DataGridViewCellStyle")
								
				if _testChecked == "CHECKED" then
				(
					_style.backColor = okColor
				)
				else
				(
					_style.backColor = errorColor
				)
				_row.cells.item[6].style = _style


				--Agregamos el número de variaciones
				_variations[_cont] = #()

				_variationNodes = _allFilesAssets[i].hairNodesAll + _allFilesAssets[i].meshNodesAll

				for _node in _variationNodes do
				(
					_vars = lb.variations.getVariations _node assets:_allFilesAssets
					
					--nos aseguramos de que no añadimos objetos cuyas variaciones ya existan en el listado
					for j = _vars.count to 1 by -1 do
					(
						_existsVariation = false
						for _v in _variations[_cont] where _v.type == _vars[j].type do
						(
							case _v.type of 
							(
								#morph: if _v.morpherMod == _vars[j].morpherMod and _v.channel == _vars[j].channel then _existsVariation = true
								#material: (if _v.mat == _vars[j].mat then _existsVariation = true)
								--#asset: if _v.files[1] == _vars[j].files[1] then _existsVariation = true
							)--case
						)--for

						if not _existsVariation then append _variations[_cont] _vars[j]
					)--for
				)--for

				
				_row.cells.item[3].value = (_variations[_cont].count as string)

				_cont += 1
			)--for

			--if lvFileList.items.count != 0 then
			--(
			--	lvFileList.items.item[0].selected = true
			--	setFocus lvFileList
			--)			
		)
		
		---------------------------------------------------------------------------
		--@fn: undefined | fillNodes | rellena el grid con la información de los currRenderLayers
		---------------------------------------------------------------------------
		fn fillNodes =
		(
			_assets = lb.asset.getSceneAssets()
			_variations = #()
			_addedFiles = #()
			
			dgNodes.rows.clear()

			if dgFileList.SelectedRows.count != 0 then
			(
				_selIndex = dgFileList.SelectedRows.item[0].index

				_file = dgFileList.rows.item[_selIndex].cells.item[1].value
				
				--recorre los objetos de mesh del la escena que pertenezcan al archivo y tengan variaciones
				for _node in objects where lb.nc.ncOk _node.name and lb.nodeInfo.hasNodeInfo _node and (tolower _node.nodeInfo.fileHistory[1] == tolower _file) do
				(
					if ((lb.nc.getNamePart _node.name 3) == lb.nc.NC_classMesh or (lb.nc.getNamePart _node.name 3) == lb.nc.NC_classHair ) then
					(
						_vars = lb.variations.getVariations _node assets:_assets

						-- Nos aseguramos de que no añadimos objetos cuyas variaciones ya existan en el listado
						for i = _vars.count to 1 by -1 do
						(
							_existsVariation = false
							for _v in _variations where _v.type == _vars[i].type do
							(
								case _v.type of 
								(
									#morph: if _v.morpherMod == _vars[i].morpherMod and _v.channel == _vars[i].channel then _existsVariation = true
									#material: (/*if _v.mat == _vars[i].mat then _existsVariation = true*/)
									--#asset: if _v.files[1] == _vars[i].files[1] then _existsVariation = true
								)
							)
							
							if _existsVariation then deleteItem _vars i else append _variations _vars[i]
						)



						if (_vars.count > 0 or (lb.controller.isPoseFrozen _node #all and (_node.skinPos != _node.position or (eulerToQuat (EulerAngles  _node.skinRot.x _node.skinRot.y _node.skinRot.z)) != _node.rotation or _node.skinScale != _node.scale)) ) \
						and (findItem _addedFiles _node.name) == 0 then
						(
								_row = (dotnetobject "System.Windows.Forms.DataGridViewRow") 
								_row.height = 25
								dgNodes.rows.add _row
								_row.cells.item[0].value = _node.name
								append _addedFiles _node.name
						)
					)
					else if ((lb.nc.getNamePart _node.name 3) == lb.nc.NC_classAnim) then 
					(
						--Para los nodos de anim sólo miraremos que se haya movido en sus animtracks
						--Obtenemos tracks
						_nodeTracks = lb.animInfo.getTracksFromObject _node showTitleSeparators:false showSeparators:false
						--print _nodeTracks.count
						--Filtramos las que son de transformación
						_exist = false
						for i=_nodeTracks.count to 1 by -1 where not _exist do
						(
							if (filterString _nodeTracks[i].name ":")[1] == "transform" then
							(
								if _nodeTracks[i].track.value != undefined and _nodeTracks[i].track.value != _nodeTracks[i].defaultVal then
								(
									_row = (dotnetobject "System.Windows.Forms.DataGridViewRow") 
									_row.height = 25
									dgNodes.rows.add _row
									_row.cells.item[0].value = _node.name
									_exist = true
								)
							)
						)
					)
				)			
			)
			else dgNodes.rows.clear()

		)

		---------------------------------------------------------------------------
		--@fn: undefined | spinnerValueChangedEvent | rellena el grid con la información de los currRenderLayers
		---------------------------------------------------------------------------
		fn spinnerValueChangedEvent self events =
		(
			
			_index = (self.name as integer) + 1
			_variation = currentVariations[_index]
			_minValue = if _variation.type == #morph then 0 else 1
			_maxValue = _variation.numVariations
			
			if self.value >  _maxValue then self.value = _maxValue
			if self.value < _minValue then self.value = _minValue
			
			if oldValue != self.value then
			(
				_variation.setValue self.value
				
				if _variation.type == #asset then
				(
					_rollout = lb.presetManager.rollMain
					_meshIndex = _rollout.dgNodes.selectedRows.item[0].index
					
					_rollout.refreshUI()

					if _meshIndex <= (_rollout.dgNodes.rows.count - 1) then
						_rollout.dgNodes.rows.item[_meshIndex].selected = true
				)
			)
			
			oldValue = self.value
		)
		
		---------------------------------------------------------------------------
		-- Evento de cambiar el texto del comboBox
		---------------------------------------------------------------------------
		fn comboTextChangedEvent self events =
		(
			--Los comboboxes están nombrados por números en 0-index, 
			--se saca el índice de la variación a la que corresponde cada combo sumando 1
			_index = (self.name as integer) + 1
			_variation = currentVariations[_index]
			
			--Si en el struct de la variación no está seleccionada la que toca se la aplicamos usando
			--su función
			if _variation.submatName != self.text then
			(
				_variation.setValue self.text
				--lb.presetManager.rollMain.dgVariations.item 1 (_index -1).value = _variation.submatName
			)
			
		)
		
		---------------------------------------------------------------------------
		--@fn: undefined | spinnerMouseMoveEvent | rellena el grid con la información de los currRenderLayers
		---------------------------------------------------------------------------
		fn spinnerMouseDownEvent self events =
		(
			_button = events.button.toString()
			
			if _button == "Left" then
			(
				editingValues = true
				mousePos = mouse.screenPos
			)
			
			if _button == "Right" then
			(
				oldValue = self.value
				self.value = 0
			)
		)
		
		---------------------------------------------------------------------------
		--@fn: undefined | spinnerMouseMoveEvent | rellena el grid con la información de los currRenderLayers
		---------------------------------------------------------------------------
		fn spinnerMouseMoveEvent self events =
		(
			if editingValues then
			(
				_index = (self.name as integer) + 1
				_yOffset = mousePos.y - mouse.screenPos.y
				self.value += _yOffset
				self.refresh()
				mousePos = mouse.screenPos
			)
		)
		
		---------------------------------------------------------------------------
		--@fn: undefined | spinnerMouseMoveEvent | rellena el grid con la información de los currRenderLayers
		---------------------------------------------------------------------------
		fn spinnerMouseUpEvent self events =
		(
			editingValues = false
		)
		
		---------------------------------------------------------------------------
		--@fn: undefined | fillVariations | rellena el grid con la información de los currRenderLayers
		---------------------------------------------------------------------------
		fn fillVariations =
		(
			_nodeName = if dgNodes.selectedCells.count > 0 then dgNodes.selectedCells.item[0].value else undefined
			_node = if _nodeName != undefined then (execute ("$'" + _nodeName + "'")) else undefined
			_sceneAssets = lb.asset.getSceneAssets()
				
			dgVariations.rows.clear()
				
			for i = dgVariations.controls.count to 1 by -1 where dgVariations.controls.item[i-1].name != "" do
				dgVariations.controls.removeAt (i-1)
			
			currentVariations = #()
			dgVariations.update()
			
			if _node != undefined then
			(
				currentVariations = lb.variations.getVariations _node assets:_sceneAssets
				
				for i = 1 to currentVariations.count do
				(
					_var = currentVariations[i]
					
					_row = (dotnetobject "System.Windows.Forms.DataGridViewRow") 
					_row.height = 25
					dgVariations.rows.add _row
					
					_row.cells.item[0].value = _var.type as string
					_row.cells.item[1].value = _var.name

					if _var.type == #material then
					(
						_row.cells.item[2].value = _var.submatName
					)
					else
					(
						_row.cells.item[2].value = _var.value
					)
					
					_row.cells.item[3].value = _var.numVariations
					_row.cells.item[4].value = "random"
					_row.cells.item[4].style.backcolor = (dotnetclass "System.Drawing.Color").lightgray
					_row.cells.item[4].style.selectionBackColor = (dotnetClass "System.Drawing.Color").lightgray
					
					_yPos = ((i - 1) * _row.height) + dgVariations.ColumnHeadersHeight 
					
					if _var.type == #material then
					(
						_comboBox = dotnetobject "system.windows.forms.comboBox"
					
						if classof _node.material == XRef_Material then
						(
							_material = _node.material.GetSourceMaterial true
							_comboItems = (_material.materialList[finditem _material.names _var.matName].names As Array)
						)
						else
						(
							_comboItems = (_node.material.materialList[finditem _node.material.names _var.matName].names As Array)
						)

						_selectedIndex = -1
						for j=1 to _comboItems.count do
						(
							if _comboItems[j] == _var.submatName then
							(
								_selectedIndex = j-1
							)
							_comboBox.items.add _comboItems[j]
						)
						--_comboBox.Font = (dotnetObject "System.Drawing.Font" )
						--print _comboBox.Font.FontFamily
						_comboBox.name = (i - 1) as string
						_comboBox.location.x = dgVariations.columns.item[0].width + dgVariations.columns.item[1].width + 1
						_comboBox.location.y = (i - 1) * _row.height + dgVariations.columnHeadersHeight + 3
						_comboBox.width = dgVariations.columns.item[2].width
						_comboBox.SelectedIndex = _selectedIndex
						_comboBox.dropDownStyle = (dotnetclass "System.Windows.Forms.ComboBoxStyle").DropDownList
						--_comboBox.size.height = _comboBox.size.height + 5--dgVariations.rows.item[0].height
						--_comboBox.borderStyle = (dotnetClass "System.Windows.Forms.BorderStyle").none

						dotNet.setLifeTimeControl _comboBox #dotNet
						dotnet.addEventHandler _comboBox "SelectedIndexChanged" (lb.presetManager.rollMain.comboTextChangedEvent)
						_comboBox.parent = dgVariations
					)
					else
					(
						_spinner = dotnetobject "system.windows.forms.numericUpDown"
						_spinner.minimum = -10000
						_spinner.maximum = 10000
						_spinner.name = (i - 1) as string
						_spinner.location.x = dgVariations.columns.item[0].width + dgVariations.columns.item[1].width + 4
						_spinner.location.y = (i - 1) * _row.height + dgVariations.columnHeadersHeight + 7
						_spinner.width = dgVariations.columns.item[2].width - 4
						_spinner.borderStyle = (dotnetClass "System.Windows.Forms.BorderStyle").none
						_spinner.value = _var.value

						dotNet.setLifeTimeControl _spinner #dotNet
						
						dotnet.addEventHandler _spinner "valueChanged" (lb.presetManager.rollMain.spinnerValueChangedEvent)
						dotnet.addEventHandler _spinner "mouseDown" (lb.presetManager.rollMain.spinnerMouseDownEvent)
						dotnet.addEventHandler _spinner "mouseMove" (lb.presetManager.rollMain.spinnerMouseMoveEvent)
						dotnet.addEventHandler _spinner "mouseUp" (lb.presetManager.rollMain.spinnerMouseUpEvent)

						_spinner.parent = dgVariations
					)
				)
				
				--Variaciones de transformación (mesh)
				if (filterString _node.name "_").count >= 3 and (filterString _node.name "_")[3] == lb.nc.NC_meshFilename and _node.parent == undefined and _node.modifiers[#Skin] == undefined then
				(
					if lb.controller.isPoseFrozen _node #all then
					(
						--print _node
						--Si la pose ha variado
						if _node.skinPos != _node.position or (eulerToQuat (EulerAngles  _node.skinRot.x _node.skinRot.y _node.skinRot.z)) != _node.rotation or _node.skinScale != _node.scale then
						(
							_row = (dotnetobject "System.Windows.Forms.DataGridViewRow") 
							_row.height = 25
							dgVariations.rows.add _row
							
							_row.cells.item[0].value = "transform"
							_row.cells.item[2].value = _node.transform As String
							_row.cells.item[4].value = "random"
						)
					)
				)
				--Piezas de anim
				else if (filterString _node.name "_").count >= 3 and (filterString _node.name "_")[3] == lb.nc.NC_animFilename then
				(
					--Obtenemos tracks
					_nodeTracks = lb.animInfo.getTracksFromObject _node showTitleSeparators:false showSeparators:false
					--print _nodeTracks.count
					--Filtramos las que son de transformación
					for i=_nodeTracks.count to 1 by -1 do
					(
						if (filterString _nodeTracks[i].name ":")[1] != "transform" then
						(
							deleteItem _nodeTracks i
						)
						else
						(
							if _nodeTracks[i].track.value != undefined and _nodeTracks[i].track.value != _nodeTracks[i].defaultVal then
							(
								--reprint ((_nodeTracks[i].track.value As String) + " != " + (_nodeTracks[i].defaultVal As String))
								_row = (dotnetobject "System.Windows.Forms.DataGridViewRow")
								_row.height = 25
								dgVariations.rows.add _row

								_row.cells.item[0].value = "animTransform"
								_row.cells.item[1].value = (filterString _nodeTracks[i].name ":")[(filterString _nodeTracks[i].name ":").count]
								_row.cells.item[2].value = (_nodeTracks[i].track.value As String)
							)
						)
					)
				)
			)
		)
		
		---------------------------------------------------------------------------
		--@fn: undefined | checkNoDuplicateNames | rellena el grid con la información de los currRenderLayers
		---------------------------------------------------------------------------
		fn checkNoDuplicateNames =
		(
			_assets = lb.asset.getSceneAssets()
			_assetGroups = #()
			
			for _asset in _assets do
			(
				if _asset.type == lb.nc.NC_chrPrefix then
				(
					--_assetNameWithoutPrefix = 
				)
			)
		)
		
		
		------------------------------------------------
		--@fn: undefined | refreshUI | refresca todo el interface
		---------------------------------------------------------------------------------------------------------------
		fn refreshUI fromUIelement:#all =
		(
			_selIndex = if (isProperty dgNodes #selectedRows) and dgNodes.selectedRows.count > 0 then dgNodes.selectedRows.item[0].index else 999999
			_uiControlNum = 1000
			
			case fromUIelement of
			(
				#all: _uiControlNum = 0
				#filesList: _uiControlNum = 1
				#nodesList: _uiControlNum = 2
				#variationsList: _uiControlNum = 3
			)
			
			if _uiControlNum <= 1 then fillFileList()
			if _uiControlNum <= 2 then fillNodes()
			if _uiControlNum <= 3 then fillVariations()

			if _selIndex <= (dgNodes.rows.count - 1) then dgNodes.rows.item[_selIndex].selected = true
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--almacena posicion
			lb.xml.setAttribute parent.cfgFile ("rollMain/pos") "x" (((getDialogPos rollMainDef).x) as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/pos") "y" (((getDialogPos rollMainDef).y) as string)
			
			--almacena tamaño
			lb.xml.setAttribute parent.cfgFile ("rollMain/size") "width" (rollMainDef.width as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/size") "height" (rollMainDef.height as string)
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			_width = (lb.xml.getAttribute parent.cfgFile ("rollMain/size") "width") as integer
			_height = (lb.xml.getAttribute parent.cfgFile ("rollMain/size") "height") as integer
				
			--posicion
			_posX = (lb.xml.getAttribute parent.cfgFile ("rollMain/pos") "x") as integer
			_posY = (lb.xml.getAttribute parent.cfgFile ("rollMain/pos") "y") as integer
				
			--establece minimos
			if _width < minRollWidth then _width = minRollWidth
			if _height < minRollHeight then _height = minRollHeight
			if _posX < 0 then _posX = 0
			if _posY < 0 then _posY = 0
				
			--aplica los valores
			rollMainDef.width = _width
			rollMainDef.height = _height
			setDialogPos rollMainDef [_posX,_posY]
		)

		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo

			if size.x < minRollWidth then (size.x = minRollWidth; rollMainDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollMainDef.height = size.y)
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--calcula el incremento en ancho y alto, respecto al mínimo.

			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			_offset = [(size.x - dialogWidth),(size.y - dialogHeight)]
			------------------------------------------------------------------------------

			------------------------------------------------------------------------------
			--redimension en horizontal

			if _increment.x != 0 then --si hay incremento
			(		
				dgFileList.width = _increment.x + 695
				if dgFileList.columns.count != 0 then dgFileList.Columns.Item[1].width = _increment.x + 305
			)--if
			
			dgNodes.width += _offset.x
			if dgNodes.columns.count > 0 then dgNodes.columns.item[0].width += _offset.x 
			
			dgVariations.pos.x += _offset.x
			btnRandomizeNode.pos.x += _offset.x
			dialogWidth = size.x
			------------------------------------------------------------------------------
			_upperOffset = (lb.math.round (_offset.y * 0.6)) 
			_lowerOffset = _offset.y - _upperOffset
			------------------------------------------------------------------------------
			--redimension en vertical
			dgFileList.height += _upperOffset
			lblVariations.pos.y += _upperOffset
			btnRandomizeNode.pos.y += _upperOffset
			dgNodes.pos.y += _upperOffset
			dgNodes.height += _lowerOffset
			dgVariations.pos.y += _upperOffset
			dgVariations.height += _lowerOffset
			dialogHeight = size.y
			------------------------------------------------------------------------------
		)
		
		----------------------------------------------------------------------------------
		-- Pasamos el path del archivo de asset y tras buscar en el datagrid nos retorna su método de carga.
		----------------------------------------------------------------------------------
		fn getLoadMode assetVariationPath = 
		(
			_loadMode = ""
			for i=0 to dgFileList.rows.count-1 do
			(
				if dgFileList.rows.item[i].cells.item[1].Value == assetVariationPath do
				(
					_loadMode = dgFileList.rows.item[i].cells.item[5].value
				)
			)
			_loadMode
		)



		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMainDef open do
		(
			loadSettings()
			initUI()


			refreshUI()
			createSceneEvents()

			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMainDef close do
		(
			saveSettings()
			
			parent.opened = false --indica que la herramienta está cerrada.
			updateToolbarButtons()
			
			removeSceneEvents()
		)
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollMainDef resized size do
		(			
			resize size
		)
		
		------------------------------------------------
		on btnLoad pressed do
		(
			gc()
			
			_filename = getOpenFileName caption:"Load Preset" types:"Preset(*.prt)|*.prt" historyCategory:"Presets"
			
			if _filename != undefined then
			(
				removeSceneEvents()
				
				lb.presets.load _filename renameParts: chkRenameParts.checked renamePartsMaterials: chkRenamePartsMaterials.checked loadSkinData:chkLoadSkins.checked
				refreshUI from:#nodesList
				
				createSceneEvents()
			)
			
			gc()
		)
		
		------------------------------------------------
		on chkRenameParts changed state do
		(
			chkRenamePartsMaterials.checked = chkRenameParts.checked
			chkRenamePartsMaterials.enabled = chkRenameParts.checked
		)

		------------------------------------------------
		on btnSave pressed do
		(
			_process = true

			_unCheckedFiles = #()
			_sceneAssets = lb.asset.getSceneAssets()
			
			--averigua si hay archivos sin verificar entre los cargados en la escena
			_sceneFiles = getFilesInScene()
			for _sceneFile in _sceneFiles do
			(
				if (getFilenameType _sceneFile) == ".max" then
				(
					if not lb.fileInfo.isFileChecked _sceneFile then append _uncheckedFiles _sceneFile
				)
				else
				(
					if (lb.presets.getPresetCheckedState _sceneFile) != #checked then
						append _uncheckedFiles _sceneFile
				)
			)

			--for _file in getFilesInScene() where not lb.fileInfo.isFileChecked _file do append _uncheckedFiles _file

			--si hay archivos sin verificar hay que decidir si continuar o no con la operacion
			if _unCheckedFiles.count != 0 then
			(
				_errorMessage = "Hay ficheros que no se han guardado verificados:\n\n"
				for _file in _unCheckedFiles do append _errorMessage (" - " + _file + "\n")
				_errorMessage += "\nSi se guarda el preset, deberá salvar verificados los archivos que lo componen posteriormente.\n¿Desea continuar?"

				_process = lb.message.show _errorMessage type:#query pos:undefined size:[600,150] modal:true
			)--if

			if _process then
			(
				_duplicatedObjects = ""
				_simpleNames = #()
				for o in Objects do
				(
					if not (appendIfUnique _simpleNames o.name ) then
					(
						_duplicatedObjects += o.name + "\n"
					)
				)

				if _duplicatedObjects.count == 0 then
				(
					_materials = lb.materials.getSceneMaterials()
					_duplicatedMaterials = ""
					_simpleNames = #()
					for m in _materials where (filterString m.name "_").count == 3 do 
					(
						if not (appendIfUnique _simpleNames m.name) then
						(
							_duplicatedMaterials += m.name + "\n"
						)
					)

					if _duplicatedMaterials.count == 0 then
					(
						if _sceneAssets.count > 0 then
						(
							_filename = getSaveFileName caption:"Save Preset" types:"Preset(*.prt)|*.prt" historyCategory:"Presets"
							
							if _filename != undefined then 
							(
								--	Si todo está correcto grabamos el preset
								if (isPresetFilenameOK _filename) then
								(
									setWaitCursor()
									if lb.presets.save _filename then
									(
										lb.message.show "Preset guardado correctamente." type:#message pos:undefined size:[300,75] modal:true
									)
									else
									(
										lb.message.show "Infinite loop detected aborting save." type:#message pos:undefined size:[300,75] modal:true
									)
									setArrowCursor()
								)
								else --	Si hay errores en el nombre del fichero lo indicamos
								(
									_errorMessage = "El nombre del preset o la ruta no son correctos.\n\n"
									_errorMessage += "Debe cumplir el formato [chr|prp|set|spr]_<nombreAsset>{<nombrePreset>}_[draft|mesh|anim]_v01.max\n"
									_errorMessage += "y estar contenido en la carpeta \"preset\" del asset del mismo nombre o en la carpeta \"asset\" de una secuencia que use el preset."
									lb.message.show _errorMessage type:#message pos:undefined size:[300,75] modal:true
								)--if
							)
						)
						else
						(
							lb.message.show "No hay assets que guardar" type:#message pos:undefined size:[300,75] modal:true
						)--if else
					)--If de materiales duplicados
					else
					(
						lb.message.show ("No se puede guardar el preset porque hay materiales duplicados: \n\n" + _duplicatedMaterials)
					)
				)
				else
				(
					
					lb.message.show ("No se puede guardar el asset porque hay objetos duplicados: \n\n" + _duplicatedObjects)
				)	
			)--if
		)
		
		------------------------------------------------
		on dgVariations cellClick events do
		(
			if events.columnIndex == 4 then
			(
				if dgVariations.rows.item[events.rowIndex].cells.item[0].value != "transform" or dgVariations.rows.item[events.rowIndex].cells.item[0].value != "animTransform" then
				(
					_index = events.rowIndex + 1
					currentVariations[_index].setValue #random
					dgVariations.controls.item[_index+1].value = currentVariations[_index].value
				)
				else
				(
					lb.message.show "Transform variations cannot perform random operations."
				)
			)
		)
		
		------------------------------------------------
		on btnRefresh pressed do
		(
			refreshUI()
		)
		
		------------------------------------------------
		on btnRandomizeAsset pressed do
		(
			_assets = lb.asset.getSceneAssets()
			
			
			for _a in _assets do
			(
				_variationNodes = _a.meshNodesAll + _a.hairNodesAll
				for _obj in _variationNodes where not (isDeleted _obj) and (lb.variations.hasVariations _obj) do
				(
					_variations = lb.variations.getVariations _obj
					for _var in _variations do _var.setValue #random
				)
			)
			
			refreshUI()
		)
		
		------------------------------------------------
		on btnRandomizeNode pressed do
		(
			for _var in currentVariations do
				_var.setValue #random
			
			refreshUI()
		)
		
		-------------------------------------------------
		on btnLoadVariations pressed do
		(

			--Buscaremos una ruta para facilitar el acceso a los presets de la escena

			_assets = lb.asset.getSceneAssets()
			_filesInScene = #()
			for _asset in _assets do
			(
				for _node in _asset.meshNodesAll where lb.nodeInfo.hasNodeInfo _node do appendIfUnique _filesInScene _node.nodeInfo.fileHistory[1]
			)

			_route = filterString _filesInScene[1] "\\"
			_route = _route[1] + "\\" + _route[2] + "\\" + _route[3] + "\\" + _route[4] + "\\" + _route[5] + "\\" + lb.nc.NC_versionFolderName + "\\" + lb.nc.NC_presetFolderName + "\\"
			_presetFile = getOpenFileName filename:_route caption: "Archivo de preset con la referencia de variaciones" types:"Preset File(*.prt)|*.prt"
			--print _presetFile
			--Cargaremos el xml del asset correspondiente para obtener la información necesaria
			_validPreset = true

			if (_presetFile != undefined) then
			(
				_filename = getFileNameFile _presetFile 
				_filenameParts = (filterString _filename "_")[3]
				if _filenameParts != lb.nc.NC_classMesh then
				(
					_validpreset = false
					lb.message.show "Por favor selecciona un preset de mesh"
				)		
			)
			
			if ((_presetFile != undefined) and _validPreset ) then
			(
				_xmlDoc = lb.xml.newXmlDoc()
				_xmlLoaded = _xmlDoc.load _presetFile

				if _xmlLoaded then
				(
					struct _strVariation (node, type, value, matId, matName, subMatName, morphChannel, morphChannelName, trackName)
					_meshVariations = #()

					_xmlFileElements = _xmlDoc.root.getNodes "preset/files/file"

					for _element in _xmlFileElements do
					(

						_filename = _element.getProperty "path"
						
						_nodeVariationXMLnodes = _element.getNodes "nodeVariations"
						for _variationXMLnode in _nodeVariationXMLNodes do 
						(
							_variationOwner = try(_variationXMLnode.getProperty "name") catch (undefined)
							if _variationOwner != undefined then
							(
								--En el caso de hacerlo generico generar una pattern aqui.
								--_objNameParts = filterString _variationOwner "_"
								--_objNamePattern = "*"+_objNameParts[3]+"_"+_objNameParts[4]+"_"+_objNameParts[5]+"*"
							)
							
							_varElements = _variationXMLnode.getNodes "variation"
							for _varElement in _varElements do
							(
								_varType = execute ("#" + (_varElement.getProperty "type")) 
								case _vartype of
								(
									#Morph:
									(
										_varValue = try (_varElement.getProperty "value") as integer catch( undefined )
										_varMorphChannel = try (_varElement.getProperty "channel") as integer catch( undefined )
										_varMorphChannelName = try (_varElement.getProperty "channelName") as string catch( "undefined" )
										for _asset in _assets do
										(
											--La variación solo se aplicará si existe un nodo compatible en la escena
											for _node in _asset.meshNodesAll where matchpattern _node.nodeInfo.nameHistory[_node.nodeInfo.nameHistory.count] pattern: _variationOwner do 
											(
												append _meshVariations (_strVariation node:_node type:_varType value:_varValue morphChannel:_varMorphChannel morphChannelName:_varMorphChannelName)
											)
										)
									)
									#material: 
									(
										_varMatName = try (_varElement.getProperty "matName") as String catch("undefined")
										_varSubMatName = try (_varElement.getProperty "subMatName") as String catch("undefined")
										if _varMatName != "undefined" and _varSubMatName != "undefined" then
										(
											for _asset in _assets do
											(
												--La variación solo se aplicará si existe un nodo compatible en la escena
												for _node in _asset.meshNodesAll where matchpattern _node.nodeInfo.nameHistory[_node.nodeInfo.nameHistory.count] pattern: _variationOwner do 
												(
													append _meshVariations (_strVariation node:_node type:_varType matName:_varMatName subMatName:_varSubMatName)
												)
											)
										)
										else
										(
											_varMatId = try (_varElement.getProperty "matID") as integer catch( undefined )
											_varValue = try (_varElement.getProperty "value") as integer catch( undefined )
											if _varMatId != undefined and _varValue != undefined then
											(
												for _asset in _assets do
												(
													--La variación solo se aplicará si existe un nodo compatible en la escena
													for _node in _asset.meshNodesAll where matchpattern _node.nodeInfo.nameHistory[_node.nodeInfo.nameHistory.count] pattern: _variationOwner do 
													(
														
														if _varValue == -1 then
														(
															_material = if classof _node.material == XRef_Material then (_node.material.getSourceMaterial true) else _node.material
															_varValue = _material[_varMatId].materialIDList[_material[_varMatId].materialIDList.count] As integer
														)
														append _meshVariations (_strVariation node:_node type:_varType value:_varValue matId:_varMatId)
													)
												)
											)	
										)
									)
								)
							)
						)
					)--foir _element
					--print _meshVariations
					for _var in _meshVariations do
					(
						_nodeVariations = lb.variations.getVariations _var.node 
						for _nodeVar in _nodeVariations where _nodeVar.type == _var.type do
						(
							case _var.type of
							(
								#material:
								(
									--Si tenemos nombre compararemos con él, sino buscaremos id.
									if (_var.matName != undefined) and (_var.matName == _nodeVar.matName) then
									(
										_nodeVar.setValue _var.subMatName
										lb.variations.removeMatVariationAttribute _var.node
										lb.variations.addMatVariationAttributeValue _var.node matName:_var.matName subMatName:_var.subMatName
										lb.variations.setStoredMatVariation _var.node


									)--if
									--Si sólo hay id entonces rellenaremos nosotros el nombre de _nodeVar que si lo tiene cargado desde getVariations
									else if  (_var.matId == _nodeVar.matId) then
									(
										_nodeVar.setValue _var.Value
										lb.variations.removeMatVariationAttribute _var.node
										lb.variations.addMatVariationAttributeValue _var.node matName:_nodeVar.matName subMatName:_nodeVar.subMatName
										lb.variations.setStoredMatVariation _var.node
									)
								)--material

								#morph:
								(	
									if _var.morphChannelName != undefined then
										if _nodeVar.name == _var.morphChannelName then _nodeVar.setValue _var.Value
									else
										if _nodeVar.channel == _var.morphChannel then _nodeVar.setValue _var.Value
								)
							)--case
						)--for
					)--f	
				)--if _xmlLoaded
			)
		)
		------------------------------------------------
		on dgNodes selectionChanged events do
		(
			fillVariations fromUIelement:#variations
		)
		
		------------------------------------------------
		on dgNodes doubleClick events do
		(
			_nodeName = if dgNodes.selectedCells.count > 0 then dgNodes.selectedCells.item[0].value else undefined
 			_node = if _nodeName != undefined then (execute ("$'" + _nodeName + "'")) else undefined
				
			if _node != undefined then
				select _node
		)

		------------------------------------------------
		on dgFileList CellClick event do
		(
			if event.columnIndex != 2 then
			(
				refreshUI fromUIelement:#nodesList
			)
			else
			(
				if (getFilenameType dgFileList.rows.item[event.rowIndex].cells.item[1].value) == ".prt" then
				(
					if lb.presetInfoManager.isOpen() then lb.presetInfoManager.destroyInterface()
					lb.presetInfoManager.run presetFileName:dgFileList.rows.item[event.rowIndex].cells.item[1].value
				)
			)

			if event.columnIndex == 4 then
			(
				--Pasamos al struct el índice y el se encarga de hacer la llamada.
				parent.loadPopup dgFileList.rows.item[event.rowIndex].cells.item[1].value
				--print dgFileList.rows.item[event.rowIndex].cells.item[0].value
			)
		)
		
	)--rollMainDef
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@struct: tl_presetManager | Contiene la herramienta de setup de opciones de videos de previo
	------------------------------------------------------------------------------------------------------------------------------------------------
	struct tl_presetManager
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		def = (classof this),				--@var: def | Almacena la definicion del struct.
		defFile = getThisScriptFilename(),	--@var: defFile | Almacena la ruta del propio archivo de script que contiene la definicion.
		
		category = #video,					--@var: category | Categoria de la tool.
		className = lb.getFileToolName (getThisScriptFilename() as string),	--@var: name | Nombre de la tool.
		description = "Tool plantilla",		--@var: description | Descripcion de la tool.
		
		cfgFile = (lb.config.getToolsIniPath()) + (lb.getFileToolName (getThisScriptFilename() as string)) + ".cfg",	--@var: cfgFile | Archivo de configuracion de la tool.
			
		opened = false,			--@var: opened | Indica si la herramienta está abierta.
		
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		assetVariationToBeChanged = "",
		------------------------------------------------------------------------------------------------
		--LIBRARIES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--ROLLOUTS
		------------------------------------------------------------------------------------------------
		
		rollMain = rollMainDef,	--@var: rollMain | Almacena el rollout principal de la herramienta.
			
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
			
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: boolean | isOpen | Devuelve información true o false, si la herramienta está abierta o cerrada.
		------------------------------------------------
		fn isOpen =
		(
			this.opened
		),

		fn responseFn variationPath =
		(
			--Si hemos realizado un cambio real
			if variationPath != this.assetVariationToBeChanged then
			(
				--Sacamos el modo de carga del asset antiguo
				_loadMode = rollMain.getLoadMode this.assetVariationToBeChanged
				
				if _loadMode != "" then
				(
					--Borramos el asset antiguo
					_assetToDelete = undefined
					_asts = lb.asset.getSceneAssets()
					for _ast in _asts do
					(
						if _ast.fullname == ((filterString (getFilenameFile this.assetVariationToBeChanged) "_")[1] + "_" + (filterString (getFilenameFile this.assetVariationToBeChanged) "_")[2]) do
						(
							_assetToDelete = _ast
						)
					)

					lb.asset.deleteAsset _assetToDelete

					--Cargamos el nuevo
					lb.asset.loadAsset variationPath (_loadMode As Name)

					--Refrescamos el interfaz
					rollmain.refreshUI()

					--Limpiamos la variable
					this.assetVariationToBeChanged = ""
				)
			)
		),

		fn loadPopup assetPath =
		(
			this.assetVariationToBeChanged = assetPath
			lb.presetManagerAssetVariationPopup.run assetPath:assetPath callbackFn:this.responseFn
		),
		------------------------------------------------
		--@fn: undefined | createInterface | Crea el interface inicial de la herramienta
		------------------------------------------------
		fn createInterface =
		(
			--crea el interface, lo redimensiona y lo reposiciona
			createDialog this.rollMain lockwidth:false lockheight:false pos:[-10000,0] style:#(#style_toolwindow, #style_titlebar, #style_sysmenu, #style_resizing)
		),
		
		------------------------------------------------
		--@fn: undefined | destroyInterface | Destruye el interface de la herramienta.
		------------------------------------------------
		fn destroyInterface =
		(
			destroyDialog this.rollMain --cierra la herramienta.			
		),--destroyInterface
		
		------------------------------------------------
		--@fn: undefined | run | Lanza la herramienta.
		------------------------------------------------
		fn run =
		(
			this.createInterface() --crea el interface.
			this.opened = true --indica que la herramienta está abierta
		),--execute
		
		------------------------------------------------
		--@fn: undefined | close | Cierra la herramienta.
		------------------------------------------------
		fn close =
		(
			this.destroyInterface() --destruye el interface.
			this.opened = false --indica que la herramienta está cerrada.
		),
		
		------------------------------------------------
		--@fn: undefined | initSubLibraries | Inicializa todas las sublibrerías en el orden establecido.
		------------------------------------------------
		fn initSubLibraries =
		(
			_subLibraries = #()
			
			for sl in _subLibraries do sl.init()
		),
		
		------------------------------------------------
		--@fn: undefined | init | Inicializa la librería.
		------------------------------------------------
		fn init =
		(		
			this.initSubLibraries() --inicialza las librerías hijas
		),		
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--@event: create | Ejecución al crearse la instancia del struct.
		------------------------------------------------
		on create do
		(
			lb.addTool this --añade la tool a la libreria principal
			--this.run()
		)
		
	)--tl_presetManager
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--EJECUCION
	------------------------------------------------------------------------------------------------------------------------------------------------
	
	--try(lb.presetManager.close())catch()
	tl_presetManager() --crea la herramienta
)

