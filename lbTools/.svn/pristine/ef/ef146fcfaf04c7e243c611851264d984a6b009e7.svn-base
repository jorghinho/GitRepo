------------------------------------------------------------------------------------------------------------------------------------------------
--Descripcion: Herramienta Plantilla.
------------------------------------------------------------------------------------------------------------------------------------------------
(
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollAdvancedDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollAdvancedDef "Advanced"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 200	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		local colWidths = #(92,25,25,25,25)	-- Ancho de las columnas del listview
		local rowHeight = 15						-- Alto de cada fila del listView

		local lvSelItems						-- objetos seleccionados en el listview
		local lvSelectedItems = #()		-- copia auxiliar que guarda temporalmente los objetos seleccionados en el listview
		local restoreSelection = false	-- indica si hay que restaurar la selección del listview

		local checkSymbol = "X"
		local uncheckSymbol = "•"

		------------------------------------------------------------------------------------------------
		--CONTROLS-
		------------------------------------------------------------------------------------------------		

		button btnSel "Sel." pos:[5,3] width:20 height:20 images:#(iconpath + "mainToolbar_16i.bmp", undefined, 98, 11, 11, 12, 12,true) toolTip:"Select all objects in selected layers"
		button btnSelAll "Sel." pos:[25,3] width:20 height:20 images:#(iconpath + "mainToolbar_16i.bmp", undefined, 98, 19, 19, 20, 20,true) toolTip:"Select all asset objects"
		button btnSelFlag "Flg" pos:[45,3] width:20 height:20 toolTip:"Select asset objects by flag"
		button btnRefresh "Refresh" pos:[150,3] width:50 height:20 toolTip:"refresh the list obtaining scene assets again"
		
		dotNetControl lvLayers "System.Windows.Forms.DataGridView" pos:[5,25] width:195 height:115

		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		----------------------------------------------------------------------------------
		-- inicia los layers del asset número num
		----------------------------------------------------------------------------------
		fn setLvColumnsWidth =
		(
			if lvLayers.rows.count * rowHeight >= lvLayers.height then
			(
				lvLayers.columns.item[0].width = colWidths[1] - 18
				--lblHidden.pos.x = 103
				--lblFrozen.pos.x = 130
			)
			else
			(
				lvLayers.columns.item[0].width = colWidths[1]
				--lblHidden.pos.x = 120
				--lblFrozen.pos.x = 148
			)
		)

		----------------------------------------------------------------------------------
		-- Actualiza los controles según el Asset seleccionado
		----------------------------------------------------------------------------------
		fn initListView =
		(
			lvLayers.rows.clear()
			lvLayers.columns.clear()
			lvLayers.allowUsertoaddRows = false
			lvLayers.allowUserToResizeRows = false
			lvLayers.allowUserToResizeColumns = false
			lvLayers.backgroundcolor = lb.assetManager.rollMain.backColor						-- color del fondo
			lvLayers.rowsdefaultcellstyle.backcolor = lb.assetManager.rollMain.backColor	-- color por defecto de las celdas
			lvlayers.AdvancedColumnHeadersBorderStyle.all = (dotnetclass "System.Windows.Forms.DataGridViewAdvancedCellBorderStyle").outset
			--lvlayers.AdvancedColumnHeadersBorderStyle.bottom = (dotnetclass "System.Windows.Forms.DataGridViewAdvancedCellBorderStyle").outset
			lvlayers.columnHeadersDefaultCellStyle.alignment = (dotnetclass "System.Windows.Forms.DataGridViewContentAlignment").middleCenter
			lvlayers.columnHeadersDefaultCellStyle.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 8 --(dotnetclass "System.Drawing.FontStyle").bold
			lvlayers.columnHeadersHeight = 18
			
			lvLayers.cellborderstyle = (dotnetclass "System.Windows.Forms.DataGridViewCellBorderStyle").single	-- tipo de borde de las celdas
			lvLayers.gridcolor = (dotnetclass "System.Drawing.Color").lightgray
			lvLayers.rowheadersvisible = false
			--lvLayers.columnheadersvisible = false
			lvLayers.readonly = true
			lvLayers.showCellTooltips = false			
			
			lvlayers.columns.add "Col1" "Layer"
			lvlayers.columns.add "Col2" "Hid"
			lvlayers.columns.add "Col3"  "Frz"
			lvlayers.columns.add "Col4"  "H"
			lvlayers.columns.add "Col5"  "F"
			
			lvlayers.columns.item[0].headerCell.style.alignment = (dotnetclass "System.Windows.Forms.DataGridViewContentAlignment").middleLeft
			
			for i = 1 to lvLayers.columns.count do
			(
				lvlayers.columns.item[i-1].sortmode = (dotnetclass "System.Windows.Forms.DataGridViewColumnSortMode").notSortable
				lvLayers.Columns.item[i-1].width = colWidths[i]
			)
			
			lvLayers.columns.item[1].defaultCellStyle.alignment = (dotnetclass "System.Windows.Forms.DataGridViewContentAlignment").middleCenter
			lvLayers.columns.item[2].defaultCellStyle.alignment = (dotnetclass "System.Windows.Forms.DataGridViewContentAlignment").middleCenter
			lvLayers.columns.item[3].defaultCellStyle.alignment = (dotnetclass "System.Windows.Forms.DataGridViewContentAlignment").middleCenter
			lvLayers.columns.item[4].defaultCellStyle.alignment = (dotnetclass "System.Windows.Forms.DataGridViewContentAlignment").middleCenter
			lvLayers.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 7.5
		)
		----------------------------------------------------------------------------------
		-- Actualiza los controles según el Asset seleccionado
		----------------------------------------------------------------------------------
		fn fillLayerControls =
		(
			lvLayers.rows.clear()
			--chr = asset name:""
			lb.asset.listedLayersObjs = #()
			
			if lb.asset.selAssets.count != 0 then
			( 
				isThereXrefSceneAssets = false --para saber si hay algun asset de tipo xrefScene
				isThereNonXrefSceneAssets = false --true si hay assets que no son de xref
				assetsToWork = #()
				
				for s in lb.asset.selAssets do
					append assetsToWork lb.asset.listedAssets[s]
				
				for i = 1 to lb.nc.NC_classTypes.count do --recorre los tipos de pieza para saber si porner una fila para ello en el listado
				(
					type = lb.nc.NC_classTypes[i] --as name
					
					objs = #() --objetos del tipo actual encontrados en los assets seleccionados
					
					-------------------------------------------------------------------------------------------
					--en caso de que sea de tipo mesh se pueden dividir los objetos por nivel de detalle
					meshObjsByLevel = #() --sera un array de arrays de objetos por nivel
					meshHiddenObjsByLevel = #() --lo mismo para los que lleven flag de oculto
					meshFrozenObjsByLevel = #() --lo mismo para los que lleven flag de congelado
					
					if type == lb.nc.NC_classMesh then
						for j=1 to lb.nc.NC_flagsDetailLevels.count do
						(
							meshObjsByLevel[j] = #()
							meshHiddenObjsByLevel[j] = #()
							meshFrozenObjsByLevel[j] = #()
						)
						
					-------------------------------------------------------------------------------------------
					
					hiddenNodes = #() --objetos con flag h del tipo actual en los assets seleccionados
					frozenNodes = #() --objetos con flag f del tipo actual en los assets seleccionados
					
					for a in assetsToWork do
					(
 						/*if type == lb.nc.NC_classMesh then
						(
							for j=1 to lb.nc.NC_flagsDetailLevels.count do
							(
								f = lb.nc.NC_flagsDetailLevels[j]
								
								meshObjsByLevel[j] += (lb.asset.getAssetNodesByType a type flags:#(f))
								meshHiddenObjsByLevel[j] += (lb.asset.getAssetNodesByType a type flags:#(f,lb.nc.NC_hiddenFlag))
								meshFrozenObjsByLevel[j] += (lb.asset.getAssetNodesByType a type flags:#(f,lb.nc.NC_frozenFlag))
							)
						)
						else
						(*/
							objs += lb.asset.getAssetNodesByType a type
							hiddenNodes += lb.asset.getAssetNodesByType a type flags:#(lb.nc.NC_hiddenFlag)
							frozenNodes += lb.asset.getAssetNodesByType a type flags:#(lb.nc.NC_frozenFlag)
							isThereNonXrefSceneAssets = true
						--)
					)
			-- 						else
			-- 							isThereXrefSceneAssets = true
					
					-- Si se encuentran objetos para el tipo de capa actual, creamos una nueva fila
					if objs.count != 0 then --or (meshObjsByLevel[1] != undefined) then
					(
						--si estamos en tipo mesh, deglosamos la capa por niveles de detalle
						/*if type == lb.nc.NC_classMesh then
						(
							for j=1 to lb.nc.NC_flagsDetailLevels.count where meshObjsByLevel[j].count != 0 do
							(
								append lb.asset.listedLayersObjs meshObjsByLevel[j]
								
								state = lb.asset.getNodesState meshObjsByLevel[j]
								
								hiddenNodesState = lb.asset.getNodesState meshHiddenObjsByLevel[j]
								frozenNodesState = lb.asset.getNodesState meshFrozenObjsByLevel[j]
								
								-- Creamos la nueva fila del Data Grid View y rellenamos sus valores
								row = (dotnetobject "System.Windows.Forms.DataGridViewRow")
								row.height = rowHeight
								
								lvLayers.rows.add row
									
								row.cells.item[0].value = tolower ((type as string) + "-" + lb.nc.NC_flagsDetailLevels[j])
								row.cells.item[1].value = if (findstring state "h" == undefined) then uncheckSymbol else checkSymbol
								row.cells.item[2].value = if (findstring state "f" == undefined) then uncheckSymbol else checkSymbol
								row.cells.item[3].value = if (findstring hiddenNodesState "h" == undefined) then uncheckSymbol else checkSymbol
								row.cells.item[4].value = if (findstring frozenNodesState "f" == undefined) then uncheckSymbol else checkSymbol
							)
						)
						else
						(*/
							append lb.asset.listedLayersObjs objs
							
							state = lb.asset.getNodesState objs
							
							hiddenNodesState = lb.asset.getNodesState hiddenNodes --(lb.asset.getAssetNodesByType ast type flags:#(lb.nc.NC_hiddenFlag))
							frozenNodesState = lb.asset.getNodesState frozenNodes --(lb.asset.getAssetNodesByType ast type flags:#(lb.nc.NC_frozenFlag))
							
							-- Creamos la nueva fila del Data Grid View y rellenamos sus valores
							row = (dotnetobject "System.Windows.Forms.DataGridViewRow")
							row.height = rowHeight
							
							lvLayers.rows.add row
								
							row.cells.item[0].value = (type as string)
							row.cells.item[1].value = if (findstring state "h" == undefined) then uncheckSymbol else checkSymbol
							row.cells.item[2].value = if (findstring state "f" == undefined) then uncheckSymbol else checkSymbol
							row.cells.item[3].value = if (findstring hiddenNodesState "h" == undefined) then uncheckSymbol else checkSymbol
							row.cells.item[4].value = if (findstring frozenNodesState "f" == undefined) then uncheckSymbol else checkSymbol
						--)--if type mesh
					)--if objs.count
						
					--setLvColumnsWidth()
					
				)--for lb.nc.NC_classTypes
				
			-- 				if isThereXrefSceneAssets and not isThereNonXrefSceneAssets then
			-- 				(
			-- 					row = (dotnetobject "System.Windows.Forms.DataGridViewRow")
			-- 					lvLayers.rows.add row
			-- 					row.cells.item[0].value = "<xRefAsset>"
			-- 				)
				
				--setLvColumnsWidth()
			)--if 	
		)

		----------------------------------------------------------------------------------
		-- Anota en la variable lvSelectedItems los elementos actualmente seleccionados
		----------------------------------------------------------------------------------
		fn getLvSelectedItems =
		(
			lvSelectedItems = #()
			for i = 1 to lvSelItems.count do append lvSelectedItems lvSelItems.item[i-1].rowIndex
		)

		----------------------------------------------------------------------------------
		-- Restaura la selección del listview según lo anotado en lvSelectedItems
		----------------------------------------------------------------------------------
		fn restoreLvSelectedItems =
		(
			lb.assetManager.rollAdvanced.lvLayers.clearSelection()
			for i =1 to lvSelectedItems.count do 
				lvLayers.rows.item[lvSelectedItems[i]].cells.item[0].selected = true
		)

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
			_id = ((parent.className + "_" + (substituteString parent.rollMain.name "Def" "")) as name)
			callbacks.addscript #filePostMerge "lb.assetManager.rollMain.resetSceneAssets()" id:_id
			callbacks.addscript #filePostOpenProcess "lb.assetManager.rollMain.resetSceneAssets()" id:_id
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
			_id = ((parent.className + "_" + (substituteString parent.rollMain.name "Def" "")) as name)
			callbacks.removescripts id:_id
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollAdvancedDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollAdvancedDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------

		----------------------------------------------------------------------------------
		on btnSel pressed do
		(
			clearSelection()
			selObjs = #()
			for i = 1 to lvSelItems.count do
			(
				index = lvSelItems.item[i-1].rowindex + 1
				join selObjs lb.asset.listedLayersObjs[index]
			)
			select selObjs
		)
			
		----------------------------------------------------------------------------------
		on btnSelAll pressed do
		(
			clearSelection()	-- La siguiente línea no deselecciona si no se encuentran nodos en el asset, por eso deseleccionamos primero
			
			for l in lb.asset.listedLayersObjs do
				selectMore l
		)
		
		----------------------------------------------------------------------------------
		on btnSelFlag pressed do
		(
			clearSelection()	-- La siguiente línea no deselecciona si no se encuentran nodos en el asset, por eso deseleccionamos primero
			lb.assetManager.rollMain.showAvailableFlags()
		)

		----------------------------------------------------------------------------------
		on btnRefresh pressed do
		(
			selAssetsFullNames = #()
			for s in lb.asset.selAssets do
				append selAssetsFullNames lb.asset.sceneAssets[s].fullname
			
			lb.assetManager.rollMain.resetSceneAssets()

			lb.asset.selAssets = #()
			for i=1 to lb.asset.sceneAssets.count do
				for s in selAssetsFullNames do
					if lb.asset.sceneAssets[i].fullname == s then
						append lb.asset.selAssets i
				
			lb.assetManager.rollMain.refreshControls()
		)

		----------------------------------------------------------------------------------
		on lvLayers cellMouseDown events do
		(
			local clickXpos = events.X
			local columns = lvLayers.columns
			local index = events.rowIndex
			
			
			if (index != -1) and (lb.asset.listedAssets[lb.asset.selAssets[1]] != undefined)/* and (lb.asset.listedAssets[selAssets[1]].isXrefScene == false)*/ then
			(
				local clickedRow = lvLayers.rows.item[index]
				local clickedCell = lvLayers.rows.item[index].cells.item[events.columnIndex]
				
				if not clickedRow.cells.item[0].selected then
				(
					if not keyboard.controlPressed and not keyboard.shiftPressed then
						lvLayers.clearSelection()
					
					clickedRow.cells.item[0].selected = true
				)
				
				getLvSelectedItems()
				
				state = (clickedCell.value == checkSymbol) --lb.asset.getNodesState lb.asset.listedLayersObjs[index+1]
				n = lvSelItems.count
				
				with undo off
				(
					for i = 1 to n do
					(
						index = lvSelItems.item[i-1].rowIndex + 1
						row = lvLayers.rows.item[index-1]
						
						--if (lvLayers.item (events.columnIndex) (i-1)).value != "" then --si no es una fila de xref
							case events.columnIndex of
							(
								1:-- HIDE
								(
									row.cells.item[1].value = if state then uncheckSymbol else checkSymbol
									lb.asset.setHiddenState lb.asset.listedLayersObjs[index] (not state) includeHiddenFlag:false
								)
								
								2: -- FREEZE
								(
									row.cells.item[2].value = if state then uncheckSymbol else checkSymbol
									lb.asset.setFrozenState lb.asset.listedLayersObjs[index] (not state) includeFrozenFlag:false
								)
								
								3:-- HIDDEN OBJECTS
								(
									row.cells.item[3].value = if state then uncheckSymbol else checkSymbol
									
									type = row.cells.item[0].value
									tParts = filterString type "-"
									type = tParts[1]
									
									auxFlags = #(lb.nc.NC_hiddenFlag)
									if tParts[2] != undefined then auxFlags = #(tParts[2]) + auxFlags
									
									nodes = #()
									for s in lb.asset.selAssets do
										nodes += (lb.asset.getAssetNodesByType lb.asset.listedAssets[s] #(type) flags:auxFlags)
									
									lb.asset.setHiddenState nodes (not state) includeHiddenFlag:true
								)
								
								4:-- FROZEN OBJECTS
								(
									row.cells.item[4].value = if state then uncheckSymbol else checkSymbol
									
									type = row.cells.item[0].value
									tParts = filterString type "-"
									type = tParts[1]
									auxFlags = #(lb.nc.NC_frozenFlag)
									if tParts[2] != undefined then auxFlags = #(tParts[2]) + auxFlags
									
									nodes = #()
									for s in lb.asset.selAssets do
										nodes += (lb.asset.getAssetNodesByType lb.asset.listedAssets[s] #(type) flags:auxFlags)
									
									lb.asset.setFrozenState nodes (not state) includeFrozenFlag:true
								)
							)--case
					)
				)--with undo of
				
			)
		)
		
		----------------------------------------------------------------------------------
		on lvLayers cellMouseUp events do
		(
			if events.columnIndex != 0 then
				restoreLvSelectedItems()
			
			btn = events.button.tostring()
			
			if btn == "Right" then 
			(
				createRmenu events.x events.y
			)
			else --NEW
			(
				if keyboard.controlPressed or keyboard.shiftPressed then
				(
					local clickXpos = events.X
					local columns = lvLayers.columns
					local index = events.rowIndex
					
					thereAreXrefSceneAssets = false
					
					for s in lb.asset.selAssets where lb.asset.listedAssets[s].isXrefScene do
						thereAreXrefSceneAssets = true
					
					if (index != -1) and  (lb.asset.listedAssets[lb.asset.selAssets[1]] != undefined) and not thereAreXrefSceneAssets then
					(
						local clickedRow = lvLayers.rows.item[index]
						local clickedCell = lvLayers.rows.item[index].cells.item[events.columnIndex]
					
						clickedRow.cells.item[0].selected = true
					)
				
					getLvSelectedItems() --guarda la seleccion de filas
				)
			)
			
			setfocus lb.assetManager.rollMain
		)
		
		----------------------------------------------------------------------------------
		
		on lvLayers selectionChanged do
		(
			for i = 1 to lvLayers.selectedCells.count do
				if i <= lvLayers.selectedCells.count then
					if lvLayers.selectedCells.item[i-1].columnIndex != 0 then
						lvLayers.selectedCells.item[i-1].selected = false
						
			lvSelItems = lvLayers.selectedCells
		)
		
		--------------------------------------------------------------
		on lvLayers cellMouseDoubleClick events do
		(
			if (events.columnIndex == 0) and (events.rowIndex != -1) then
			(
				index = events.rowIndex + 1
				if not keyboard.controlPressed then clearSelection()
				
				select lb.asset.listedLayersObjs[index]
			)
		)

		------------------------------------------------
		--COMMON
		------------------------------------------------

		on rollAdvancedDef rolledUp state do 
		(
			parent.heightAdjust 0
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollAdvancedDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollAdvancedDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			initListView()
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollAdvancedDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollAdvancedDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollFXDef | Contiene la herramienta rollFXDef.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollFXDef "FX"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		

		local minRollWidth = 180	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 30	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		checkbutton chkLoadFxBySelection "Assets by Selection" pos:[5,2] width:105 height:20 checked:true
		checkbutton chkLoadFxBySelAsset "Selected Assets" pos:[110,2] width:95 height:20
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollFXDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollFXDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		--Evento de pulsar el boton usar los assets de los objetos seleccionados.
		on chkLoadFxBySelection changed state do 
		(
			if state then
				chkLoadFxBySelAsset.checked = false
			else
				chkLoadFxBySelection.checked = true
		)
		
		--Evento de pulsar el boton usar los assets seleccionados en el asset manager.
		on chkLoadFxBySelAsset changed state do
		(
			if state then
				chkLoadFxBySelection.checked = false
			else
				chkLoadFxBySelAsset.checked = true
		)

		on rollFXDef rolledUp state do 
		(
			parent.heightAdjust 6
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollFXDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollFXDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollFXDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollFXDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollLoadFxDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollLoadFxDef "Load Specific Fx"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		button btnMergeFx "Merge Asset Fx" pos:[5,5] width:195 height:20
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollLoadFxDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollLoadFxDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		on btnMergeFx pressed do
		(
			-- Antes de empezar siquiera a cargar pondremos como activa la capa 0 y guardamos la que estaba activa antes.
			_lastActiveLayer = LayerManager.current
			(LayerManager.getLayerFromName "0").current = true
			
			-- Cogemos los assets a cargar de los seleccionados con el asset checker.
			if parent.rollFX.chkLoadFxBySelAsset.checked then 
				_assetsToLoad = lb.assetManager.getSelectedAssets()
			-- Cogemos los assets a cargar de los seleccionados con el asset manager.
			else if parent.rollFX.chkLoadFxBySelection.checked then
				_assetsToLoad = lb.asset.getAssetsFromNodes (getCurrentSelection())
			
			--Miramos que la carpeta de rig del asset actual esté actualizada.
			--Creamos un array para los assets que no cumplen los requisitos para ser cargados.
			_notValidAssets = #()
			
			--Recorreremos todos los assets que pretendemos cargar.
			for i=1 to _assetsToLoad.count do
			(
				--Si la carpeta de rig del asset actual está sin actualizar lo añadiremos a la lista de no aptos.
				if not (doesFileExist (_assetsToLoad[i].folder + "rig") and lb.svn.svnIsFolderVersioned (_assetsToLoad[i].folder + "rig")) then
				(
					append _notValidAssets _assetsToLoad[i]
				)
				--O no hay nada dentro de la de fx (o archivos con nombres no válidos)
				else if (getFiles (_assetsToLoad[i].folder + "rig\\fx\\" + (filterString _assetsToLoad[i].fullname "#")[1] + "_fx_v*")).count == 0 then
				(
					append _notValidAssets _assetsToLoad[i]
				)
				--Vamos a comprobar que haya al menos un archivo válido en la carpeta sino a la lista de no válidos.
				else
				(
					_files = (getFiles (_assetsToLoad[i].folder + "rig\\fx\\" + (filterString _assetsToLoad[i].fullname "#")[1] + "_fx_v*"))
					_correctFile = ""
						
					for j=1 to _files.count do
						if lb.math.isNumeric (substring (getFilenameFile _files[j])  ((getFilenameFile _files[j]).count - 1) ((getFilenameFile _files[j]).count)) then
							_correctFile = _files[j]
						
					if _correctFile == "" then
					(
						append _notValidAssets _assetsToLoad[i]
					)
				)
			)
			
			--Si hay assets erróneos los mostraremos en un popup.
			if _notValidAssets.count > 0 then
			(
				_feedback = _notValidAssets[1].fullname
				
				for i=2 to _notValidAssets.count do
					_feedBack += (", " + _notValidAssets[i].fullname)
				
				_feedback += "."
				
				lb.message.show ("Some assets are outdated or lack of fx file: " + _feedBack + " They wont be loaded.") type:#message pos:undefined size:[300,75] modal:true
			)
			
			--Vamos a crear un flag para indicar si ya hemos preguntado para sobreescribir los assets de fx existentes 
			--y otro para saber que hemos decidido
			_askToOverwrite = undefined --Primero estará a undefined, a true para preguntar por el primero y a false luego para no preguntar por los demás.
			_overwrite = false
			
			--Ahora recorreremos todos los que son válidos mirando para sacar la ultima versión de su archivo y cargarlo.
			for i=1 to _assetsToLoad.count where finditem _notValidAssets _assetsToLoad[i] == 0 do
			(
				
				--Primero sacaremos la última versión del archivo de fx que corresponda.
				_files = getFiles (_assetsToLoad[i].folder + "rig\\fx\\" + (filterString _assetsToLoad[i].fullname "#")[1] + "_fx_*")
				
				_latestFile = ""
				
				--Los recorreremos y cogeremos la última versión del archivo de fx que queremos cargar.
				for j=1 to _files.count do
				(
					if lb.math.isNumeric  (substring (getFilenameFile _files[j])  ((getFilenameFile _files[j]).count - 1) ((getFilenameFile _files[j]).count)) then
					(
						if _latestFile == "" then
							_latestFile = _files[j]
						else
						(
							if (substring (getFilenameFile _files[j])  ((getFilenameFile _files[j]).count - 1) ((getFilenameFile _files[j]).count)) As Number >= \
							(substring (getFilenameFile _latestFile)  ((getFilenameFile _latestFile).count - 1) ((getFilenameFile _latestFile).count)) As Number then
							(
								_latestFile = _files[j]
							)
						)
					)
				)
				
				--Miraremos si el asset que queremos cargar está ya en la escena.
				_fileAssets = getFileInfoAssets _latestFile
				_existingAssets = #()
				
				--Una vez tengamos los nombres de todos los subassets cogeremos los de fx y buscaremos a ver si están en la escena.
				for j=1 to _fileAssets.count where (filterString _fileAssets[j] "_")[1] == lb.nc.NC_fxPrefix do
				(
					-- Para ello sacaremos los subassets del actual...
					_currentSubAssets = lb.asset.getDependentAssets _assetsToLoad[i] lb.asset.sceneAssets
					
					-- ...y compararemos sus nombres con los que queremos cargar apilando los existentes en un array.
					for k=1 to _currentSubAssets.count do
					(
						if (filterString _currentSubAssets[k].fullname "#")[1] == _fileAssets[j] then
						(
							--Si no hemos preguntado todavia == undefined activaremos el flag de preguntar para sobreescribir
							if _askToOverwrite == undefined then
								_askToOverwrite = true
							
							append _existingAssets _currentSubAssets[k]
						)
					)
				)
				
				--Preguntamos si se desea sobreescribir los assets que hay ya en la escena
				if _askToOverwrite != undefined and _askToOverwrite then
				(	
					--Volvemos a poner el flag de preguntar a falso.
					_askToOverwrite = false
					
					if (lb.message.show "Some assets are already loaded in scene, ¿Do you want to overwrite them?" type:#query pos:undefined size:[300,75] modal:true) then
						_overwrite = true
					else
						_overwrite = false
				)
				
				--Ahora sacaremos los objetos de dentro del archivo de fx.
				_fxAssetNames = getMAXFileObjectNames _latestFile
				
				--No todos los assets que hemos cargado son de fx por que hay que quitarlos.
				for j=_fxAssetNames.count to 1 by -1 do
					if (filterString _fxAssetNames[j] "_")[1] != lb.nc.NC_fxPrefix then
						deleteItem _fxAssetNames j
				
				--Si hemos decidido sobreescribir los existentes haremos un deleteAsset de ellos.
				if _overwrite then
				(
					for j=_existingAssets.count to 1 by -1 do
					(
			-- 						print "overwrite"
						lb.asset.deleteAsset _existingAssets[j]
						deleteItem _existingAssets j
					)
				)
				--Si en cambio hemos decidido no sobreescribir, tendremos que eliminar de la lista de objetos a cargar los de esos assets.
				else
				(
					for j=1 to _existingAssets.count do
						for k=_fxAssetNames.count to 1 by -1 do
							if matchpattern _fxAssetNames[k] pattern: ((filterString _existingAssets[j].fullname "#")[1] + "*") then
							(
								deleteItem _fxAssetNames k
							)
				)
				
				--Comprobamos que no hayamos eliminado todos.
				if _fxAssetNames.count !=0 then 
				(
			-- 					print "Entro"
					--Hacemos un backup de los atmosféricos que hay en la escena.
					_oldAtmospherics = #()
					for j=1 to numAtmospherics do append _oldAtmospherics (getAtmospheric j)
					
					--Cargamos los assets y recogemos los nuevos nodos.
					_loadedNodes = lb.asset.loadAsset _latestFile #merge objectNames:_fxAssetNames
					
					--Ahora renombraremos los objetos nuevos y sus atmosféricos.
					if (filterString _assetsToLoad[i].fullname "#")[2] == undefined then
						_assetIndex = ""
					else
						_assetIndex = (filterString _assetsToLoad[i].fullname "#")[2]
					
					--Miraré si hay capas con los nombres de los objetos nuevos que tengo que cargar,
					_newLayers = #()
					
					--Recorremos todos los nombres de subassets a crear y creamos sus layers si no están creados ya.
					for j=1 to _fileAssets.count where (filterString _fileAssets[j] "_")[1] == lb.nc.NC_fxPrefix do
					(
						if _assetIndex == "" then
							_nameToCompare = _fileAssets[j]
						else
							_nameToCompare = (_fileAssets[j] + "#" + _assetIndex)
						
						--Si no hemos encontrado una capa con el nombre del nuevo asset a cargar crearemos una nueva
						if (LayerManager.getLayerFromName _nameToCompare) == undefined then
							LayerManager.newLayerFromName _nameToCompare
					)
					
					--Recorreremos los nodos cargados para irlos renombrando y colocando en la capa que les corresponde
					for j=1 to _loadedNodes.count do
					(
						--Si es un objeto que se renombra solo, muy probablemente ya tenga el índice por lo que lo quitaremos de la segunda parte del nombre de su capa
						--para que no sea agregado dos veces.
						if matchPattern _loadedNodes[j].name pattern: "*->*" then
						(
							if _assetIndex != "" then
								_newNodeLayerName = (filterString _loadedNodes[j].name "_")[1] + "_" + (filterString (filterString _loadedNodes[j].name "_")[2] "#")[1] + "#" + _assetIndex
							else
								_newNodeLayerName = (filterString _loadedNodes[j].name "_")[1] + "_" + (filterString (filterString _loadedNodes[j].name "_")[2] "#")[1]
						)
						else
						(
							if _assetIndex != "" then
								_newNodeLayerName = (filterString _loadedNodes[j].name "_")[1] + "_" + (filterString _loadedNodes[j].name "_")[2] + "#" + _assetIndex
							else
								_newNodeLayerName = (filterString _loadedNodes[j].name "_")[1] + "_" + (filterString _loadedNodes[j].name "_")[2]
						)
						--Lo agregamos a la capa que le corresponde
						_currentLayer = LayerManager.getLayerFromName _newNodeLayerName
						_currentLayer.addNode  _loadedNodes[j]
						
						--Lo renombramos (sólo si no es uno de los que se renombran solos)
						if not matchPattern _loadedNodes[j].name pattern: "*->*" then
							_loadedNodes[j].name = substituteString _loadedNodes[j].name ((filterString _loadedNodes[j].name "_")[1] + "_" + (filterString _loadedNodes[j].name "_")[2]) _newNodeLayerName
					)
					
					--Una vez hemos renombrado los objetos miraremos si ha quedado alguna capa vacía colgando (fruto de haber cargado un #001 sin existir el que no tiene indice)
					--esto es debido a que al hacer merge los objetos vienen con su capa ya de serie, pero al moverlos todos a su nueva capa la antigua permanece.
					for j=1 to _fileAssets.count where (filterString _fileAssets[j] "_")[1] == lb.nc.NC_fxPrefix do
					(
						--Buscamos la capa del asset sin numerar, si existe y está vacía la eliminaremos
						if (Layermanager.getLayerFromName _fileAssets[j]) != undefined then
						(
							_nodes = #()
							(Layermanager.getLayerFromName _fileAssets[j]).nodes &_nodes
							if _nodes.count == 0 then
								LayerManager.deleteLayerByName _fileAssets[j]
						)
					)
					
					
					--Renombraremos los atmosféricos de los objetos.
					for j=1 to numAtmospherics where lb.nc.ncOK (getAtmospheric j).name type:#atmospheric and (getAtmospheric j).name != "FusionWorks Renderer" do
					(
						--Si el atmosférico no estaba antes en la lista es que es nuevo
						if finditem _oldAtmospherics (getAtmospheric j) == 0 then
						(
							--Si pertenece a un asset con numero se lo añadiremos.
							if _assetIndex != "" then
							(
								(getAtmospheric j).name = (filterString (getAtmospheric j).name "_")[1] + "_"+ (filterString (getAtmospheric j).name "_")[2] + "#" + _assetIndex + "_" + (filterString (getAtmospheric j).name "_")[3]
							)
						)
					)
					
					--Me creo un booleano por si no encuentra el objeto al que tiene que aplicarse el attach.
					_objectFound = true
					
					--Ahora toca alinear los objetos que tengan attachObjectToFace al objeto.
					for j=1 to _loadedNodes.count where _objectFound do
					(
						--Obtenemos los controladores de attachObjectToFace del objeto 
						_attachProControllers = lb.attachObjectToFaceFunctions.getAttachProControllers _loadedNodes[j]
						
						--Si tiene dicha información lo alinearemos de nuevo.
						if _attachProControllers[1] != undefined and _attachProControllers[2] != undefined and _attachProControllers[3] != undefined then
						(
							--Antes de alinearlo si el objeto al que pertenece tiene un índice se lo añadiremos a su información (para que no se alineen todos al que no lo tiene)
							if _assetIndex != "" then
							(
								_targetObjParts = (filterString _attachProControllers[1].targetObj "_")
								
								_attachProControllers[1].targetObj = _targetObjParts[1] + "_" + _targetObjParts[2] + "#" + _assetIndex + "_" + _targetObjParts[3] + "_"  \
								+ _targetObjParts[4] + "_" + _targetObjParts[5] + "_" + _targetObjParts[6] + "_" + _targetObjParts[7]
							)
							
							--Una vez está todo bien nombrado sacaremos el struct de attachObjectToFace
							_attachPro = lb.attachObjectToFaceFunctions.getAttachProInfo _loadedNodes[j]
							
							--Si no encontramos el objeto al que queremos atachar lanzamos un mensaje de error.
							if _attachPro.targetObj != undefined then
							(
								case _attachPro.AOTFattachMode of 
								(
									#animBake:
										lb.attachObjectToFaceFunctions.createAnimFromVertex _loadedNodes[j] _attachPro.targetObj _attachPro.face barCoords:_attachPro.barCoords initialOffset:_attachPro.initialOffset inheritRotation:_attachPro.inheritRotation keepOffset:_attachPro.keepOffset alignToFace:_attachPro.alignToFace flipAxis:_attachPro.flipAxis xAxis:_attachPro.xAxis
									
									#attach:
										_attachPro.posController.update()
								)
							)
							else
							(
								_objectFound = false
							)
						)
					)--for j=1 to _loadedNodes.count where _objectFound do
					
					--Si no hemos encontrado el objeto entonces.
					if not _objectFound then
					(
						
						lb.message.show "Target object to attach not found check fx file for errors. Verify if mesh and anim objects names are the same." type:#message pos:undefined size:[300,75] modal:true
						_assetsToDelete = lb.asset.getAssetNodes _loadedNodes
						
						if _assetsToDelete.count == 1 then
						(
							lb.asset.deleteAsset _assetsToDelete[1]
						)
					)
				) -- if _fxAssetNames.count !=0
			)--for i=1 to _assetsToLoad.count where finditem _notValidAssets _assetsToLoad[i] == 0 do
			
			--Al terminar ponemos como activa la que estaba antes.
			_lastActiveLayer.current = true	
		)-- on btnMergeFx pressed do

		on rollLoadFxDef rolledUp state do 
		(
			parent.heightAdjust 6
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollLoadFxDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollLoadFxDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollLoadFxDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollLoadFxDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollFxDetailDef | Contiene la herramienta rollFxDetailDef.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollFxDetailDef "Fx Detail Level"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local selectedFxAsset = undefined

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		groupBox grpPFDetailLevel "PF Quantity Multipliers and Display" pos:[5,5] width:195 height:70
		spinner spnVisualizationQuantity "Vis: " pos:[20,23] width:80 height:20 range:[0.0,10000.0,100.0]
		spinner spnRenderQuantity "Rnd: " pos:[115,23] width:80 height:20 range:[0.0,10000.0,100.0]
		label lblDisplayType "Display Type: " pos:[13,48] width:70 height:20
		dropdownList ddlDisplayType pos:[85,46] width:110 height:20 items:#("None","Dots","Ticks","Circles","Lines","Bounding Boxes","Geometry","Diamonds","Boxes","Asterisks","Triangles")
		
		groupBox grpABDetailLevel "Afterburn Detail Level" pos:[5,75] width:195 height:45
		button btnOpenEnvDialog "Open env dialog" pos:[10,92] width:85 height:20
		label lblAFDisplayType "Display:" pos:[98,95] width:50 height:20
		dropdownList ddlAFDisplayType pos:[139,92] width:57 height:20 items:#("None","Sphere","Circle")
		
		groupBox grpFFXDetailLevel "FumeFx Detail Level" pos:[5,122] width:195 height:230
		groupBox grpFFXAssetLevels "                                 " pos: [10,138] width:185 height:40
		checkBox chkFFXAssetLevels "Asset Simulations" pos:[15,136] width:100 height:20 checked:true
		radiobuttons rdoFFXAssetLevels  pos:[15,156] width:100 labels:#("Low","Medium  ","High") columns:3 default:2
		
		checkBox chkFFXSequenceLevels "Use Sequence Simulation" pos:[15,183] width:140 height:20 checked:false
		
		groupBox grpFFXCustomLevels "                         " pos: [10,208] width:185 height:45
		checkBox chkFFXCustomLevels "Select Simulation" pos:[15,206] width:100 height:20 checked:false
		edittext edtFFXCustomLevels pos:[10,226] height:20 width:160 readOnly:true
		button btnFFXCustomLevels "..." pos:[170,226] width:20 height:20
		
		label lblFFXPlayFrom "Play simulation from:" pos:[15,261] width:130 height:20
		spinner spnFFXPlayFrom pos:[130,261] width:65 height:20 range:[-1000000,1000000,0] type:#integer
		label lblFFXPlayTo "Play simulation to:" pos:[15,281] width:100 height:20
		spinner spnFFXPlayTo pos:[130,281] width:65 height:20 range:[-1000000,1000000,100] type:#integer
		label lblFFXOffset "Simulation offset:" pos:[15,301] width:100 height:20
		spinner spnFFXOffset pos:[130,301] width:65 height:20 range:[-1000000,1000000,0] type:#integer
		button btnFFXRunSimulation "Run Simulation" pos:[10,326] width:185 height:20
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		-----------------------------------------------------------------------------------------
		-- Desbloquea los controles del rollout 
		-----------------------------------------------------------------------------------------
		fn unlockControls = 
		(
			--Controles de PFlow
			spnVisualizationQuantity.enabled = true
			spnRenderQuantity.enabled = true
			ddlDisplayType.enabled = true
			lblDisplayType.enabled = true
			
			--Controles de Afterburn
			lblAFDisplayType.enabled = true
			ddlAFDisplayType.enabled = true
		)
		
		
		-----------------------------------------------------------------------------------------
		-- Bloquea los controles del rollout
		-----------------------------------------------------------------------------------------
		fn lockControls = 
		(
			--Controles de PFlow
			spnVisualizationQuantity.enabled = false
			spnRenderQuantity.enabled = false
			ddlDisplayType.enabled = false
			lblDisplayType.enabled = false
			
			--Controles de Afterburn
			lblAFDisplayType.enabled = false
			ddlAFDisplayType.enabled = false
			
			--Ponemos todos los controles de FFX como desactivados
			--Custom controls
			chkFFXCustomLevels.enabled = false
			chkFFXCustomLevels.checked = false
			edtFFXCustomLevels.enabled = false
			btnFFXCustomLevels.enabled = false
			
			--Sequence controls
			chkFFXSequenceLevels.checked = false
			chkFFXSequenceLevels.enabled = false
			
			--Asset controls
			chkFFXAssetLevels.enabled = false
			chkFFXAssetLevels.checked = false
			rdoFFXAssetLevels.state = 2
			rdoFFXAssetLevels.enabled = false
			
			--Simulation frame offset controls
			--Los controles de los rangos de los cachés.
			spnFFXPlayFrom.enabled = false
			spnFFXPlayTo.enabled = false
			spnFFXOffset.enabled = false
			
			--El botón de simulación
			btnFFXRunSimulation.enabled = false
		)
		
		
		------------------------------------------------------------------------------
		-- Le pasamos un asset y la calidad y nos devuelve la ruta de su simulación
		------------------------------------------------------------------------------
		fn getFFXAssetSimulationPath asset quality:#medium basePath:"\\\\lbdata002\\z\\simulation\\" =
		(
			_path = basePath
			
			--Miraremos si el asset es de fx o es un subasset de fx.
			--Si es un asset de fx.
			if matchPattern asset.folder pattern:"*\\rig\\fx\\" then
			(
				_folderParts = (filterString asset.folder "\\")
				--Montaremos en _path la ruta del asset sin z: del principio y sin las carpetas rig y fx del final 
				for i=2 to (_folderParts.count-2) do
				(
					_path += _folderParts[i] + "\\"
				)
			)	
			else
			(
				_folderParts = (filterString asset.folder "\\")
				
				--Montaremos en _path la ruta del asset sin z: del principio
				for i=2 to _folderParts.count do
				(
					_path += _folderParts[i] + "\\"
				)
			)
			
			--Montaremos la carpeta del plugin y la versión del asset.
			_path += "fumeFx\\v" + (formattedPrint asset.version format:"02d") + "\\"
			
			--En función de la calidad sacaré una ruta u otra.
			case quality of
			(
				#low: _path += "low\\"
				#medium: _path += "medium\\"
				#high: _path += "high\\"
				#none: _path += ""
			)
			
			_path
		)
		
		
		------------------------------------------------------------------------------
		-- Retorna la ruta de la secuencia actual, si el archivo no es de secuencia
		-- devuelve ""
		------------------------------------------------------------------------------
		fn getFFXSequenceSimulationPath basePath:"\\\\lbdata002\\z\\simulation\\" =
		(
			_path = basePath
			
			--Monto el path directamente en la carpeta de secuencia
			_path += "sequence\\"
			
			if lb.nc.ncOK maxfilename type:#seqfile then
				--Monto el numero de secuencia y el de cámara en la ruta.
				_path += "seq_" + (filterString (getFilenameFile maxfilename) "_")[2] + "\\cam\\" + (filterString (getFilenameFile maxfilename) "_")[3] + "\\"
			else
				_path = "" --no tenemos que dejar poner la ruta
			
			_path
		)
		
		
		------------------------------------------------------------------------------
		-- Aplica el path de simulación a la lista de nodos de ffx pasados por array
		------------------------------------------------------------------------------
		fn applyFFXSimulationPath ffxNodes ffxPath =
		(
			--Recorreremos la lista de nodos e iremos poniendo sus rutas de simulación.
			for i=1 to ffxNodes.count where classof ffxNodes[i] == FumeFX do
			(
				_simulationFileName = lb.nc.NC_fxPrefix + "_" + (filterString (filterString ffxNodes[i].name "_")[2] "#")[1] + "_" + (filterString ffxNodes[i].name "_")[5]
				
				if not doesFileExist ffxPath then
					if not (makeDir ffxPath all:true) then
						messageBox ("Simulation path <" + ffxPath +"> could not be created. Check your write permissions.")
				
				--Aplicamos la ruta
			-- 				print "Applying default path\n"
				ffxNodes[i].setPath (ffxPath + _simulationFilename + "_default_.fxd") "default"
			-- 				print "Applying wavelet path\n"
				ffxNodes[i].setPath (ffxPath + _simulationFilename + "_wavelet_.fxd") "wavelet"
			-- 				print "Applying retimer path\n"
				ffxNodes[i].setPath (ffxPath + _simulationFilename + "_retimer_.fxd") "retimer"
			)
		)
		
		-------------------------------------------------------------------------------
		-- Activa o desactiva controles de ffx en función de la opción que le
		-- pasemos en ffxOption : #asset, #sequence, #custom
		-------------------------------------------------------------------------------
		fn activateFFXOption ffxOption =
		(
			case ffxOption of
			(
				#asset:
				(
					--Ponemos todos los controles como desactivados
					--Custom controls
					chkFFXCustomLevels.enabled = true
					chkFFXCustomLevels.checked = false
					edtFFXCustomLevels.enabled = false
					btnFFXCustomLevels.enabled = false
					
					--Sequence controls
					chkFFXSequenceLevels.enabled = true
					chkFFXSequenceLevels.checked = false
					
					--Activaremos los controles de simulación por asset con calidad media
					chkFFXAssetLevels.enabled = true
					chkFFXAssetLevels.checked = true
					rdoFFXAssetLevels.state = 2
					rdoFFXAssetLevels.enabled = true
					
					--Activo los controles de los frames de inicio y fin de FFX.
					spnFFXPlayFrom.enabled = true
					spnFFXPlayTo.enabled = true
					spnFFXOffset.enabled = true
					
					--El botón de simulación
					btnFFXRunSimulation.enabled = true
				)
				
				#sequence:
				(
					--Ponemos todos los controles como desactivados
					--Custom controls
					chkFFXCustomLevels.enabled = true 
					chkFFXCustomLevels.checked = false
					edtFFXCustomLevels.enabled = false
					btnFFXCustomLevels.enabled = false
					
					--Sequence controls
					chkFFXSequenceLevels.enabled = true
					chkFFXSequenceLevels.checked = true
					
					--Activaremos los controles de simulación por asset con calidad media
					chkFFXAssetLevels.enabled = true
					chkFFXAssetLevels.checked = false
					rdoFFXAssetLevels.state = 2
					rdoFFXAssetLevels.enabled = false
					
					--Activo los controles de los frames de inicio y fin de FFX.
					spnFFXPlayFrom.enabled = true
					spnFFXPlayTo.enabled = true
					spnFFXOffset.enabled = true
					
					--El botón de simulación
					btnFFXRunSimulation.enabled = true
				)
				
				#custom:
				(
					--Ponemos todos los controles como desactivados
					--Custom controls
					chkFFXCustomLevels.enabled = true 
					chkFFXCustomLevels.checked = true
					edtFFXCustomLevels.enabled = true
					btnFFXCustomLevels.enabled = true
					
					--Sequence controls
					chkFFXSequenceLevels.enabled = true
					chkFFXSequenceLevels.checked = false
					
					--Activaremos los controles de simulación por asset con calidad media
					chkFFXAssetLevels.enabled = true
					chkFFXAssetLevels.checked = false
					rdoFFXAssetLevels.state = 2
					rdoFFXAssetLevels.enabled = false
					
					--Activo los controles de los frames de inicio y fin de FFX.
					spnFFXPlayFrom.enabled = true
					spnFFXPlayTo.enabled = true
					spnFFXOffset.enabled = true
					
					--El botón de simulación
					btnFFXRunSimulation.enabled = true
				)
			)
		)
		
		
		
		-------------------------------------------------------------------------------
		-- Pone los controles de los objetos en asset medium y aplica la ruta
		-- correspondiente.
		-------------------------------------------------------------------------------
		fn forceDefaultFFXState =
		(
			activateFFXOption #asset
			
			-- 			print rdoFFXAssetLevels.state
			rdoFFXAssetLevels.state = 2
			
			--Obtengo el path de la simulación de calidad media
			_path = getFFXAssetSimulationPath selectedFxAsset quality:#medium basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit)
			
			--Obtengo todos los fumefx del asset en cuestión
			_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
			
			--Aplico las rutas
			applyFFXSimulationPath _ffxNodes _path
		)
		
		-----------------------------------------------------------------------------------------
		-- Actualiza los controles del rollout con cada cambio de selección
		-----------------------------------------------------------------------------------------
		fn fillFumeFxControls =
		(
			--Miraremos el tipo de ruta que tenemos en el objeto e intentaremos sacar que opciones tiene seleccionado (Asset,sequence o custom)
			--Obtengo todos los fumefx del asset en cuestión
			_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
			
			if _ffxNodes.count > 0 then
			(
				--Comprobaremos que entre los distintos elementos de fume fx tienen las rutas iguales
				_defaultPath = getFilenamePath (_ffxNodes[1].getPath "default")
				_waveletPath = getFilenamePath (_ffxNodes[1].getPath "wavelet")
				_retimerPath = getFilenamePath (_ffxNodes[1].getPath "retimer")
				
				_differentPaths = false
				
				--Si los 3 paths son iguales entonces seguiremos
				if _defaultPath == _waveletPath and _defaultPath == _retimerPath then
				(
					for i=2 to _ffxNodes.count do
					(
						--Si alguno de los paths es distinto
						if _defaultPath != getFilenamePath (_ffxNodes[i].getPath "default") \
						or _defaultPath != getFilenamePath (_ffxNodes[i].getPath "wavelet") \
						or _defaultPath != getFilenamePath (_ffxNodes[i].getPath "retimer") then
							_differentPaths = true
					)
				)
				--Si no lo son entonces mal
				else
				(
					_differentPaths = true
				)
				
				--Si las rutas son distintas forzaré que el asset simule por asset a calidad media
				if _differentPaths then
				(
					messagebox "FFX paths differ, forcing medium quality asset simulation."
					forceDefaultFFXState()
				)
				else
				(
					--Llegados a este punto como las rutas de todos los fx del asset son iguales entonces tomaremos la de default del primero para saber que opcion tiene puesta
					_path = _defaultPath
					
					--Vamos a ver si es una ruta de asset
					if matchpattern (getFilenamePath _path) pattern:((getFFXAssetSimulationPath selectedFxAsset quality:#none basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit)) + "*") then
					(
						activateFFXOption #asset
						
						--Miramos la ultima parte del nombre de la ruta
						case tolower (filterString _path "\\")[(filterString _path "\\").count] of
						(	
							"low": rdoFFXAssetLevels.state = 1
							"medium": rdoFFXAssetLevels.state = 2
							"high": rdoFFXAssetLevels.state = 3
						)
					)
					--Si coincide con una ruta de secuencia y además su número de cámara y secuencia cuadran entonces será de secuencia.
					else if (matchpattern (getFilenamePath _path) pattern: "\\\\lbdata002\\simulation\\sequence\\seq_???\\cam\\cam???\\" \
					or matchpattern (getFilenamePath _path) pattern: "\\\\lbdata002\\simulation\\sequence\\seq_????\\cam\\cam???\\") then
					(
						--Si estamos en una escena de secuencia entonces miraremos si es la misma secuencia y cámara
						if lb.nc.ncOK (getFilenameFile maxfilename) type:#seqFile then
						(
							--Si coinciden secuencia y cámara entonces.
							if (filterString (filterString _path "\\")[4] "_")[2] == (filterString (getFilenameFile maxfilename) "_")[2] \
							and (filterString _path "\\")[6] == (filterString (getFilenameFile maxfilename) "_")[3] then
							(
								activateFFXOption #sequence
							)
							--Si no coinciden pondremos la opción de custom
							else
							(
								activateFFXOption #custom
								edtFFXCustomLevels.text = _path
							)
						)
						--Si no estamos en una secuencia 
						else
						(
							forceDefaultFFXState()
						)
					)
					--Pongo la ruta custom
					else
					(
						activateFFXOption #custom
						edtFFXCustomLevels.text = _path
					)
				)
				
				--Una vez tengamos los controles de fumeFx cargados procederemos a rellenar los spinners de rangos de frames
				_playFrom = _ffxNodes[1].PlayFrom
				_playTo = _ffxNodes[1].PlayTo
				_offset = _ffxNodes[1].Offset
				
				--Iremos comparando los offsets de todos los nodos de FFX quedándonos con los rangos mas amplios
				for i=2 to _ffxNodes.count do
				(
					--Si el frame de inicio es menor nos quedaremos con él
					if _playFrom > _ffxNodes[i].PlayFrom then
						_playFrom = _ffxNodes[i].PlayFrom
					
					--Si el frame de inicio es menor nos quedaremos con él
					if _playTo < _ffxNodes[i].PlayTo then
						_playTo = _ffxNodes[i].PlayTo
					
					--Si el frame de inicio es menor nos quedaremos con él
					if _offset > _ffxNodes[i].Offset then
						_offset = _ffxNodes[i].Offset
				)
				
				for i=1 to _ffxNodes.count do
				(
					_ffxNodes[i].PlayFrom = _playFrom
					_ffxNodes[i].PlayTo = _playTo
					_ffxNodes[i].Offset = _offset
				)
				
				spnFFXPlayFrom.value = _playFrom
				spnFFXPlayTo.value = _playTo
				spnFFXOffset.value = _offset
				
			)-- if ffxNodes.count >0
			else
			(
				--Ponemos todos los controles como desactivados
				--Custom controls
				chkFFXCustomLevels.enabled = false
				chkFFXCustomLevels.checked = false
				edtFFXCustomLevels.enabled = false
				btnFFXCustomLevels.enabled = false
				
				--Sequence controls
				chkFFXSequenceLevels.checked = false
				chkFFXSequenceLevels.enabled = false
				
				--Asset controls
				chkFFXAssetLevels.checked = false
				rdoFFXAssetLevels.state = 2
				rdoFFXAssetLevels.enabled = false
				
				--Los controles de los rangos de los cachés.
				spnFFXPlayFrom.value = 0
				spnFFXPlayTo.value = 100
				spnFFXOffset.value = 0
				spnFFXPlayFrom.enabled = false
				spnFFXPlayTo.enabled = false
				spnFFXOffset.enabled = false
				
				--El botón de simulación
				btnFFXRunSimulation.enabled = false
			)
		)
		
		
		-----------------------------------------------------------------------------------------
		-- Rellena los controles del rollout con los valores que tenemos en el asset
		-- de fx seleccionado (variable selectedFxAsset de este rollout) 
		-----------------------------------------------------------------------------------------
		fn fillControls =
		(
			------------------CONTROLES DE PFLOW--------------------------
			--Primero sacaremos los PFSources y los displays.
			_pfSources = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == PF_Source collect selectedFxAsset.nodes[i]
			_pfDisplays = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == DisplayParticles collect selectedFxAsset.nodes[i]
			
			--Luego miraremos si hay distintos valores para los particle flows (para mostrar los spinners como Indeterminados o no (vacios))
			if _pfSources.count > 0 then
			(
				--Miramos primero los valores de visualización en viewport
				_distinct = false
				_firstValue = _pfSources[1].Quantity_Viewport
				
				for i=2 to _pfSources.count do
				(
					--El el momento en el que encontremos algún valor diferente activaremos el flag
					if _firstValue != _pfSources[i].Quantity_Viewport then
						_distinct = true
				)
				
				--Si son valores distintos pondremos el spinner como indeterminado (sin valor pero se puede mover)
				if _distinct then
					spnVisualizationQuantity.indeterminate = true
				else
					spnVisualizationQuantity.value = _firstValue
				
				
				--Luego miraremos los valores de visualización en render
				_distinct = false
				_firstValue = _pfSources[1].Quantity_Render
				
				for i=2 to _pfSources.count do
				(
					--El el momento en el que encontremos algún valor diferente activaremos el flag
					if _firstValue != _pfSources[i].Quantity_Render then
						_distinct = true
				)
				
				--Si son valores distintos pondremos el spinner como indeterminado (sin valor pero se puede mover)
				if _distinct then
					spnRenderQuantity.indeterminate = true
				else
					spnRenderQuantity.value = _firstValue
			)
			--Si no hay particle flows desactivamos ambos controles.
			else
			(
				spnVisualizationQuantity.enabled = false
				spnRenderQuantity.enabled = false
			)
			
			--Luego miraremos si hay distintos valores para los particle flows (para mostrar los spinners como Indeterminados o no (vacios))
			if _pfDisplays.count > 0 then
			(
				--Miramos primero los valores de visualización en viewport
				_distinct = false
				_firstValue = _pfDisplays[1].type
				
				for i=2 to _pfDisplays.count do
				(
					--El el momento en el que encontremos algún valor diferente activaremos el flag
					if _firstValue != _pfDisplays[i].type then
						_distinct = true
				)
				
				--Si son valores distintos pondremos el dropdown como indeterminado (índice 0)
				if _distinct then
					ddlDisplayType.selection = 0
				else
					--Le sumamos uno al valor de nuestro spinner porque en rango de valores de la propiedad empieza en 0.
					ddlDisplayType.selection = _firstValue + 1
			)
			--Si no hay particle flows desactivamos ambos controles.
			else
			(
				ddlDisplayType.enabled = false
			)
			
			------------------CONTROLES DE AFTERBURN--------------------------
			--Primero obtendremos el atmosférico(o atmosfericos) del asset seleccionado.
			_atmospherics = #()
			
			for i=1 to numAtmospherics where classof (getAtmospheric i) == AfterBurn do
			(
				if matchPattern (getAtmospheric i).name pattern: (selectedFxAsset.fullname + "_*") and (getAtmospheric i).VptGeometryType != undefined then
					append _atmospherics (getAtmospheric i)
			)
			
			if _atmospherics.count > 0 then
			(
				--Miramos primero los valores de visualización en viewport
				_distinct = false
				_firstValue = _atmospherics[1].VptGeometryType
				
				--Recorro todos los atmosfericos para ver si encuentro alguno que tenga valores distintos que los demás
				for i=2 to _atmospherics.count do
				(
					if _atmospherics[2].VptGeometryType != _firstValue then
						_distinct = true
				)
				
				--Si hay uno distinto pondre el dropdown con índice 0 que es vacío sin seleccionar nada.
				if _distinct then
				(
					ddlAFDisplayType.selection = 0
				)
				--Si son todos iguales o hay uno le pondré el valor + 2 (es la correspondencia que hay entre los diferentes valores y el desplegable nuestro)
				else
				(
					ddlAFDisplayType.selection = _firstValue + 2
				)
			)
			--Si no hay atmosféricos de afterburn entonces lo que haremos será
			else
			(
				ddlAFDisplayType.enabled = false
			)
			
			------------------CONTROLES DE FUMEFX--------------------------
			fillFumeFxControls()
		)
		
		
		-----------------------------------------------------------------------------------------
		-- Actualiza los controles del rollout con cada cambio de selección
		-----------------------------------------------------------------------------------------
		fn updateFxUI =
		(
			_assetsToLoad = #()
			-- Cogemos los assets a mostrar de los seleccionados de la escena.
			if parent.rollFX.chkLoadFxBySelAsset.checked then 
			(
				_assetsToLoad = lb.assetManager.getSelectedAssets()
			)
			-- Cogemos los assets a mostrar de los seleccionados con el asset manager.
			else
			(
				_assetsToLoad = lb.asset.getAssetsFromNodes (getCurrentSelection())
			)
			-- 			print ("Numero de assets seleccionados: " + _assetsToLoad.count As String)
			--Si tenemos seleccionados uno solo 
			if _assetsToLoad.count == 1 then
			(
				--Si además es de fx
				if _assetsToLoad[1].type == lb.nc.NC_fxPrefix then
				(
					selectedFxAsset = _assetsToLoad[1]
					unlockControls()
					fillControls()
				)
				else
				(
			-- 					print "No es un asset de fx bloqueo"
					selectedFxAsset = undefined
					lockControls()
				)
			)
			else
			(
			-- 				print "No hay assets seleccionados o hay más de uno"
				selectedFxAsset = undefined
				lockControls()
			)
		)
		
		
	
		-------------------------------------------------------------------------------
		-- Función que aplica las rutas de las simulaciones seleccionadas a los
		-- objetos.
		-------------------------------------------------------------------------------
		fn applySimulationRoutes =
		(
			--Obtengo todos los fumefx del asset en cuestión
			_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
			
			--Creo un string para almacenar la ruta final que vamos a usar.
			_path = ""
			
			--Me creo un array de errores.
			_notFoundFiles = #()
			
			--Iremos viendo los tipos de archivo de simulación y sacaremos la ruta del que proceda (de asset,de secuencia o elegido por el usuario)
			if chkFFXAssetLevels.checked then
			(
				--Tendremos en cuenta la calidad
				if rdoFFXAssetLevels.state == 1 then
					applyFFXSimulationPath _ffxNodes (getFFXAssetSimulationPath selectedFxAsset quality:#low basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit))
				else if rdoFFXAssetLevels.state == 3 then
					applyFFXSimulationPath _ffxNodes (getFFXAssetSimulationPath selectedFxAsset quality:#high basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit))
				--Pongo la de medio al final porque es la que hay por defecto.
				else
					applyFFXSimulationPath _ffxNodes (getFFXAssetSimulationPath selectedFxAsset quality:#medium basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit))
			)
			--Si se trata de la simulación de una secuencia
			else if chkFFXSequenceLevels.checked then
			(
				_path = getFFXSequenceSimulationPath basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit)
				
				--Si no hemos podido hallar la ruta es que el archivo no es de secuencia asi que pondremos el estado de simulación por defecto.
				if _path == "" then
				(
					messageBox "Current scene is not a sequence file, path not applied."
					forceDefaultFFXState()
				)
				--Si es una ruta válida
				else
				(
					--La aplicamos
					applyFFXSimulationPath _ffxNodes _path
				)
			)
			--Si se trata de una simulación seleccionada por el usuario
			else
			(
				if edtFFXCustomLevels.text != "" and edtFFXCustomLevels.text != undefined then
					applyFFXSimulationPath _ffxNodes edtFFXCustomLevels.text
				else
					messageBox "Path is invalid or empty, not applied."
			)
		)		

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
			_id = ((parent.className + "_" + (substituteString parent.rollMain.name "Def" "")) as name)
			callbacks.addScript #selectionSetChanged "lb.assetManager.rollFxDetail.updateFxUI()" id:_id
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
			_id = ((parent.className + "_" + (substituteString parent.rollMain.name "Def" "")) as name)
			callbacks.removescripts id:_id
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollFxDetailDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollFxDetailDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		---------------------------------------------------------------------------------
		-- Cambia las rutas de simulación entre low, medium y high en los controles
		-- de simulaciones de asset.
		---------------------------------------------------------------------------------
		on rdoFFXAssetLevels changed arg do
		(
			--Obtengo todos los fumefx del asset en cuestión
			_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
			
			case arg of
			(
				1:
				(
					applyFFXSimulationPath _ffxNodes (getFFXAssetSimulationPath selectedFxAsset quality:#low basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit))
				)
				3:
				(
					applyFFXSimulationPath _ffxNodes (getFFXAssetSimulationPath selectedFxAsset quality:#high basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit))
				)
				default:
				(
					applyFFXSimulationPath _ffxNodes (getFFXAssetSimulationPath selectedFxAsset quality:#medium basepath:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation\\" projectUnit))
				)
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Recalcula las simulaciones en la ruta actual del asset.
		---------------------------------------------------------------------------------
		on btnFFXRunSimulation pressed do
		(
			--Obtengo todos los fumefx del asset en cuestión
			_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
			
			--Sacamos todos los particle flow sources para modificarles los valores.
			for i=1 to _ffxNodes.count do 
			(
				_ffxNodes[i].runSimulation 0
			)
		)
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner de inicio de simulacion de FFX
		-- con teclado.
		---------------------------------------------------------------------------------
		on spnFFXPlayFrom entered do
		(
			--Obtengo todos los fumefx del asset en cuestión
			_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
			--Sacamos todos los particle flow sources para modificarles los valores.
			for i=1 to _ffxNodes.count do 
			(
				_ffxNodes[i].PlayFrom = spnFFXPlayFrom.value
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner de inicio de simulacion de FFX
		-- con boton.
		---------------------------------------------------------------------------------
		on spnFFXPlayFrom buttonup arg do
		(
			if not arg then
			(
				--Obtengo todos los fumefx del asset en cuestión
				_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
				--Sacamos todos los particle flow sources para modificarles los valores.
				for i=1 to _ffxNodes.count do 
				(
					_ffxNodes[i].PlayFrom = spnFFXPlayFrom.value
				)
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner de fin de simulacion de FFX
		-- con teclado.
		---------------------------------------------------------------------------------
		on spnFFXPlayTo entered do
		(
			--Obtengo todos los fumefx del asset en cuestión
			_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
			--Sacamos todos los particle flow sources para modificarles los valores.
			for i=1 to _ffxNodes.count do 
			(
				_ffxNodes[i].PlayTo = spnFFXPlayTo.value
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner de fin de simulacion de FFX
		-- con boton.
		---------------------------------------------------------------------------------
		on spnFFXPlayTo buttonup arg do
		(
			if not arg then
			(
				--Obtengo todos los fumefx del asset en cuestión
				_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
				--Sacamos todos los particle flow sources para modificarles los valores.
				for i=1 to _ffxNodes.count do 
				(
					_ffxNodes[i].PlayTo = spnFFXPlayTo.value
				)
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner de fin de simulacion de FFX
		-- con teclado.
		---------------------------------------------------------------------------------
		on spnFFXOffset entered do
		(
			--Obtengo todos los fumefx del asset en cuestión
			_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
			--Sacamos todos los particle flow sources para modificarles los valores.
			for i=1 to _ffxNodes.count do 
			(
				_ffxNodes[i].Offset = spnFFXOffset.value
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner de fin de simulacion de FFX
		-- con boton.
		---------------------------------------------------------------------------------
		on spnFFXOffset buttonup arg do
		(
			if not arg then
			(
				--Obtengo todos los fumefx del asset en cuestión
				_ffxNodes = for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == FumeFX collect selectedFxAsset.nodes[i]
				--Sacamos todos los particle flow sources para modificarles los valores.
				for i=1 to _ffxNodes.count do 
				(
					_ffxNodes[i].Offset = spnFFXOffset.value
				)
			)
		)
		
		
		
		--------------------------------------------------------------------------------
		-- Evento de hacer click en el botón de abrir ventana de environment.
		--------------------------------------------------------------------------------
		on btnOpenEnvDialog pressed do
		(
			--Si lo hemos marcado, aplicaremos las simulaciones de los assets de fx.
			if  not envEffectsDialog.isOpen() then
				actionMan.executeAction 0 "40029"
		)
		
		
		--------------------------------------------------------------------------------
		-- Evento de hacer click en seleccionar las simulaciones por asset en FFX.
		--------------------------------------------------------------------------------
		on chkFFXAssetLevels changed arg do
		(
			--Si lo hemos marcado, aplicaremos las simulaciones de los assets de fx.
			if arg then
			(
				--Ponemos la opción #asset
				activateFFXOption #asset
				--Aplicaremos las rutas que correspondan
				applySimulationRoutes()
			)
			else
				chkFFXAssetLevels.checked = true
		)
		
		
		--------------------------------------------------------------------------------
		-- Evento de hacer click en seleccionar las simulaciones por asset en FFX.
		--------------------------------------------------------------------------------
		on chkFFXSequenceLevels changed arg do
		(
			--Si lo hemos marcado, aplicaremos las simulaciones de los assets de fx.
			if arg then
			(
				--Ponemos la opción #sequence
				activateFFXOption #sequence
				--Aplicaremos las rutas que correspondan
				applySimulationRoutes()
			)
			else
				chkFFXSequenceLevels.checked = true
		)
		
		
		--------------------------------------------------------------------------------
		-- Evento de hacer click en seleccionar las simulaciones por asset en FFX.
		--------------------------------------------------------------------------------
		on chkFFXCustomLevels changed arg do
		(
			--Si lo hemos marcado, aplicaremos las simulaciones de los assets de fx.
			if arg then
				--Ponemos la opcion de custom en los controles
				activateFFXOption #custom
			else
				chkFFXCustomLevels.checked = true
		)
		
		
		--------------------------------------------------------------------------------
		-- Evento de hacer click en seleccionar las simulaciones por asset en FFX.
		--------------------------------------------------------------------------------
		on btnFFXCustomLevels pressed do
		(
			_path = getSavePath "Select Custom Simulation Save Path" initialDir:(lb.nc.swapUnit "\\\\lbdata002\\z\\simulation" projectUnit)
			
			if _path == undefined then
				edtFFXCustomLevels.text = ""
			else
			(
				edtFFXCustomLevels.text = _path + "\\"
			)
			
			--Aplicaremos las rutas que correspondan
			applySimulationRoutes()
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner visualization de Particle Flow
		-- por teclado.
		---------------------------------------------------------------------------------
		on spnVisualizationQuantity entered do
		(
			--Sacamos todos los particle flow sources para modificarles los valores.
			for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == PF_Source do 
			(
				selectedFxAsset.nodes[i].Quantity_Viewport = spnVisualizationQuantity.value
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner visualization de Particle Flow
		---------------------------------------------------------------------------------
		on spnVisualizationQuantity buttonup arg do
		(
			if not arg then
			(
				--Sacamos todos los particle flow sources para modificarles los valores.
				for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == PF_Source do 
				(
					selectedFxAsset.nodes[i].Quantity_Viewport = spnVisualizationQuantity.value
				)
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del spinner render de Particle Flow
		-- por teclado.
		---------------------------------------------------------------------------------
		on spnRenderQuantity entered do
		(
			--Sacamos todos los particle flow sources para modificarles los valores.
			for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == PF_Source do 
			(
				selectedFxAsset.nodes[i].Quantity_Render = spnRenderQuantity.value
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de soltar el boton del spinner render de Particle Flow
		---------------------------------------------------------------------------------
		on spnRenderQuantity buttonup arg do
		(
			if not arg then
			(
				--Sacamos todos los particle flow sources para modificarles los valores.
				for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == PF_Source do 
				(
					selectedFxAsset.nodes[i].Quantity_Render = spnRenderQuantity.value
				)
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del dropdownlist tipo de visualización de Particle Flow
		---------------------------------------------------------------------------------
		on ddlDisplayType selected arg do
		(
			--Sacamos todos los particle flow sources para modificarles los valores.
			for i=1 to selectedFxAsset.nodes.count where classof selectedFxAsset.nodes[i] == DisplayParticles do 
			(
				selectedFxAsset.nodes[i].type = ddlDisplayType.selection - 1
			)
		)
		
		
		---------------------------------------------------------------------------------
		-- Evento de cambiar el valor del dropdownlist tipo de visualización de Afterburn
		---------------------------------------------------------------------------------
		on ddlAFDisplayType selected arg do
		(
			--Primero obtendremos el atmosférico(o atmosfericos) del asset seleccionado.
			_atmospherics = #()
			
			for i=1 to numAtmospherics where classof (getAtmospheric i) == AfterBurn do
			(
				if matchPattern (getAtmospheric i).name pattern: (selectedFxAsset.fullname + "_*") then
					append _atmospherics (getAtmospheric i)
			)
			
			--Sacamos todos los particle flow sources para modificarles los valores.
			for i=1 to _atmospherics.count do 
			(
				_atmospherics.VptGeometryType = ddlAFDisplayType.selection - 2
			)
		)
		on rollFxDetailDef rolledUp state do 
		(
			parent.heightAdjust 6
		)	

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollFxDetailDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollFxDetailDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			updateFxUI()
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollFxDetailDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollFxDetailDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollHairDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollHairDef "Hair"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 180	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 30	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		groupBox grpHairVisModes "Hair Visualization Modes" pos:[5,0] width:200 height:103
		button btnVMhair "Hr" pos:[10,17] width:25 height:20
		button btnVMskinHair "S+Hr" pos:[35,17] width:35 height:20
		button btnVMskinHairVideo "S+Hr+Video" pos:[75,17] width:70 height:20
		dropdownlist ddlVMHairVideoPercent "" pos:[145,17] width:55 height:20 items:#("10%", "20%", "30%", "40%", "50%", "60%", "70%", "80%", "90%", "100%")
		
		button btnhairModifiersEnable "" pos:[150,43] width:25 height:25 images:#(iconpath + "HairAndFur_24i.bmp", undefined, 30, 7, 7, 7, 7, true) tooltip:"Enable asset/s hair modifiers"
		button btnhairModifiersOffInViewport "" pos:[175,43] width:25 height:25 images:#(iconpath + "HairAndFur_24i.bmp", undefined, 30, 6, 6, 6, 6, true) tooltip:"Off in viewport asset/s hair modifiers"

		button btnVMhairHair "Display Hair" pos:[10,43] width:65 height:25 tooltip:"Display assets hair"
		button btnVMhairMesh "Display Mesh" pos:[75,43] width:70 height:25 tooltip:"Display assets hair mesh"

		button btnVMhideScalps "Hide Scalps" pos:[10,73] width:65 height:25 tooltip:"Display assets hair"
		button btnVMshowscalps "Show Scalps" pos:[75,73] width:70 height:25 tooltip:"Display assets hair mesh"

		--button btnhairModifierPolyStripsDelete "" pos:[10,43] width:25 height:25 images:#(iconpath + "HairAndFur_24i.bmp", undefined, 30, 7, 7, 7, 7, true) tooltip:"Enable asset/s hair modifiers"
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		------------------------------------------------

		------------------------------------------------
		--inicial los valores de UI
		------------------------------------------------
		fn initUI =
		(
			ddlVMHairVideoPercent.selection = 10
		)

		----------------------------------------------------------------------------------
		--devuelve un array con los assets con los que trabajar segun la opcion de usar
		--los seleccionados en la escena o en el listado
		----------------------------------------------------------------------------------
		fn getAssetsToWork =
		(
			_assetsToWork = #() --array para almacenar los assets que se pondran en el modo de visualizacion
			_assetsToWork = lb.assetManager.getSelectedAssets()
			_assetsToWork --devuelve los assets con los que trabajar
		)

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollHairDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollHairDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		----------------------------------------------------------------------------------
		--cambia los assets que proceda a modo hair
		----------------------------------------------------------------------------------
		on btnVMhair pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion cloth
			with undo off			
				for ast in _assetsToWork do lb.asset.setAssetHairMode ast
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
				
			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		
		----------------------------------------------------------------------------------
		--cambia los assets que proceda a modo skin + hair
		----------------------------------------------------------------------------------
		on btnVMskinHair pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion skin + cloth
			with undo off
				for ast in _assetsToWork do lb.asset.setAssetSkinHairMode ast
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
				
			lb.assetManager.rollAdvanced.fillLayerControls()
		)

		----------------------------------------------------------------------------------
		--cambia los assets que proceda a modo skin + hair + video
		----------------------------------------------------------------------------------
		on btnVMskinHairVideo pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion skin + cloth
			with undo off
				for ast in _assetsToWork do lb.asset.setAssetSkinHairVideoMode ast hairGeneratePercent:(ddlVMHairVideoPercent.selection*10)
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
				
			lb.assetManager.rollAdvanced.fillLayerControls()
		)

		----------------------------------------------------------------------------------
		--cambia los assets que proceda para que muestre los pelos en modo pelo
		----------------------------------------------------------------------------------
		on btnVMhairHair pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion skin + cloth
			with undo off
			(
				for ast in _assetsToWork do
				(
					for _node in ast.hairNodesAll do
					(
						_nodeNamePart5 = lb.nc.getNamePart _node.name 5

						if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_scalpPattern then
						(
							for m in _node.modifiers do
							(
								if classof m == Hair_Display then
								(
									m.displayMode = 0
									m.viewportSteps = 1
								)
							)--for
						)--if
					)--for
				)--for
			)
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
		)

		----------------------------------------------------------------------------------
		--cambia los assets que proceda para que muestre los pelos en modo geometria
		----------------------------------------------------------------------------------
		on btnVMhairMesh pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion skin + cloth
			with undo off
			(
				for ast in _assetsToWork do
				(
					for _node in ast.hairNodesAll do
					(
						_nodeNamePart5 = lb.nc.getNamePart _node.name 5

						if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_scalpPattern then
						(
							for m in _node.modifiers do
							(
								if classof m == Hair_Display then
								(
									m.displayMode = 1
								)
							)--for
						)--if
					)--for
				)--for
			)
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
		)
		
		----------------------------------------------------------------------------------
		--muestra los root de los scalps
		----------------------------------------------------------------------------------
		on btnVMshowscalps pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion skin + cloth
			with undo off
			(
				for ast in _assetsToWork do
				(
					for _node in ast.hairNodesAll do
					(
						_nodeNamePart5 = lb.nc.getNamePart _node.name 5

						if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_scalpPattern then
						(
							for m in _node.modifiers do
							(
								if classof m == Hair_Display then
								(
									m.hideRootObjectInViewports = false
								)
							)--for
						)--if
					)--for
				)--for
			)
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
		)

		----------------------------------------------------------------------------------
		--oculta los root de los scalps
		----------------------------------------------------------------------------------
		on btnVMhideScalps pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion skin + cloth
			with undo off
			(
				for ast in _assetsToWork do
				(
					for _node in ast.hairNodesAll do
					(
						_nodeNamePart5 = lb.nc.getNamePart _node.name 5

						if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_scalpPattern then
						(
							for m in _node.modifiers do
							(
								if classof m == Hair_Display then
								(
									m.hideRootObjectInViewports = true
								)
							)--for
						)--if
					)--for
				)--for
			)
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
		)

		----------------------------------------------------------------------------------
		--activa los modificadores de hair
		----------------------------------------------------------------------------------
		on btnhairModifiersEnable pressed do
		(
			_hairFarmClasses = #(HairStyle_Uncomb, HairTo_SplinesSpacewarpModifier, HairTo_PolySpacewarpModifier, HairTo_InstancesSpacewarpModifier, HairStyle_PushOutSpacewarpModifier, HairStyle_Forces, Hair_Display, HairTo_Splines, HairTo_Poly, HairTo_Instances, HairStyle_Wisps, HairStyle_Spiral, HairStyle_Scale, HairStyle_PushOut, HairStyle_Length, HairStyle_Kink, HairStyle_Gravity, HairStyle_Frizz, HairStyle_Displace, HairStyle_Curves, HairStyle_Cluster, HairMesh_to_Poly, HairMesh_Smooth, HairMesh_Sim, HairMesh_Mirror, HairMesh_Link, HairMesh_Extrude, HairMesh_Edit, HairMesh_Brush, Hair_Generate, Hair_Direction_on_Poly)
			
			_sel = getCurrentSelection()
			if _sel.count != 0 then
			(
				for o in _sel do 
					for m in o.modifiers where findItem _hairFarmClasses (classof m) != 0 do
					(
						m.enabled = true
						m.enabledInViews = true
					)
			)
			else
			(
				_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
				for ast in _assetsToWork do
					for o in ast.hairNodesAll do
						for m in o.modifiers where findItem _hairFarmClasses (classof m) != 0 do
						(
							m.enabled = true
							m.enabledInViews = true
						)
			)
		)
		
		----------------------------------------------------------------------------------
		--pone en off in viewport los modificadores de hair
		----------------------------------------------------------------------------------
		on btnhairModifiersOffInViewport pressed do
		(
			_hairFarmClasses = #(HairStyle_Uncomb, HairTo_SplinesSpacewarpModifier, HairTo_PolySpacewarpModifier, HairTo_InstancesSpacewarpModifier, HairStyle_PushOutSpacewarpModifier, HairStyle_Forces, Hair_Display, HairTo_Splines, HairTo_Poly, HairTo_Instances, HairStyle_Wisps, HairStyle_Spiral, HairStyle_Scale, HairStyle_PushOut, HairStyle_Length, HairStyle_Kink, HairStyle_Gravity, HairStyle_Frizz, HairStyle_Displace, HairStyle_Curves, HairStyle_Cluster, HairMesh_to_Poly, HairMesh_Smooth, HairMesh_Sim, HairMesh_Mirror, HairMesh_Link, HairMesh_Extrude, HairMesh_Edit, HairMesh_Brush, Hair_Generate, Hair_Direction_on_Poly)
			
			_sel = getCurrentSelection()
			if _sel.count != 0 then
			(
				for o in _sel do 
					for m in o.modifiers where findItem _hairFarmClasses (classof m) != 0 do
					(
						m.enabled = true
						m.enabledInViews = false
					)
			)
			else
			(
				_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
				for ast in _assetsToWork do
					for o in ast.hairNodesAll do
						for m in o.modifiers where findItem _hairFarmClasses (classof m) != 0 do
						(
							m.enabled = true
							m.enabledInViews = false
						)
			)
		)

		on rollHairDef rolledUp state do 
		(
			parent.heightAdjust 7
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollHairDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollHairDef open do
		(
			loadSettings()
			initUI()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollHairDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollHairDef
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollHairDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollHairImportDef "Hair Import"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 180	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 30	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		checkbutton chkOperateOnSelAssets "Sel Assets" pos:[5,0] width:98 height:20 checked:true
		checkbutton ckbOperateOnSelection "Sel Objects" pos:[103,0] width:98 height:20
		button btnImportHair "Import Selected Asset/s Hair" pos:[5,25] width:195 height:20
		checkBox chbPromptLoadHair "Load From File" pos:[60,50]
		button btnDeleteHair "Delete Selected Asset/s Hair" pos:[5,75] width:195 height:20

		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollHairImportDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollHairImportDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		--------------------------------------------------------------
		on chkOperateOnSelAssets changed state do
		(
			chkOperateOnSelAssets.checked = state
			ckbOperateOnSelection.checked = not state
		)	
		
		--------------------------------------------------------------
		on ckbOperateOnSelection changed state do
		(
			ckbOperateOnSelection.checked = state
			chkOperateOnSelAssets.checked = not state
		)

		------------------------------------------------
		--importa el pelo de los assets seleccionados en el listado
		------------------------------------------------
		on btnImportHair pressed do
		(
			if lb.asset.listedAssets.count != 0 then
			(
 				_assetsToUse = #()

				if chkOperateOnSelAssets.checked then --almacena solo los assets seleccionados
				(
					_assetsToUse = lb.assetManager.getSelectedAssets()
				)
				else if ckbOperateOnSelection.checked then --busca los assets de los objetos seleccionados y almacena un array de arrys de nodos y otro de nodos a renombrar
				(
					selNodes = getCurrentSelection()
					_assetsToUse = lb.asset.getAssetsFromNodes selNodes --mira que assets son los dueños de las piezas seleccionadas					
				)--if

				_loadedCount = 0
				_notLoadedCount = 0

				
				--averiguar si hay pelo ya cargado para alguno de los assets
				_haveHairLoaded = false
				for _asset in _assetsToUse where lb.asset.hasHairAsset _asset do _haveHairLoaded = true
				
				_proccess = true
				if _haveHairLoaded then _proccess = lb.message.show "Some selected assets have hair loaded yet. Do you want to delete hair and load it again?\n\nIf you press NO the process will be canceled." type:#query

				if _proccess then
				(
					for _asset in _assetsToUse do
					(
						print _asset
						if _haveHairLoaded then lb.asset.removeHairAsset _asset
						if (not chbPromptLoadHair.state) then 
						(
							_success = lb.asset.importHairAsset _asset
						)
						else 
						(
							_success = lb.asset.importHairAsset _asset _specifyRoute:true
						)
						if _success then (_loadedCount +=1) else (_notLoadedCount +=1)
					)--for

					lb.assetManager.rollMain.resetSceneAssets()

					--mensaje de resultados
					--_pos = getDialogPos lb.assetManager.rollMain
					--_pos += [(lb.assetManager.rollMain.width/2 - 150), (lb.assetManager.rollMain.height/2)]
					lb.message.show ((_loadedCount as string) + " hair assets loaded successfully" + (if _notLoadedCount != 0 then ("\n" + (_notLoadedCount as string) + " hair assets not loaded or not exist") else "")) --pos:_pos size:[300,75]
				)
			)
		)

		------------------------------------------------
		--elimina el pelo de los assets seleccionados en el listado
		------------------------------------------------
		on btnDeleteHair pressed do
		(
			if lb.asset.listedAssets.count != 0 then
			(
 				_assetsToUse = #()

				if chkOperateOnSelAssets.checked then --almacena solo los assets seleccionados
				(
					_assetsToUse = lb.assetManager.getSelectedAssets()
				)
				else if ckbOperateOnSelection.checked then --busca los assets de los objetos seleccionados y almacena un array de arrys de nodos y otro de nodos a renombrar
				(
					selNodes = getCurrentSelection()
					_assetsToUse = lb.asset.getAssetsFromNodes selNodes --mira que assets son los dueños de las piezas seleccionadas					
				)--if

				_deletedCount = 0
				
				for _asset in _assetsToUse where lb.asset.hasHairAsset _asset do
				(
					 lb.asset.removeHairAsset _asset
					_deletedCount +=1
				)--for

				lb.assetManager.rollMain.resetSceneAssets()

				--mensaje de resultados
				--_pos = getDialogPos lb.assetManager.rollMain
				--_pos += [(lb.assetManager.rollMain.width/2 - 150), (lb.assetManager.rollMain.height/2)]
				lb.message.show ((_deletedCount as string) + " hair assets deleted successfully") --pos:_pos size:[300,75]				
			)
		)

		------------------------------------------------
		--ajusta el alto de la herramienta
		------------------------------------------------
		on rollHairImportDef rolledUp state do 
		(
			parent.heightAdjust 7
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollHairImportDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollHairImportDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollHairImportDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollHairImportDef


	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollHairDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollHairExportSimDef "Hair Export Simulation"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 180	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 30	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		checkbutton chkOperateOnSelAssets "Sel Assets" pos:[5,0] width:98 height:20 checked:true
		checkbutton ckbOperateOnSelection "Sel Objects" pos:[103,0] width:98 height:20
		button btnExportHairSim "Export Selected Hair Simulation" pos:[5,25] width:195 height:20

		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollHairImportDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollHairImportDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		--------------------------------------------------------------
		on chkOperateOnSelAssets changed state do
		(
			chkOperateOnSelAssets.checked = state
			ckbOperateOnSelection.checked = not state
		)	
		
		--------------------------------------------------------------
		on ckbOperateOnSelection changed state do
		(
			ckbOperateOnSelection.checked = state
			chkOperateOnSelAssets.checked = not state
		)

		------------------------------------------------
		--Exporta la simulación del pelo de los assets seleccionados en el listado
		------------------------------------------------
		on btnExportHairSim pressed do
		(
			if lb.asset.listedAssets.count != 0 then
			(
				sourceFolder = maxFilePath + "..\\cache\\source\\"
 				_objectsToUse = #()
				if chkOperateOnSelAssets.checked then --almacena todos los objetos de los assets seleccionados
				(
					for _asset in lb.assetManager.getSelectedAssets() do
						_objectsToUse += _asset.hairNodesAll
				)
				else if ckbOperateOnSelection.checked then --filtra en los objetos seleccionados aquellos que sean de  pelo
				(
					_objectsToUse = for o in getCurrentSelection() where (lb.nc.getObjectType o) == lb.nc.NC_classHair collect o
				)--if

				_exportedCount = 0
				_notExportedCount = 0

				for o in _objectsToUse where (lb.hair.hasHairGenerator o) do
				(
					_success = lb.hair.exportHairSimulation o sourceFolder
					if _success then (_exportedCount +=1) else (_notExportedCount +=1)
				)--for

				--mensaje de resultados
				_pos = getDialogPos lb.assetManager.rollMain
				_pos += [(lb.assetManager.rollMain.width/2 - 150), (lb.assetManager.rollMain.height/2)]
				lb.message.show ((_exportedCount as string) + " hair sims exported successfully" + (if _notExportedCount != 0 then ("\n" + (_notExportedCount as string) + " hair sims not exported") else "")) pos:_pos size:[300,75]
			)
		)

		------------------------------------------------
		--ajusta el alto de la herramienta
		------------------------------------------------
		on rollHairExportSimDef rolledUp state do 
		(
			parent.heightAdjust 7
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollHairExportSimDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollHairExportSimDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollHairExportSimDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollHairExportSimDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollMiscDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollMiscDef "Misc"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		

		local minRollWidth = 180	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 150	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		groupBox grpRenameAsset "Rename Asset" pos:[8,0] width:190 height:110
		label lblAssetType "None" pos:[15,17] width:30 enabled:false
		edittext edtAssetName "" pos:[43,15] width:150 enabled:false
		button btnRenameAsset "Apply" pos:[13,39] width:180 enabled:false
		checkBox chkRenameMaterial "Rename Material" pos:[13,65] width:180
		checkBox chkOverwrite "Overwrite Asset Name" pos:[13,85] width:180 checked:true
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		fn updateMiscControls =
		(
			--Guardamos los assets seleccionados en un array
			_assets = lb.assetManager.getSelectedAssets()

			--Si el datagrid de personajes tiene más de uno seleccionado bloquearemos los controles.
			if lb.asset.selAssets.count == 1 then
			(
				--Activamos el texto y ponemos el nombre del asset.
				edtAssetName.enabled = true
				lblAssetType.enabled = true
				btnRenameAsset.enabled = true
				
				lblAssetType.text = (filterString lb.asset.listedAssets[lb.asset.selAssets[1]].fullName "_")[1] + "_"
				edtAssetName.text = (filterString lb.asset.listedAssets[lb.asset.selAssets[1]].fullName "_")[2]
			)
			else
			(
				edtAssetName.enabled = false
				lblAssetType.enabled = false
				btnRenameAsset.enabled = false
				
				lblAssetType.caption = "ast_"
				edtAssetName.text = ""
			)
		)		

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollMiscDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollMiscDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		---------------------------------------------------------------------------------------
		--Evento del botón de renombrar asset pulsado
		---------------------------------------------------------------------------------------
		on btnRenameAsset pressed do
		(
			_proccess = true
			_message = ""
			_depAssets = #() --array para almacenar los assets dependientes.
			_currentAsset = undefined --variable para almacenar el asset seleccionado.
			
			--si no hay nombre que utilizar.
			if edtAssetName.text == "" then
			(
				_proccess = false
				_message = "You have to specify a name."
			)
			
			--solo puede haber un asset seleccionado.
			if _proccess and (lb.asset.selAssets.count == 0 or lb.asset.selAssets.count > 1) then
			(
				_proccess = false
				_message = "You have to select only one asset."
			)
			
			--si cumple los requisitos hasta aqui
			if _proccess then
			(
				--almacena el asset actual y sus dependientes si tuviera
				_currentAsset = lb.asset.listedAssets[lb.asset.selAssets[1]]
				_depAssets = lb.asset.getDependencyGroup _currentAsset lb.asset.sceneAssets
				_renameDependents = true --flag para saber si hay que renombrar los dependientes o no
				
				--si hay dependientes y el tick de afectarlos esta activado
				if _depAssets.count != 0 and lb.assetManager.rollMain.chkaffectDependentAssets.checked then
				(
					if not _currentAsset.isDependent then --si es un asset principal
					(
						if _depAssets.count > 1 then --si tiene dependientes
						(
							--pregunta si renombrar los dependientes
							_answer = yesNoCancelBox (_currentAsset.fullname + " has dependent assets. If you dont rename them, the dependency will be broken. Do you want to rename them?")
							
							if _answer == #cancel then _proccess = false --el usuario ha cancelado
							_renameDependents = (_answer == #yes)
						)--if
					)--if 
					else
					(
						_answer = queryBox (_currentAsset.fullname + " is a dependent asset. If you want to rename all its dependents, you have to select its main asset. Do you want to continue? It will break the dependency.")
						_renameDependents = false
						_proccess = _answer
					)
				)
				
				if _proccess then --si no se ha cancelado la operacion
				(
					--agrupa los assets a renombrar en un array
					_assetsToRename = if _renameDependents then _depAssets else #(_currentAsset)
					_assetsToRenameNewNames = #() --array para almacenar los nombres que
					
					-------------------------------------------------------------------------------------------------------------
					--averigua que nombre tendrá cada asset a renombrar por si ello va a provocar conflictos
					_numericPart = ""
					_newName = edtAssetName.text
					_newNameParts = filterString edtAssetName.text "#"
					if _newNameParts.count == 2 and lb.math.isNumeric _newNameParts[2] then
					(
						_numericPart = _newNameParts[2]
						_newName = _newNameParts[1]
					)
					
					for i=1 to _assetsToRename.count do --averigua el nuevo nombre de cada asset
						if _numericPart != "" then --si hay parte numerica en el nuevo nombre
						(
							_assetsToRenameNewNames[i] = substituteString _assetsToRename[i].fullName _assetsToRename[1].name _newName
							_assetsToRenameNewNames[i] += "#" + _numericPart
						)
						else --si no tiene numero de copia o no hay parte numerica en el nuevo nombre
						(	
							_assetsToRenameNewNames[i] = substituteString _assetsToRename[i].fullname (_assetsToRename[1].name) edtAssetName.text
						)						
					-------------------------------------------------------------------------------------------------------------
					
					-------------------------------------------------------------------------------------------------------------
					--si el nombre que se le va a poner a un asset coincide con el del alguno que ya exista en la escena, no permite realizar la operacion.
					_sceneAssetsFullNames	= for ast in lb.asset.sceneAssets collect ast.fullname
					
					if not chkOverwrite.checked then		
						for astName in _assetsToRenameNewNames where _proccess and findItem _sceneAssetsFullNames astName != 0 do
						(
							_proccess = false
							_message = "Asset name conflict: \"" + astName + "\" is used by another asset yet. The proccess cant continue."
						)
					-------------------------------------------------------------------------------------------------------------
						
					if _proccess then --si no hay contratiempos
						for i=1 to _assetsToRename.count do --renombra los assets
							lb.asset.renameAsset _assetsToRename[i] (filterString _assetsToRenameNewNames[i] "_")[2] renameMaterials:chkRenameMaterial.checked
				)
			)--if _proccess
			
			--imprime el mensaje si no se ha podido renombrar el asset
			if not _proccess and _message != "" then
				lb.message.show _message type:#message pos:undefined size:[300,75] modal:true
			
			lb.assetManager.rollAdvanced.btnRefresh.pressed()

			if lb.objectSetManager.isOpen() then lb.objectSetManager.rollMain.fillInfo()
		)--on btnRenameAsset

		on rollMiscDef rolledUp state do 
		(
			parent.heightAdjust 8
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollMiscDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMiscDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			updateMiscControls()
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMiscDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollMiscDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollCameraAssetsDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollCameraAssetsDef "Asset Camera Variations"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		button btnLoadVariations "Load Variations" pos:[5,5] width:197 height:20 toolTip:"Load the asset camera variations for the current scene"
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollCameraAssetsDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollCameraAssetsDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		on btnLoadVariations pressed do 
		(
			for ast in lb.asset.sceneAssets where ast.type == lb.nc.NC_setPrefix do
			(
				lb.asset.removeAssetCameraVariations ast
				completeRedraw()
				
				lb.asset.loadAssetCameraVariations ast
				completeRedraw()
			)

			--------------------------------------------------------------
			--refresca el interfaz para que los nodos temporales que se hayan eliminado no se queden como deleted scene nodes
			selAssetsFullNames = #()
			for s in lb.asset.selAssets do
				append selAssetsFullNames lb.asset.sceneAssets[s].fullname
			
			lb.assetManager.rollMain.resetSceneAssets()

			lb.asset.selAssets = #()
			for i=1 to lb.asset.sceneAssets.count do
				for s in selAssetsFullNames do
					if lb.asset.sceneAssets[i].fullname == s then
						append lb.asset.selAssets i
				
			lb.assetManager.rollMain.refreshControls()
			--------------------------------------------------------------
		)

		on rollCameraAssetsDef rolledUp state do 
		(
			parent.heightAdjust 8
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollCameraAssetsDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCameraAssetsDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCameraAssetsDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollCameraAssetsDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollCacheSceneDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollCacheSceneDef "Cache Scene"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		label lblCacheFormat "Point Cache Format" pos:[10,10] width:105 height:13
		dropdownList ddlCacheFormat "" pos:[120,5] width:85 height:21 items:#(".pc2", ".xml", ".abc")
		checkbox chkEnableCloth "Enable cloth in export process" pos:[10,27] width:150 height:15 checked:false toolTip:"All cloth modifiers are disbled in export process"
		
		GroupBox grpSceneCacheScene "Cache Scene Options" pos:[5,45] width:202 height:100
		button btnConvertToCacheScene "Convert to cache scene" pos:[10,64] width:192 height:20
		checkbox chkProcessAssets "assets" pos:[10,89] width:50 height:15 checked:true toolTip:"Convert assets to cache assets removing all rig objects"
		checkbox chkProcessCaches "caches" pos:[104,89] width:50 height:15 checked:true toolTip:"Records the caches of the assets"
		checkbox chkMergeXrefs "Merge xRefs" pos:[10,121] width:80 height:15 checked:false toolTip:"All xRef Scenes and xRefObjects will be merged in scene"
		checkbox chkSaveNewMaxFile "Save new file" pos:[10,105] width:88 height:15 checked:true toolTip:"Saves a new Max file. You will be asked for filename and folder"
		checkbox chkDeleteOldCacheFiles "Del old caches" pos:[104,105] width:94 height:15 checked:true toolTip:"Delete old cache files in Source folder"
		checkbox chkSelAssetsOnly "Sel assets only" pos:[104,121] width:94 height:15 toolTip:"Converts only selected assets. Other assets will be deleted"
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		----------------------------------------------------------------------------------------------
		-- 	Cambia el asset a modo de visualización CONNECTALL y desactiva en viewport 
		--	los Turbosmooth de las piezas de tipo mesh. 
		----------------------------------------------------------------------------------------------
		fn prepareAssetForCacheRecording ast enableCloth:false =
		(
			--	Si el asset no está en modo CONNECTALL se lo activamos.
			_modeToBe = "CA" -- if ast.clothNodesAll.count != 0 then "CA" else "S+B"
				
			if lb.asset.getAssetvismode ast != _modeToBe then
				lb.asset.setAssetConnectAllMode ast enableCloth:enableCloth
			
			--	desactivamos los turbosmooth de las piezas mesh
			for o in ast.meshNodesAll do lb.modifiers.setTurbosmoothState o #disabledInViews
		)

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollCacheSceneDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollCacheSceneDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		on btnConvertToCacheScene pressed do
		(
			local meshObjs = #()					--	Todas las piezas de tipo mesh de todos los assets
			local cacheFileName 	= undefined		--	Fichero de caches donde se almacena el resultado
			local cachesFolder		= undefined		--	Carpeta donde se almacenarán los ficheros de point cache
			local materialFileName	= undefined		--	Fichero donde iran los materiales
			local continueProcess	= true			--	Indica si se puede realizar o no la conversión
			
			if (queryBox "Assets will be set to (CONNECT ALL) mode and Turbosmooths will be disabled in viewports. Do you want to continue?") then
			(
				disableSceneRedraw()
				suspendEditing()
				setWaitCursor()
				lb.assetManager.rollMain.removeSceneEvents()
				
				--	apagamos Turbosmooths y colocamos cada asset en el modo de visualizacion skin+box
				assetsToProcess = if chkSelAssetsOnly.checked then (lb.assetManager.getSelectedAssets()) else lb.asset.sceneAssets
				
				for a in assetsToProcess do
					prepareAssetForCacheRecording a enableCloth:chkEnableCloth.checked
				
				resumeEditing()
				enableSceneRedraw()
				completeRedraw()
			
				--	si se va a guardar un nuevo fichero .max, pedimo un nombre para él y asumimos que, si
				--	se van a grabar también los ficheros de datos de caché, irán a parar a la misma ruta
				--	que el fichero .max pero dentro de una carpeta \source
				if chkSaveNewMaxFile.checked then
				(
					if findString maxFileName "_anim" != undefined then
						newName = (substituteString maxFileName "_anim" "_cache")
					else if findString maxFileName "_cloth" != undefined then
						newName = (substituteString maxFileName "_cloth" "_cache")
					else if findString maxFileName "_fx" != undefined then
						newName = (substituteString maxFileName "_fx" "_cache")
					else if findString maxFileName "_hair" != undefined then
						newName = (substituteString maxFileName "_hair" "_cache")
					else if findString maxFileName "_cache" != undefined then
						newName = (substituteString maxFileName "_cache" "_cache")
					else
						newName = maxFileName
					
					--intenta que se abra en la carpeta de caches
					 _currentPath = maxfilepath
					if matchPattern _currentPath pattern:"*anim\\" then
						if doesFileExist (substituteString _currentPath "anim\\" "cache\\") then
							_currentPath = (substituteString _currentPath "anim\\" "cache\\")
					
					cacheFileName = getSaveFileName caption:"Save Cache Scene" types:"Max Scene File (*.max)|*.max" filename:(_currentPath + newName) historyCategory:"cacheScene"
					
					if cacheFileName != undefined then
					(
						cachesFolder = ((getFileNamePath cacheFileName) + "source\\")
						materialFileName = cachesFolder + (lb.materials.materialLibName newName)
					)
					else
						continueProcess = false
					
				)
				--	Si no se va a guardar un nuevo .max pero sí se van a tratar los caches pedimos una ruta
				--	donde almacenar los ficheros de datos de cache.
				else if chkProcessCaches.checked then
				(
					cachesFolder = getSavePath caption:"Select Caches SOURCE Folder" initialDir:maxFilePath
					
					--  Si no se especifica una ruta de salida no se puede continuar
					if cachesFolder == undefined then continueProcess = false
				)
				
				_fileType = ddlCacheFormat.selected
				
				--	si no existían ficheros de cache en la carpeta SOURCE comprobamos que 
				--	el formato de exportación elegido sea PC2, que es más óptimo.
				if cachesFolder != undefined and (getFiles (cachesFolder + "*.*")).count == 0 and _fileType != ".pc2" then
						if (queryBox "No previous cache files in SOURCE folder. Cache format should be PC2.\nDo you want to change to PC2 format?") then
							ddlCacheFormat.selection = 1
				
				if cachesFolder != undefined and (getFiles (cachesFolder + "*.*")).count > 0 then
				(
					_oldCacheFiles = (getFiles (cachesFolder + "*.*"))
					_oldCacheFilesType = undefined
					
					--	revisamos el formato de los ficheros de cache que pudieran existir anteriormente
					for f in _oldCacheFiles where _oldCacheFilesType == undefined do
					(
						_fileType = (toLower (getFileNameType f))
						
						if _fileType == ".xml" then
							_oldCacheFilesType = _fileType
						else if _fileType == ".pc2" then
							_oldCacheFilesType = _fileType
						else if _fileType == ".abc" then
							_oldCacheFilesType = _fileType
					)
					
					--	Si existían ficheros miramos si el formato que vamos a crear es el mismo que ya existía
					--	Si no coinciden lanzamos un Warning
					_showFormatWarning = false
					
					if _oldCacheFilesType != undefined then
						_showFormatWarning = (_oldCacheFilesType != ddlCacheFormat.selected)
			 					--((_oldCacheFilesType == ".xml" and ddlCacheFormat.selected == ".pc2") or \
			 					--							(_oldCacheFilesType == ".pc2" and ddlCacheFormat.selected == ".xml"))
					
					if _showFormatWarning then
					(
						messageBox ("Destination SOURCE folder contains " + (toUpper _oldCacheFilesType) + " files and you selected to export " + (toUpper ddlCacheFormat.selected) + " cache files. Can't continue.")
						continueProcess = false
					)
					
					--	Si la carpeta SOURCE no está vacía pedimos confirmación de borrado o sobreescritura de los ficheros.
					if continueProcess then
					(
						if chkDeleteOldCacheFiles.checked then
						(
							if not queryBox "Destination SOURCE folder to save caches is not empty. Files will be deleted. Do you want to continue?" then continueProcess = false
						)
						else
						(
							if not queryBox "Destination SOURCE folder to save caches is not empty. Files will be overwriten. Do you want to continue?" then continueProcess = false
						)
					)
				)
					
				--	Si todos los pasos han sido correctos realizamos la conversión
				if continueProcess then
				(
					--	si solo vamos a convertir ciertos assets, el resto los borramos.
					for a in lb.asset.sceneAssets where findItem assetsToProcess a == 0 do
						lb.asset.deleteAsset a includeDependents:false
					
					--	conversión de la escena a caches
					-- se ha añadido de parametro desactivar cloth, para que no saque los caches de los objetos con cloth como tick en el ui
					lb.cache.convertSceneToCaches chkProcessAssets.checked chkProcessCaches.checked cachesFolder:cachesFolder pcFormat:ddlCacheFormat.selected deleteOldCacheFiles:chkDeleteOldCacheFiles.checked mergeXrefs:chkMergeXrefs.checked --disableCloth:chkDisableCloth.checked
					
					--	guardamos el nuevo fichero .max si se ha indicado
					if chkSaveNewMaxFile.checked then
					(
						saveMaxFile cacheFileName
						lb.materials.saveLib materialFileName
					)
					
					--	reiniciamos el listado de assets para mostrar el nuevo estado
					lb.assetManager.rollMain.resetSceneAssets()
				)
			)
			
			setArrowCursor()
			lb.assetManager.rollMain.createSceneEvents()
			lb.assetManager.rollMain.removeSceneEvents()
		)

		on rollCacheSceneDef rolledUp state do 
		(
			parent.heightAdjust 3
			--parent.rollCacheScene.open = state
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollCacheSceneDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCacheSceneDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCacheSceneDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollCacheSceneDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollCacheExtrasDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollCacheExtrasDef "Cache Manager"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		label lblOperateOn "Operate on:" pos:[5,0] width:160 height:15
		-- 		checkbutton ckbOperateOnAllAssets "All assets" pos:[5,15] width:65 height:20 checked:true 
		checkbutton ckbOperateOnSelAssets "Sel Assets" pos:[5,15] width:97 height:20 checked:true
		checkbutton ckbOperateOnSelection "Sel Objects" pos:[105,15] width:97 height:20
		checkbutton ckbOperateOnSelAssetsHair "Sel Assets Hair" pos:[5,38] width:97 height:20
			
		GroupBox grpRecordRange "Record range" pos:[5,65] width:202 height:85	
		spinner spnRecordStart "Start frame" pos:[30,85] width:110 height:15 range:[-1e+007,1e+007,0] type:#integer
		spinner spnRecordEnd "End frame  " pos:[30,105] width:110 height:15 range:[-1e+007,1e+007,100] type:#integer
		button btnGetRange "Get" pos:[165,85] width:35 height:35
		button btnRecordCache "Record" pos:[10,125] width:193 height:20 --images:#(iconpath + "bip_general_i.bmp", undefined, 30, 7, 7, 8, 8,true)
			
		GroupBox grpPlaybackRange "Playback type" pos:[5,155] width:202 height:130
		dropdownList ddlPlaybackType "" pos:[10,170] width:192 height:20 items:#("Original range", "Custom start", "Custom range","Loop range")
		spinner spnPlaybackStartFrame "Start" pos:[10,195] width:75 fieldwidth:35 height:16 enabled:false range:[-1e+007,1e+007,0] type:#integer
		spinner spnPlaybackEndFrame "End" pos:[10,215] width:75 fieldwidth:35 height:16 enabled:false range:[-1e+007,1e+007,100] type:#integer
		spinner spnCacheStrength "Strength" pos:[126,195] width:75 fieldwidth:35 height:16 range:[-10000,10000,1] type:#float
		checkbox chkCacheRelativeOffset "Relat. Offset" pos:[111,215] width:80 height:15
		-- 		checkbox chkCacheLoop "Loop cache" pos:[111,215] width:80 height:15
		button btnGetPlaybackData "Get" pos:[10,235] width:95 height:20 toolTip:"Gets playback data from operate objects"
		button btnApplyPlaybackData "Apply" pos:[110,235] width:91 height:20 toolTip:"Apply playback data to operate objects"
		button btnLoadCache "Load" pos:[10,260] width:192 height:20 toolTip:"Load cache files" --images:#(iconpath + "bip_general_i.bmp", undefined, 30, 5, 5, 6, 6,true)
			
		GroupBox grpCacheOperations "Cache operations" pos:[5,290] width:202 height:40
		button btnEnableCache "Enable" pos:[10,305] width:45 height:20 toolTip:"Enable cache modifiers"
		button btnDisableCache "Disable" pos:[60,305] width:45 height:20 toolTip:"Disable cache modifiers"
		button btnReloadCache "Reload" pos:[110,305] width:45 height:20 toolTip:"Reload cache modifiers"
		button btnResetCache "Reset" pos:[160,305] width:43 height:20 toolTip:"Unload all cache info in modifiers"
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		----------------------------------------------------------------------------------
		-- devuelve un array de objetos sobre los que hay que trabajar
		-- dependiendo de la opción OPERATE ON seleccionada (Asset, Selection o All Assets)
		----------------------------------------------------------------------------------
		fn getOperateObjects operateOnSelection:false =
		(
			_operateObjs = #()
			
			if operateOnSelection then
			(
				_operateObjs = for o in selection where (superclassof o == GeometryClass) collect o
			)
			else
			(
				for a in (lb.assetManager.getSelectedAssets()) do
				(
					_operateObjs += a.meshNodesAll + a.hairNodesAll + a.connectNodesAll
				)
			)--if else
			
			_operateObjs
		)
		
		--------------------------------------------------------------
		-- Activa o desactiva los spinners de playback según
		-- el tipo de playback seleccionado
		fn setPlaybackSpinnersState =
		(
			case ddlPlaybackType.selection of
			(
				1: (spnPlaybackStartFrame.enabled = false; spnPlaybackEndFrame.enabled = false)
				2: (spnPlaybackStartFrame.enabled = true; spnPlaybackEndFrame.enabled = false)
				3: (spnPlaybackStartFrame.enabled = true; spnPlaybackEndFrame.enabled = true)
				4: (spnPlaybackStartFrame.enabled = true; spnPlaybackEndFrame.enabled = true)
			)
		)

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollCacheExtrasDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollCacheExtrasDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		--------------------------------------------------------------
		on ckbOperateOnSelAssets changed val do 
		(
			if val then
			(
				ckbOperateOnSelection.checked = false
				ckbOperateOnSelAssetsHair.checked = false
			)
			else
				ckbOperateOnSelAssets.checked = true
		)
		
		--------------------------------------------------------------
		on ckbOperateOnSelection changed val do 
		(
			if val then
			(
				ckbOperateOnSelAssets.checked = false
				ckbOperateOnSelAssetsHair.checked = false
			)
			else
				ckbOperateOnSelection.checked = true
		)

		--------------------------------------------------------------
		on ckbOperateOnSelAssetsHair changed val do 
		(
			if val then
			(
				ckbOperateOnSelection.checked = false
				ckbOperateOnSelAssets.checked = false
			)
			else
				ckbOperateOnSelAssetsHair.checked = true
		)

		--------------------------------------------------------------
		on btnLoadCache pressed do
		(
			f = getsavepath "Point Cache folder" initialDir:maxFilePath
			if f != undefined then
			(
				operateObjs = getOperateObjects operateOnSelection:ckbOperateOnSelection.checked
				
				undo "Load Cache" on
				(
					for o in operateObjs do
					(
						filename = f + "\\" + (lb.nc.getSimpleObjectName o.name)
						
						lb.cache.loadCache o filename
					)
				)
			)
		)
		
		--------------------------------------------------------------
		on btnRecordCache pressed do
		(
			_operateObjs = getOperateObjects operateOnSelection:ckbOperateOnSelection.checked

			if ckbOperateOnSelAssetsHair.checked then
			(
				for i=_operateObjs.count to 1 by -1 do
				(
					_nPart5 = lb.nc.getNamePart	_operateObjs[i].name 5
					_isHairSysNode = false
					
					if not _isHairSysNode then _isHairSysNode = MatchPattern _nPart5 pattern:lb.nc.NC_HAIR_draftPattern
					if not _isHairSysNode then _isHairSysNode = MatchPattern _nPart5 pattern:lb.nc.NC_HAIR_drvPattern
					if not _isHairSysNode then _isHairSysNode = MatchPattern _nPart5 pattern:lb.nc.NC_HAIR_scalpPattern
					if not _isHairSysNode then _isHairSysNode = MatchPattern _nPart5 pattern:lb.nc.NC_HAIR_shadowPattern

					if not _isHairSysNode then deleteItem _operateObjs i
				)

				--print _operateObjs
				--print "-----------------------"
			)
			
			if (queryBox "Assets will be set to (CONNECT ALL) mode and Turbosmooths will be disabled in viewports. Do you want to continue?") then
			(
				assetsToPrepare = lb.asset.getAssetsFromNodes _operateObjs	--	 assets que hay que pasar a S+B y desactivar turbosmooths
				
				disableSceneRedraw()				
				
				--	Preparamos los assets para la grabación de cachés (paso a modo de visualizacion para caches con todo conectado)
				for a in assetsToPrepare do
					lb.assetManager.rollCacheScene.prepareAssetForCacheRecording a enableCloth:parent.rollCacheScene.chkEnableCloth.checked
				
				enableSceneRedraw()
				completeRedraw()
				
				--intenta que se abra en la carpeta de source de caches
				_currentPath = maxfilepath
				if matchPattern _currentPath pattern:"*anim\\" then
					if doesFileExist (substituteString _currentPath "anim\\" "cache\\") then
						_currentPath = (substituteString _currentPath "anim\\" "cache\\")
				
				_subFolders = getDirectories (_currentPath + "*") --busca los subdirectorios del actual
				_stop = false
				
				--busca el primer source que encuentre
				for _subF in _subFolders where not _stop do
				(
					if findString _subF "source" != undefined then (_currentPath = _subF; _stop = true)
					_subFolders += getDirectories (_subF + "*") --busca los subdirectorios del actual
				)--for
				
				f = getsavepath "Point Cache folder" initialDir:_currentPath historyCategory:"assetCache"
				if f != undefined then
				(
					setWaitCursor()
					progressStart "Saving Caches"
					
					for i = 1 to _operateObjs.count do
					(
						--	Capturamos el rango de animación del asset al que pertenece la pieza
						objAsset = (lb.asset.getAssetsFromNodes #(_operateObjs[i]))[1]
						recordRange = lb.asset.getAssetAnimRange objAsset timeRange:(interval spnRecordStart.value spnRecordEnd.value)
						
						lb.cache.recordCacheFromObject _operateObjs[i] f recordRange.start recordRange.end pcFormat:rollCacheSceneDef.ddlCacheFormat.selected
						
						progressUpdate (i * 100 / _operateObjs.count)
					)

					materialFileName = f + "\\" + (lb.materials.materialLibName maxFileName)
					lb.materials.saveLib materialFileName
					
					progressEnd()
					setArrowCursor()
				)
			)
		)
		
		--------------------------------------------------------------
		on btnGetRange pressed do
		(
			spnRecordStart.value = animationRange.start
			spnRecordEnd.value = animationRange.end
		)
		
		--------------------------------------------------------------
		on ddlPlaybackType selected val do
			setPlaybackSpinnersState()
		
		--------------------------------------------------------------
		on btnGetPlaybackData pressed do
		(
			operateObjs = getOperateObjects operateOnSelection:ckbOperateOnSelection.checked
			found = false
			i = 1
			
			while not found and i <= operateObjs.count do
			(
				mods = lb.cache.getCacheMods operateObjs[i]
				if mods.count > 0 then
				(
					found = true
					for m in mods do
					(
						ddlPlaybackType.selection = m.playbackType + 1
						spnPlaybackStartFrame.value = m.playbackStart
						spnPlaybackEndFrame.value = m.playbackEnd
						setPlaybackSpinnersState()
						spnCacheStrength.value = m.strength
						chkCacheRelativeOffset.checked = m.relativeOffset
					)
				)
				i += 1
			)
			
			if not found then lb.message.show "No Point Cache modifiers found on selected objects" type:#message pos:undefined size:[300,75] modal:true
		)
		
		--------------------------------------------------------------
		on btnApplyPlaybackData pressed do
		(
			operateObjs = getOperateObjects operateOnSelection:ckbOperateOnSelection.checked
			
			disableSceneRedraw()
			
			undo "Apply Playback Data" on
			(
				for o in operateObjs do
					lb.cache.setCachePlaybackData o playbackType:(ddlPlaybackType.selection - 1) playbackStart:spnPlaybackStartFrame.value playbackEnd:spnPlaybackEndFrame.value  strength:spnCacheStrength.value relativeOffset:chkCacheRelativeOffset.checked cacheLoop:(ddlPlaybackType.selection == 4)
			)
			
			enableSceneRedraw()
		)
		
		--------------------------------------------------------------
		on btnEnableCache pressed do
		(
			operateObjs = getOperateObjects operateOnSelection:ckbOperateOnSelection.checked
			
			undo "Enable Cache" on
			(
				for o in operateObjs do lb.cache.setCacheEnabled o true
			)
		)
		
		--------------------------------------------------------------
		on btnDisableCache pressed do
		(
			operateObjs = getOperateObjects operateOnSelection:ckbOperateOnSelection.checked
			
			undo "Disable Cache" on
			(
				for o in operateObjs do lb.cache.setCacheEnabled o false
			)
		)
		
		
		--------------------------------------------------------------
		on btnReloadCache pressed do
		(
			operateObjs = getOperateObjects operateOnSelection:ckbOperateOnSelection.checked
			
			for o in operateObjs do lb.cache.reloadCache o
		)
		
		--------------------------------------------------------------
		on btnResetCache pressed do
		(
			operateObjs = getOperateObjects operateOnSelection:ckbOperateOnSelection.checked
			
			undo "Reset Cache" on
			(
				for o in operateObjs do lb.cache.resetCache o
			)
		)

		on rollCacheExtrasDef rolledUp state do 
		(
			parent.heightAdjust 3
			--parent.rollCacheExtras.open = state
		)	

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollCacheExtrasDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCacheExtrasDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks

			spnRecordStart.value = animationRange.start
			spnRecordEnd.value = animationRange.end

			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCacheExtrasDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollCacheExtrasDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollAnimationDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollAnimationDef "Animation"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local animModeButtonsNonSelBG = (dotnetclass "system.drawing.color").fromargb 180 180 180
		local animModeButtonsSelBG = (dotnetclass "system.drawing.color").fromargb 150 150 255	

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		checkbutton chkOperateOnSelAssets "Sel Assets" pos:[5,0] width:98 height:20 checked:true
		checkbutton ckbOperateOnSelection "Sel Objects" pos:[108,0] width:98 height:20
		
		button btnLoadAnimation "Load" pos:[5,25] width:25 height:25 images:#(iconpath + "bip_general_i.bmp", undefined, 30, 5, 5, 6, 6,true) tooltip:"Load Animation"
		button btnSaveAnimation "Save" pos:[33,25] width:25 height:25 images:#(iconpath + "bip_general_i.bmp", undefined, 30, 7, 7, 8, 8,true) tooltip:"Save Animation"
		checkbox chkOneFilePerAsset "One file per asset" pos:[65,30] width:150 height:15 checked:true
			
		groupBox grpLoadOptions "Load options" pos:[5,55] width:114 height:90
		radiobuttons rdoRelAbs "" pos:[10,72] labels:#("Relative", "Absolute") columns:1 default:2
		radiobuttons rdoReplace "" pos:[10,108] labels:#("Replace", "Insert at") columns:1 default:2
		spinner spnInsertAt	"" pos:[73,123] width:43 type:#integer scale:1 range:[-1000,100000,0] enabled:true  
			
		groupBox grpSaveOptions "Save options" pos:[120,55] width:87 height:90
		checkbox chkSegment "Segment" pos:[124,72] width:63 height:15 checked:false
		button btnGetRange "GR" pos:[185,70] width:20 height:20 border:false enabled:false images:#(iconpath + "TrackViewTools_16i.bmp", undefined, 117, 50, 50, 52, 52, true) tooltip:"Get Animation Range"
		spinner spnFrom	"From" pos:[137,95] width:65 type:#integer scale:1 range:[-1000,100000,0] enabled:false
		spinner spnTo "   To" pos:[137,115] width:65 type:#integer scale:1 range:[-1000,100000,100] enabled:false
		
		groupBox grpLoadSaveFrom "Load to/Save from:" pos:[5,150] width:202 height:55
		radiobuttons rdoSaveFrom "" pos:[10,167] labels:#("Selected layers",  "Rig", "All animation", "Facial") columns:2 default:3
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		--------------------------------------------------------------
		--cambia entre las opciones de 
		--------------------------------------------------------------
		fn toggleSelAssetOptions checkedCtrl state =
		(
			case checkedCtrl of
			(
				-- 				ckbOperateOnAllAssets:
				-- 				(
				-- 					chkOperateOnSelAssets.checked = not state
				-- 					ckbOperateOnSelection.checked = not state
				-- 					rdoSaveFrom.enabled = true
				-- 				)
				
				chkOperateOnSelAssets:
				(
				-- 					ckbOperateOnAllAssets.checked = not state
					ckbOperateOnSelection.checked = not state
					rdoSaveFrom.enabled = true
				)
				
				ckbOperateOnSelection:
				(
				-- 					ckbOperateOnAllAssets.checked = not state
					chkOperateOnSelAssets.checked = not state
					rdoSaveFrom.enabled = false
				)
			)--case of
		)--toggle

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollAnimationDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollAnimationDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		--------------------------------------------------------------
		on chkOperateOnSelAssets changed state do
			if not state then
				chkOperateOnSelAssets.checked = true
			else
				toggleSelAssetOptions chkOperateOnSelAssets state
		
		--------------------------------------------------------------
		on ckbOperateOnSelection changed state do
			if not state then
				ckbOperateOnSelection.checked = true
			else
				toggleSelAssetOptions ckbOperateOnSelection state

		on rollAnimationDef rolledUp state do 
		(
			parent.heightAdjust 2
		)

		--------------------------------------------------------------
		on btnGetRange pressed do
		(
			spnFrom.value = animationRange.start.frame as integer
			spnTo.value = animationRange.end.frame as integer
		)
		
		--------------------------------------------------------------
		on chkSegment changed state do
		(
			btnGetRange.enabled = state
			spnFrom.enabled = state
			spnTo.enabled = state
		)	
		--------------------------------------------------------------
		--actualiza el estado del spinner de insertAt
		--------------------------------------------------------------
		
		on rdoReplace changed state do
			spnInsertAt.enabled = (rdoReplace.state == 2)	

		--------------------------------------------------------------
		--carga la animacion del asset seleccionado
		--si el check de All Assets esta activado se carga la animacion de todos los assets
		--si el check de Sel. layers only esta activado se carga la animacion de los layer seleccionados
		--------------------------------------------------------------
		on btnLoadAnimation pressed do
		(
			_duplicatedObjectNames = #()

			if chkOperateOnSelAssets.checked then
			(
				_assetsToUse = lb.assetManager.getSelectedAssets()

				if _assetsToUse.count != 0 then
				(
					for _asset in _assetsToUse do
					(
						_duplicatedAssetObjectNames = #()
						_assetObjs = #()

						for _node in _asset.animNodesAll do
						(
							_nodepartNames = filterString _node.name "_"
							if (matchPattern _nodepartNames[7] pattern: lb.nc.NC_controlFlag) or (matchPattern _nodepartNames[7] pattern: lb.nc.NC_extraFlag) then
							(
								_simpleName = _nodepartNames[3] + "_" + _nodepartNames[4] + "_" + _nodepartNames[5] 
								if not (appendIfUnique _assetObjs (toUpper(_simpleName))) then appendIfUnique _duplicatedAssetObjectNames _node
							)
						)
						for _node in _asset.facialNodesAll do
						(
							_nodepartNames = filterString _node.name "_"
							if (matchPattern _nodepartNames[7] pattern: lb.nc.NC_controlFlag) or (matchPattern _nodepartNames[7] pattern: lb.nc.NC_extraFlag) then
							(
								_simpleName = _nodepartNames[3] + "_" + _nodepartNames[4] + "_" + _nodepartNames[5] 
								if not (appendIfUnique _assetObjs (toUpper(_simpleName))) then appendIfUnique _duplicatedAssetObjectNames _node
							)
						)
						for _element in _duplicatedAssetObjectNames do append _duplicatedObjectNames _element
					) 
				)
				else 
				(
					lb.message.show "Select at least 1 asset"
					return undefined
				)	
			)
			else
			(
				_sel = getCurrentSelection()
				_assetObjs = #()

				for _obj in _sel do
				(
					_objNameParts = filterString _obj.name "_"
					if (matchPattern _objNameParts[7] pattern: lb.nc.NC_controlFlag) or (matchPattern _objNameParts[7] pattern: lb.nc.NC_extraFlag) then
					(
						if (_objNameParts[3] == lb.nc.NC_classFacial) or (_objNameParts[3] == lb.nc.NC_classAnim) then
						(
							_simpleName = _objNameParts[2] + "_" + _objNameParts[3] + "_" + _objNameParts[4] + "_" + _objNameParts[5] 
							if not (appendIfUnique _assetObjs (toUpper(_simpleName))) then appendIfUnique _duplicatedObjectNames _obj
						)
					)

				)
			)
			if _duplicatedObjectNames.count != 0 then
			(
				_message = "Duplicate names found In the pieces:\n\n"
				for _node in _duplicatedObjectNames do
				(
					_message = _message + _node.name + "\n" 
				)
				_message = _message + "\nAborting\n"
				lb.message.show _message type:#message pos:undefined size:[300,75] modal:true
				return undefined
			)

			assetsToLoad = #() --array con los assets de los que guardar la animacion
			nodesToLoad = #() --array de arrays con los nodos de cada asset de los que guardar animacion
			selNodes = #() --por si la animacion se guarda de los objetos seleccionados
			
			lvSelectedLayers = lb.assetManager.rollAdvanced.lvSelItems --lvSelectedItems
			
			if lb.asset.listedAssets.count != 0 then
			(
 				--if ckbOperateOnAllAssets.checked then --almacena todos los assets
 					--assetsToLoad = deepCopy listedAssets
				if chkOperateOnSelAssets.checked then --almacena solo los assets seleccionados
					assetsToLoad = lb.assetManager.getSelectedAssets()
				else if ckbOperateOnSelection.checked then --busca los assets de los objetos seleccionados y almacena un array de arrys de nodos y otro de nodos a renombrar
				(
					selNodes = getCurrentSelection()
					assetsToLoad = lb.asset.getAssetsFromNodes selNodes --mira que assets son los dueños de las piezas seleccionadas
						
					for i=1 to assetsToLoad.count do
						nodesToLoad[i] = #()
						
					for o in selNodes do
						for i=1 to assetsToLoad.count where findItem assetsToLoad[i].nodes o != 0 do
							append nodesToLoad[i] o
					
 						--for i=1 to assetsToLoad.count where (findItem assetsToLoad[i].rigNodesAll o != 0) or (findItem assetsToLoad[i].facialNodesAll o != 0) do
 							--append nodesToLoad[i] o
				)
			)
			
			nodes = #()
			nodesToRename = #()
			
			if not ckbOperateOnSelection.checked then --si es para todos los assets o los assets seleccionados
			(
				numLoadedAnimations = 0
				
				if chkOneFilePerAsset.checked then --un archivo por asset
				(
					--recorre los assets de los que guardar animacion y realiza las operaciones oportunas
					for a in assetsToLoad do
					(
						nodes = #()
						nodesToRename = #()
						
						case rdoSaveFrom.state of
						(
							1:
							(
								--recorre los layer seleccionados
								for i=0 to (lvSelectedLayers.count - 1) do
								(
									layerType = lvSelectedLayers.item[i].value
									
									--si es un tipo de layer animable, almacena su tipo
									if findItem lb.nc.NC_classAnimatable layerType != 0 then
									(
										join nodes (lb.asset.getAssetAnimNodes a layerType)
										join nodesToRename (lb.asset.getAssetNodesByType a #(layerType))
									)
								)--for
							)
							
							2:
							(
								nodes = (lb.asset.getAssetAnimNodes a lb.nc.NC_classAnim) 
								nodesToRename = a.animNodesAll --lb.asset.getAssetNodesByType a #(lb.nc.NC_classAnim)
							)
							
							3:
							(
								nodes = lb.asset.getAssetAnimNodes a #all
								nodesToRename = lb.asset.getAssetNodesByType a lb.nc.NC_classAnimatable
							)
							
							4:
							(
								nodes = lb.asset.getAssetAnimNodes a lb.nc.NC_classFacial
								nodesToRename = a.facialNodesAll --lb.asset.getAssetNodesByType a #(lb.nc.NC_classFacial)
							)
						)--case of
						
						--pregunta por el fichero de donde queremos cargar la animacion
						file = getOpenFileName caption:("Load Animation to " + a.fullname) types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
						
						--una vez obtenidos los nodos animables de el asset actual, cargamos su animacion
						if file != undefined then
							if (lb.asset.loadAnimation file nodes nodesToRename relative:(rdoRelAbs.state == 1) insert:(rdoReplace.state == 2) insTime:spnInsertAt.value) then
	 							numLoadedAnimations += 1
						
					)--for
				)
				else --un archivo general
				(
					nodes = #()
					nodesToRename = #()

					--recorre los assets de los que guardar animacion y realiza las operaciones oportunas
					for a in assetsToLoad do
					(						
						case rdoSaveFrom.state of
						(
							1:
							(
								--recorre los layer seleccionados
								for i=0 to (lvSelectedLayers.count - 1) do
								(
									layerType = lvSelectedLayers.item[i].value
									
									--si es un tipo de layer animable, almacena su tipo
									if findItem lb.nc.NC_classAnimatable layerType != 0 then
									(
										nodes += (lb.asset.getAssetAnimNodes a layerType)
										nodesToRename += (lb.asset.getAssetNodesByType a #(layerType))
									)
								)--for
							)
							
							2:
							(
								nodes += (lb.asset.getAssetAnimNodes a lb.nc.NC_classAnim) 
								nodesToRename += a.animNodesAll --lb.asset.getAssetNodesByType a #(lb.nc.NC_classAnim)
							)
							
							3:
							(
								nodes += lb.asset.getAssetAnimNodes a #all
								nodesToRename += lb.asset.getAssetNodesByType a lb.nc.NC_classAnimatable
							)
							
							4:
							(
								nodes += lb.asset.getAssetAnimNodes a lb.nc.NC_classFacial
								nodesToRename += a.facialNodesAll --lb.asset.getAssetNodesByType a #(lb.nc.NC_classFacial)
							)
						)--case of
					)--for

					--pregunta por el fichero de donde queremos cargar la animacion
					file = getOpenFileName caption:("Load Animation to <selected assets>") types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
					
					--una vez obtenidos los nodos animables de el asset actual, cargamos su animacion
					if file != undefined then
						if (lb.asset.loadAnimation file nodes nodesToRename relative:(rdoRelAbs.state == 1) insert:(rdoReplace.state == 2) insTime:spnInsertAt.value) then
 							numLoadedAnimations += 1
				)--if else				
				
				lb.message.show (numLoadedAnimations as string + " animations loaded successfully") type:#message pos:undefined size:[300,75] modal:true
			)
			else --si es para los objetos seleccionados
			(
				numLoadedAnimations = 0
				
				nonAssetObjects = #() --objetos que no pertenecen a ningun asset
				
				--busca los objetos que no pertenecen a ningun asset
				for obj in selNodes do
				(
					found = false
					
					for ast in assetsToLoad where findItem ast.nodes obj != 0 do--(findItem ast.rigNodesAll obj != 0) or (findItem ast.facialNodesAll obj != 0) do
						found = true
					
					if not found do
						appendIfUnique nonAssetObjects obj
				)

				if chkOneFilePerAsset.checked then --un archivo por asset
				(
					--carga la animacion de los assets
					for i=1 to assetsToLoad.count do
					(
						nodes = #()
						nodesToRename = #()
						
						nodes = nodesToLoad[i]
									
						nodesToRename = nodesToLoad[i]
						nodesToRenameParents = #()
						
						for obj in nodesToRename where obj.parent != undefined do
							appendIfUnique nodesToRenameParents obj.parent
						
						for obj in nodesToRenameParents do
							appendIfUnique nodesToRename obj
						
						--pregunta por el fichero donde queremos guardar la animacion
						file = getOpenFileName caption:("Load Animation to " + assetsToLoad[i].fullname) types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
						
						--una vez obtenidos los nodos animables de el asset actual, guardamos su animacion
						if file != undefined then
							if (lb.asset.loadAnimation file nodes nodesToRename relative:(rdoRelAbs.state == 1) insert:(rdoReplace.state == 2) insTime:spnInsertAt.value) then
								numLoadedAnimations += 1
						
					)--for
				)
				else
				(
					nodes = #()
					nodesToRename = #()

					--carga la animacion de los assets
					for i=1 to assetsToLoad.count do
					(						
						nodes += nodesToLoad[i]
									
						nodesToRename += nodesToLoad[i]
						nodesToRenameParents = #()
						
						for obj in nodesToRename where obj.parent != undefined do
							appendIfUnique nodesToRenameParents obj.parent
						
						for obj in nodesToRenameParents do
							appendIfUnique nodesToRename obj						
					)--for

					--pregunta por el fichero donde queremos guardar la animacion
					file = getOpenFileName caption:("Load Animation to <selected objects assets>") types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
					
					--una vez obtenidos los nodos animables de el asset actual, guardamos su animacion
					if file != undefined then
						if (lb.asset.loadAnimation file nodes nodesToRename relative:(rdoRelAbs.state == 1) insert:(rdoReplace.state == 2) insTime:spnInsertAt.value) then
							numLoadedAnimations += 1
				)--if else

				if nonAssetObjects.count != 0 then --si hay objetos seleccionados que no pertenecen a ningun asset, salvamos su animacion y sus links en un archivo a parte
				(
					nodes = #()
					nodesToRename = #()
						
					nodes = nonAssetObjects
						
					nodesToRename = nonAssetObjects
					nodesToRenameParents = #()
					
					for obj in nodesToRename where obj.parent != undefined do
						appendIfUnique nodesToRenameParents obj.parent
					
					for obj in nodesToRenameParents do
						appendIfUnique nodesToRename obj
					
					--pregunta por el fichero donde queremos guardar la animacion
					file = getOpenFileName caption:("Load Animation - Non asset objects") types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
						
					--una vez obtenidos los nodos animables de el asset actual, guardamos su animacion
					if file != undefined then
						if (lb.asset.loadAnimation file nodes nodesToRename relative:(rdoRelAbs.state == 1) insert:(rdoReplace.state == 2) insTime:spnInsertAt.value) then
							numLoadedAnimations += 1
					--saveAnimation file nodes nodesToRename	save
				)
				
				lb.message.show (numLoadedAnimations as string + " animations loaded successfully") type:#message pos:undefined size:[300,75] modal:true
			)--if	
		)--on
		
		--------------------------------------------------------------
		--salva la animacion del asset seleccionado
		--si el check de All Assets esta activado se guarda la animacion de todos los assets
		--si el check de Sel. layers only esta activado se guarda la animacion de los layer seleccionados
		--------------------------------------------------------------
		on btnSaveAnimation pressed do
		(
			if not (lb.misc.passAssetCheck CHK_NCuniqueNamesTask fix:false) do
			(
				lb.message.show "Duplicate names found. Aborting" type:#message pos:undefined size:[300,75] modal:true
				return undefined
			)

			assetsToSave = #() --array con los assets de los que guardar la animacion
			nodesToSave = #() --array de arrays con los nodos de cada asset de los que guardar animacion
			assetsToSaveProjectIds = #() --array con el id de proyecto de cada asset a salvar, para saber que técnica usar.
			selNodes = #() --por si la animacion se guarda de los objetos seleccionados
			
			lvSelectedLayers = lb.assetManager.rollAdvanced.lvSelItems --lvSelectedItems
			
			--necesitamos saber en que proyecto se está trabajando para salvar la animación con una técnica u otra.
			_projectId = undefined
			if maxfilePath != "" then
			(
				_prjct = (lb.project.getProjectByRoot (((filterString maxfilepath "\\")[1]) + "\\"))
				if _prjct != undefined then _projectId = _prjct.getId()
			)
			
			if lb.asset.listedAssets.count != 0 then
			(
 				--if ckbOperateOnAllAssets.checked then --almacena todos los assets
 					--assetsToSave = deepCopy listedAssets
				if chkOperateOnSelAssets.checked then --almacena solo los assets seleccionados
				(
					assetsToSave = lb.assetManager.getSelectedAssets()
				)
				else if ckbOperateOnSelection.checked then --busca los assets de los objetos seleccionados y almacena un array de arrys de nodos y otro de nodos a renombrar
				(
					selNodes = getCurrentSelection()
					assetsToSave = lb.asset.getAssetsFromNodes selNodes --mira que assets son los dueños de las piezas seleccionadas
						
					for i=1 to assetsToSave.count do
						nodesToSave[i] = #()
							
					for o in selNodes do
						for i=1 to assetsToSave.count where findItem assetsToSave[i].nodes o != 0 do
							append nodesToSave[i] o
 						--for i=1 to assetsToSave.count where (findItem assetsToSave[i].rigNodesAll o != 0) or (findItem assetsToSave[i].facialNodesAll o != 0) do
 							--append nodesToSave[i] o
				)--if
				
				--averigua el id de proyecto para cada asset
				for i=1 to assetsToSave.count do
				(
					if _projectId != undefined then
						assetsToSaveProjectIds[i] = _projectId
					else
					(
						_assetFolder = if assetsToSave[i].folder != "" then assetsToSave[i].folder else maxFilePath
						_drive = (filterString _assetFolder "\\:")[1] + "\\"
						_pj = lb.project.getProjectByRoot _drive
						assetsToSaveProjectIds[i] = if _pj != undefined then _pj.getId() else (lb.project.getProjectByRoot "z:\\").getId()
					)
				)--for
			)--if
			
			animInterval = (if chkSegment.checked then (interval spnFrom.value spnTo.value) else animationRange)
			
			if not ckbOperateOnSelection.checked then --si es para todos los assets o los assets seleccionados
			(
				numSavedAnimations = 0
				
				_oneFilePerAsset = false

				if chkOneFilePerAsset.checked then --un archivo por asset
				(
					--recorre los assets de los que guardar animacion y realiza las operaciones oportunas
					for i=1 to assetsToSave.count do
					(
						a = assetsToSave[i]
						nodes = #()
						nodesToRename = #()
						
						case rdoSaveFrom.state of
						(
							1:
							(
								--recorre los layer seleccionados
								for i=0 to (lvSelectedLayers.count - 1) do
								(
									layerType = lvSelectedLayers.item[i].value
									
									--si es un tipo de layer animable, almacena su tipo
									if findItem lb.nc.NC_classAnimatable layerType != 0 then
									(
										join nodes (lb.asset.getAssetAnimNodes a layerType)
										join nodesToRename (lb.asset.getAssetNodesByType a #(layerType))
									)
								)--for
							)
							
							2:
							(
								nodes = a.animNodesAll --lb.asset.getAssetAnimNodes a lb.nc.NC_classAnim
								nodesToRename = a.animNodesAll --lb.asset.getAssetNodesByType a #(lb.nc.NC_classAnim)
							)
							
							3:
							(
								nodes = lb.asset.getAssetAnimNodes a #all
								nodesToRename = lb.asset.getAssetNodesByType a lb.nc.NC_classAnimatable
							)
							
							4:
							(
								nodes = lb.asset.getAssetAnimNodes a lb.nc.NC_classFacial
								nodesToRename = a.facialNodesAll --lb.asset.getAssetNodesByType a #(lb.nc.NC_classFacial)
							)
						)--case of
						
						--pregunta por el fichero donde queremos guardar la animacion
						file = getSaveFileName caption:("Save Animation from " + a.fullname) types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
						
						--una vez obtenidos los nodos animables de el asset actual, guardamos su animacion
						if file != undefined then
							if (lb.asset.saveAnimation file nodes nodesToRename	saveSegment:true segInterval:animInterval projectId:assetsToSaveProjectIds[i]) then
								numSavedAnimations += 1
							--saveAnimation file nodes nodesToRename	saveSegment:chkSegment.checked segInterval:animInterval
					)--for
				)
				else --un archivo general
				(
					nodes = #()
					nodesToRename = #()

					--recorre los assets de los que guardar animacion y realiza las operaciones oportunas
					for i=1 to assetsToSave.count do
					(
						a = assetsToSave[i]						
						
						case rdoSaveFrom.state of
						(
							1:
							(
								--recorre los layer seleccionados
								for i=0 to (lvSelectedLayers.count - 1) do
								(
									layerType = lvSelectedLayers.item[i].value
									
									--si es un tipo de layer animable, almacena su tipo
									if findItem lb.nc.NC_classAnimatable layerType != 0 then
									(
										nodes += (lb.asset.getAssetAnimNodes a layerType)
										nodesToRename += (lb.asset.getAssetNodesByType a #(layerType))
									)
								)--for
							)
							
							2:
							(
								nodes += a.animNodesAll --lb.asset.getAssetAnimNodes a lb.nc.NC_classAnim
								nodesToRename += a.animNodesAll --lb.asset.getAssetNodesByType a #(lb.nc.NC_classAnim)
							)
							
							3:
							(
								nodes += lb.asset.getAssetAnimNodes a #all
								nodesToRename += lb.asset.getAssetNodesByType a lb.nc.NC_classAnimatable
							)
							
							4:
							(
								nodes += lb.asset.getAssetAnimNodes a lb.nc.NC_classFacial
								nodesToRename += a.facialNodesAll --lb.asset.getAssetNodesByType a #(lb.nc.NC_classFacial)
							)
						)--case of						
					)--for

					--pregunta por el fichero donde queremos guardar la animacion
					file = getSaveFileName caption:("Save Animation from <selected assets>") types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
					
					--una vez obtenidos los nodos animables de los assets, guardamos su animacion
					if file != undefined then
						if (lb.asset.saveAnimation file nodes nodesToRename	saveSegment:true segInterval:animInterval projectId:assetsToSaveProjectIds[1]) then
							numSavedAnimations += 1
						--saveAnimation file nodes nodesToRename	saveSegment:chkSegment.checked segInterval:animInterval
				)--if else				
				
				lb.message.show ((numSavedAnimations as string) + " animations saved successfully") type:#message pos:undefined size:[300,75] modal:true
			)
			else --si es para los objetos seleccionados
			(
				numSavedAnimations = 0
				
				nonAssetObjects = #() --objetos que no pertenecen a ningun asset
				
				--busca los objetos que no pertenecen a ningun asset
				for obj in selNodes do
				(
					found = false
					
					for ast in assetsToSave where findItem ast.nodes obj != 0 do-- (findItem ast.rigNodesAll obj != 0) or (findItem ast.facialNodesAll obj != 0) do
						found = true
					
					if not found do
						appendIfUnique nonAssetObjects obj
				)
				
				if chkOneFilePerAsset.checked then --un archivo por asset
				(
					--salva la animacion de los assets
					for i=1 to assetsToSave.count do
					(
						nodes = #()
						nodesToRename = #()
						
						nodes = nodesToSave[i]
									
						nodesToRename = nodesToSave[i]
						nodesToRenameParents = #()
						
						for obj in nodesToRename where obj.parent != undefined do
							appendIfUnique nodesToRenameParents obj.parent
						
						for obj in nodesToRenameParents do
							appendIfUnique nodesToRename obj
						
						--pregunta por el fichero donde queremos guardar la animacion
						file = getSaveFileName caption:("Save Animation from " + assetsToSave[i].fullname) types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
							
						--una vez obtenidos los nodos animables de el asset actual, guardamos su animacion
						if file != undefined then
							if  (lb.asset.saveAnimation file nodes nodesToRename	saveSegment:true segInterval:animInterval projectId:assetsToSaveProjectIds[i]) then
								numSavedAnimations += 1
							--saveAnimation file nodes nodesToRename	saveSegment:chkSegment.checked segInterval:animInterval						
					)--for
				)
				else --un archivo general
				(
					nodes = #()
					nodesToRename = #()

					--salva la animacion de los assets
					for i=1 to assetsToSave.count do
					(						
						nodes += nodesToSave[i]
									
						nodesToRename += nodesToSave[i]
						nodesToRenameParents = #()
						
						for obj in nodesToSave[i] where obj.parent != undefined do
							appendIfUnique nodesToRenameParents obj.parent
						
						for obj in nodesToRenameParents do
							appendIfUnique nodesToRename obj
						
					)--for
					
					--pregunta por el fichero donde queremos guardar la animacion
					file = getSaveFileName caption:("Save Animation from <selected obhjects assets>") types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
							
					--una vez obtenidos los nodos animables de el asset actual, guardamos su animacion
					if file != undefined then
						if  (lb.asset.saveAnimation file nodes nodesToRename	saveSegment:true segInterval:animInterval projectId:assetsToSaveProjectIds[1]) then
							numSavedAnimations += 1
						--saveAnimation file nodes nodesToRename	saveSegment:chkSegment.checked segInterval:animInterval						
				)--if else
				
				if nonAssetObjects.count != 0 then --si hay objetos seleccionados que no pertenecen a ningun asset, salvamos su animacion y sus links en un archivo a parte
				(
					nodes = #()
					nodesToRename = #()
						
					nodes = nonAssetObjects
						
					nodesToRename = nonAssetObjects
					nodesToRenameParents = #()
					
					for obj in nodesToRename where obj.parent != undefined do
						appendIfUnique nodesToRenameParents obj.parent
					
					for obj in nodesToRenameParents do
						appendIfUnique nodesToRename obj
					
					--pregunta por el fichero donde queremos guardar la animacion
					file = getSaveFileName caption:("Save Animation - Non asset objects") types:"animation(*.xaf)|*.xaf|Todos los formatos (*.*)|*.*|"
						
					--una vez obtenidos los nodos animables de el asset actual, guardamos su animacion
					if file != undefined then
						if  (lb.asset.saveAnimation file nodes nodesToRename saveSegment:true segInterval:animInterval projectId:(if _projectId != undefined then _projectId else ((lb.project.getProjectByDrive "z:\\").getId()))) then
							numSavedAnimations += 1
					--saveAnimation file nodes nodesToRename	save
				)--if
				
				lb.message.show ((numSavedAnimations as string) + " animations saved successfully") type:#message pos:undefined size:[300,75] modal:true
			)--if
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollAnimationDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollAnimationDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks

			spnInsertAt.value = animationRange.start

			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollAnimationDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollAnimationDef
	
	rollout rollSecondaryAnimationDef "Secondary Animation"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local animModeButtonsNonSelBG = (dotnetclass "system.drawing.color").fromargb 180 180 180
		local animModeButtonsSelBG = (dotnetclass "system.drawing.color").fromargb 150 150 255	

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
				
		button btnSave "Save Options" pos:[5,5] width:100 
		button btnLoad "Load Options" pos:[105,5] width:100 		
		groupBox grpPoint "Point" pos:[5,30] width:200 height:40
		spinner spnMass "Mass:" pos:[25,45] width:80 type:#float scale:1.0 range:[-10000.0,10000.0,300.0] --enabled:false
		spinner spnDrag "Drag:" pos:[120,45] width:80 type:#float scale:0.01 range:[0.0,10.0,1.0] --enabled:false
		
		groupBox grpSprings "Springs" pos:[5,75] width:200 height:40
		spinner spnTension "Tension:" pos:[28,92] width:70 type:#float scale:0.01 range:[-100.0,100.0,2.0] --enabled:false
		spinner spnDampering "Dampering:" pos:[130,92] width:73 type:#float scale:0.001 range:[-10.0,10.0,0.5]

		button btnBake "Bake Animation" pos:[5,120] width:100
		spinner spnPercent "Percent:" pos:[135,122] width:65 type:#integer scale:1 range:[0,100,100]
		button btnUnbake "Unbake Animation" pos:[5,145] width:200 
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollSecondaryAnimationDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollSecondaryAnimationDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		-----------------------------------------------------------------------------------
		--Recibe una cadena de huesos y mira si no se bifurca y si están unidos directamente.
		-----------------------------------------------------------------------------------
		fn verifyChain bonechain =
		(
			_chainOk = true
			if bonechain.count == 0 then _chainOk = false
			
			for i=bonechain.count to 1 by -1 where _chainOk do
			(
				--Si no es el último hueso entonces esperaremos que el padre sea el hueso anterior
				if i!= 1 then 
				(
					if bonechain[i].parent != bonechain[i-1] then
					(
						_chainOk = false
					)
				)
			)
			_chainOk
		)

		---------------------------------------------------------------------------------------
		--Crea una cadena de huesos con puntos y aplica springs en todos sus valores
		-- retorna: local struct springChain (springs = #(), lookAts = #())
		---------------------------------------------------------------------------------------
		fn createSpringSystem bonechain mass:300.0 drag:1.0 tension:2.0 dampering:0.5 effectPercent:100.0 =
		(
			struct springSystem (springs = #(), lookAts = #(), boneChain = #())
			_springSystem = springSystem()
			if bonechain[1].parent != undefined then 
			(
				_springChain = #()
				_lookAtChain = #()

				with animate off
				(
					--Ponemos el slider al comienzo de la animación
					sliderTime = animationRange.start

					--Creamos las dos cadenas de huesos y las emparentamos correctamente
					for i=1 to bonechain.count do
					(
						--Creamos y orientamos los puntos
						_springPoint = Point centermarker:false axistripod:false cross:false box:true constantscreensize:true
						_springPoint.transform = bonechain[i].transform
						append _springChain _springPoint

						_lookAtPoint = Point centermarker:false axistripod:true cross:false box:false constantscreensize:true
						_lookAtPoint.transform = bonechain[i].transform
						append _lookAtChain _lookAtPoint

						--Si son los primeros los emparentaremos al padre del inicio de la cadena de hueso dada, sino al hueso anterior.
						if i==1 then 
						(
							_springPoint.parent = bonechain[1].parent
							_lookAtPoint.parent = bonechain[1].parent
						)
						else
						(
							_springPoint.parent = _springChain[_springChain.count-1]
							_lookAtPoint.parent = _lookAtChain[_lookAtChain.count-1]
						)
					)
					
					--Ahora toca crear los springs (el primero no lleva)
					for i=2 to _springChain.count do
					(
						_springChain[i].position.controller = SpringPositionController()
						_springChain[i].position.controller.setMass mass
						_springChain[i].position.controller.setDrag drag
						_springChain[i].position.controller.setTension 1 tension
						_springChain[i].position.controller.setDampening 1 dampering

						_springChain[i].position.controller.x_effect = effectPercent
						_springChain[i].position.controller.y_effect = effectPercent
						_springChain[i].position.controller.z_effect = effectPercent
					)

					--Por ultimo los LookAt_Constraint
					for i=1 to _lookAtChain.count-1 do
					(
						_lookAtChain[i].rotation.controller = LookAt_Constraint()
						_lookAtChain[i].rotation.controller.appendTarget _springChain[i+1] 50.0
						_lookAtChain[i].rotation.controller.pickUpNode = _springChain[i+1] 
						_lookAtChain[i].rotation.controller.upnode_world = false
						_lookAtChain[i].rotation.controller.target_axisFlip = (bonechain[i].objectoffsetscale == [-1,1,1])
						_lookAtChain[i].rotation.controller.StoUP_axis = 2
						_lookAtChain[i].rotation.controller.viewline_length_abs = false
					)
				)
				_springSystem.springs = _springChain
				_springSystem.lookAts = _lookAtChain
				_springSystem.boneChain = bonechain
			)
			else
			(
				print "BAKE CHAIN: Bone chain starting bone has no parent, cannot bake."
				_springChain = undefined
			)
			_springSystem
		)
		
		------------------------------------------------------------------------
		-- Realiza un bakeo de la cadena de puntos con springs y lookats obtenidos de fn createSpringSystem
		fn bakeSpringSystem springSystem percent:100 =
		(
			for i=1 to springSystem.boneChain.count do
			(
				_bone = springSystem.boneChain[i]

				if not lb.animLayers.hasAnimLayers _bone then
				(
					lb.animLayers.enable _bone
					lb.animLayers.addLayer _bone suffix:"secAnim"
				)
				else
				(
					lb.animLayers.addLayer _bone
				)

				with animate on
				(
					for j=animationRange.start to animationRange.end do
					(
						--_tmpPoint = Point centermarker:false axistripod:false cross:true box:false constantscreensize:false size:2

						at time j
						(							
							/*_tmpPoint.transform = springSystem.lookAts[i].transform
							
							_pos = _tmpPoint.position
							_rot = _tmpPoint.rotation as eulerangles
							_rot.x = _rot.x*percent
							_rot.y = _rot.y*percent
							_rot.z = _rot.z*percent
							_tmpPoint.rotation = (_rot as quat)
							_tmpPoint.position = _pos

							_bone.transform = _tmpPoint.transform*/

							_bone.transform = springSystem.lookAts[i].transform
						)

						--delete _tmpPoint
					)--for
				)
			)
			
			--Una vez terminado borramos los puntos de lookat y spring
			delete springSystem.springs
			delete springSystem.lookAts
		)


		---------------------------------------------------------------------------------------
		--Crea una cadena de huesos con puntos y aplica springs en todos sus valores, 
		--luego lo bakea en la cadena objetivo
		---------------------------------------------------------------------------------------
		fn bakeSecondaryAnimation bonechain mass:300.0 drag:1.0 tension:2.0 dampering:0.5 percent:100 =
		(
			_isBone = (classof bonechain[bonechain.count].baseObject) == BoneGeometry
			if _isBone then
			(
				at time animationRange.start
				(
					_auxEndPoint = Point centermarker:false axistripod:false cross:false box:true constantscreensize:false size:5
					_auxEndPoint.transform = bonechain[bonechain.count].transform

					_offset = bonechain[bonechain.count].length
					if (bonechain[bonechain.count].objectoffsetscale == [-1,1,1]) then _offset = -_offset

					with animate off (in coordsys local (_auxEndPoint.position.x += _offset))
				)
				append boneChain _auxEndPoint
			)

			_springSystem = (createSpringSystem bonechain mass:mass drag:drag tension:tension dampering:dampering effectPercent:percent)
			if _springSystem != undefined then
			(
				bakeSpringSystem _springSystem percent:percent
			)

			if _isBone then delete _auxEndPoint
		)

		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		--Obtiene los settings de los springs de un xml
		on btnLoad pressed do
		(
			_filename = getOpenFileName caption:"Load Options File" types:"Spring Options File(*.spo)|*.spo"
			--print _filename
			if _filename == undefined and doesFileExist _filename then
			(
				spnMass.value = (lb.xml.getAttribute _filename ("spring/options") "mass") as Number
				spnDrag.value = (lb.xml.getAttribute _filename ("spring/options") "drag") as Number
				spnTension.value = (lb.xml.getAttribute _filename ("spring/options") "tension") as Number
				spnDampering.value = (lb.xml.getAttribute _filename ("spring/options") "dampering") as Number
			)
			else
			(
				lb.message.show "Could not load file."
			)
		)

		--Salva un xml con la configuración de springs
		on btnSave pressed do
		(
			_filename = undefined
			_nodes = (getCurrentSelection())

			--Sin selección sacamos la ruta del max
			if _nodes.count == 0 then
			(
				_filename = maxFilePath 
			)
			else
			(
				--Si hay más de un asset sacamos la ruta del max, sino la del asset
				_assets = lb.asset.getAssetsFromNodes _nodes[1]

				if _assets.count == 1 then
				(
					_filename = _assets[1].folder
				)
				else
				(
					_filename = maxfilepath
				)
			)

			if _filename == undefined  or _filename == "" then
			(
				_filename = "c:\\spring_options.spo"
			)
			else
			(
				_filename += "spring_options.spo"
			)

			_filename = getSaveFileName caption:"Save Options File" filename:_filename 

			lb.xml.setAttribute _filename ("spring/options") "mass" (spnMass.value As String)
			lb.xml.setAttribute _filename ("spring/options") "drag" (spnDrag.value As String)
			lb.xml.setAttribute _filename ("spring/options") "tension" (spnTension.value As String)
			lb.xml.setAttribute _filename ("spring/options") "dampering" (spnDampering.value As String)
		)

		--Botón de unbakear animación, borra las capas que encuentre con el sufijo "secAnim"
		on btnUnbake pressed do
		(
			_selection = getCurrentSelection()

			--elimina lo que no sean huesos de la seleccion
			--for i=_selection.count to 1 by -1 where classof _selection[i].baseObject != BoneGeometry do deleteItem _selection i

			--Elimina una capa por selección
			if _selection.count > 0 then
			(
				_sliderTimeBackup = sliderTime
				setWaitCursor()
				sliderTime = animationRange.start
				
				_boneslists = lb.rig.getHierarchiesFromNodes _selection useVirtualHierarchy:false

				for _bones in _bonesLists do
				(
					for _bone in _bones do
					(
						lb.animLayers.removeLayerBySuffix _bone "secAnim"
						if (lb.animLayers.count _bone) == 1 then 
						(
							lb.animLayers.disable _bone
						)
					)
				)

				setArrowCursor()
				sliderTime = _sliderTimeBackup
			)
			else
			(
				lb.message.show "UNBAKE SECONDARY ANIMATION: No nodes are selected. Aborting."
			)
		)

		--Botón de bakear animación
		on btnBake pressed do
		(
			_selection = getCurrentSelection()

			--elimina lo que no sean huesos de la seleccion
			--for i=_selection.count to 1 by -1 where classof _selection[i].baseObject != BoneGeometry do deleteItem _selection i

			if _selection.count > 0 then
			(
				_sliderTimeBackup = sliderTime
				setWaitCursor()

				_boneslists = lb.rig.getHierarchiesFromNodes _selection useVirtualHierarchy:false
				for _bones in _bonesLists do
				(
					--primero hace unbake de la animacion
					for _bone in _bones do
					(
						lb.animLayers.removeLayerBySuffix _bone "secAnim"
						if (lb.animLayers.count _bone) == 1 then 
						(
							lb.animLayers.disable _bone
						)
					)

					--hace bake de la animacion
					if (verifyChain _bones) then
					(
						bakeSecondaryAnimation _bones mass:spnMass.value drag:spnDrag.value tension:spnTension.value dampering:spnDampering.value percent:(spnPercent.value)
					)
					else
					(
						print "BAKE SECONDARY ANIMATION: Bones are not directly linked or chain bifurcates, aborting process."
					)
				)

				setArrowCursor()
				sliderTime = _sliderTimeBackup
			)
			else
			(
				lb.message.show "BAKE SECONDARY ANIMATION: No bones are selected, please select one or more bones."
			)
		)

		------------------------------------------------
		--COMMON
		------------------------------------------------

		on rollSecondaryAnimationDef rolledUp state do 
		(
			parent.heightAdjust 2
		)

		

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollSecondaryAnimationDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollSecondaryAnimationDef open do
		(
			--loadSettings()
			--createSceneEvents() --crea los callbacks

			--spnInsertAt.value = animationRange.start

			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollSecondaryAnimationDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollSecondaryAnimationDef

	rollout rollCacheReloadAssetDef "Asset Reload"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		button btnReloadAsset "Reload Asset" pos:[10,5] width:192 height:20
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollCacheReloadAssetDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollCacheReloadAssetDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		------------------------------------------------
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on btnReloadAsset pressed do 
		(
			_isPrpSetAsset = false
			--Configuramos la tool de creación de puntos des de objetos
			_tool = (lb.getScript "createPointsFromObjects")
			--Conseguimos el asset a usar de la seleccion del asset manager
			_assetsToUse = lb.assetManager.getSelectedAssets()
			if _assetsToUse.count == 1 then
			(
				for _node in _assetsToUse[1].nodes do
				(
					if (matchpattern _node.name pattern: "*base*") or (matchpattern _node.name pattern: "*handCross*") then 
					(
						--Creamos los puntos en la base y los controles de ik
						select _node
						_tool.run() --lanza el script
					)
				)
			
				--Debemos cambiar de tab del assetManager para que las llamadas a las funciones de alli no se "pudren"
				lb.assetManager.rollMain.tbTabs.selectedTabPageIndex = 1
				--Salvamos la animación
				lb.assetManager.rollAnimation.btnSaveAnimation.pressed()
				
				if lb.nodeInfo.hasNodeInfo _assetsToUse[1].nodes[1] and _assetsToUse[1].nodes[1].nodeInfo.fileHistory.count != 0 then
				(
					_assetBaseName = undefined
					_assetfileHistory = undefined
					for j = 1 to _assetsToUse[1].nodes[1].nodeInfo.fileHistory.count do
					(
						if ((filterString  _assetsToUse[1].nodes[1].nodeInfo.fileHistory[j] "\\")[3]) == lb.nc.NC_setPrefix or ((filterString  _assetsToUse[1].nodes[1].nodeInfo.fileHistory[j] "\\")[3]) == lb.nc.NC_prpPrefix then
						(
							_isPrpSetAsset = true
							if ((filterString  _assetsToUse[1].nodes[1].nodeInfo.fileHistory[j] "\\")[6]) == lb.nc.NC_presetFolderName then
							(
								_assetBaseName =  _assetsToUse[1].nodes[1].nodeInfo.layerNameHistory[j]
								_assetfileHistory = _assetsToUse[1].nodes[1].nodeInfo.fileHistory[j]
							)
						)
						else
						(
							if ((filterString  _assetsToUse[1].nodes[1].nodeInfo.fileHistory[j] "\\")[7]) == lb.nc.NC_presetFolderName then
							(
								_assetBaseName =  _assetsToUse[1].nodes[1].nodeInfo.layerNameHistory[j]
								_assetfileHistory = _assetsToUse[1].nodes[1].nodeInfo.fileHistory[j]
							)
						)

					)
					if _assetfileHistory != undefined then
					(
						lb.assetManager.rollMain.selectAssetByName _assetBaseName
						lb.assetManager.rollMain.btnDeleteAsset.pressed()
						--Cargamos el preset
						if not doesFileExist (_assetfileHistory) then 
						(
							_assetfileHistory = getOpenFileName filename:(_assetfileHistory) caption: ("Archivo "+ (_assetfileHistory))
						)	
						--Cargaremos siempre la ultima versión del Preset del Asset
						--------------------------------------------------------------------------
						
						_assetFileHistoryFolderParts = filterString _assetfileHistory "\\"
						if not _isPrpSetAsset then
						(
							_assetHistoryFolder = _assetFileHistoryFolderParts[1]+"\\"+_assetFileHistoryFolderParts[2]+"\\"+_assetFileHistoryFolderParts[3]+"\\"+_assetFileHistoryFolderParts[4]+"\\"+_assetFileHistoryFolderParts[5]+"\\"+_assetFileHistoryFolderParts[6]+"\\"+_assetFileHistoryFolderParts[7]+"\\"+"*.prt"
						)
						else
						(
							_assetHistoryFolder = _assetFileHistoryFolderParts[1]+"\\"+_assetFileHistoryFolderParts[2]+"\\"+_assetFileHistoryFolderParts[3]+"\\"+_assetFileHistoryFolderParts[4]+"\\"+_assetFileHistoryFolderParts[5]+"\\"+_assetFileHistoryFolderParts[6]+"\\"+"*.prt"
						)
						_files = getFiles _assetHistoryFolder

						_fromParts = filterString _assetfileHistory "_"
						_fromVersion = (filterString _fromParts[_fromParts.count] ".")[1]
						_newFrom = substituteString _assetfileHistory _fromVersion "v*"
						_hightestIndex = (-1)
						_highestVersionName = ""
						for _file in _files do
						(
							if matchpattern _file pattern:(_newFrom) do
							(
								_fileParts =  filterString _file "_"
								_fileVersion = (filterString _fileParts[_fileParts.count] ".")[1]
								_fileVersion = (filterString _fileVersion "v")[1]
								if (_fileVersion as integer) > (_hightestIndex as integer) then
								(
									_hightestIndex = _fileVersion
									_highestVersionName = _file	
								)
							)
						)
						_assetfileHistory = _highestVersionName
						---------------------------------------------------------------------------
						
						lb.presets.loadPreset _assetfileHistory
						--Vamos a la pestaña de renombrado y renombramos el asset como se llamaba antes
						lb.assetManager.rollMain.tbTabs.selectedTabPageIndex = 7
						lb.assetManager.rollMain.selectAssetByName _assetBaseName
						--refrescamos la memoria del asset con las nuevas referencias
						_assetsToUse = lb.assetManager.getSelectedAssets()
						_assetBaseName = substituteString _assetBaseName "chr_" ""
						lb.assetManager.rollMisc.edtAssetName.text = _assetBaseName
						lb.assetManager.rollMisc.btnRenameAsset.pressed()
						--Cargamos la animación guardada
						lb.assetManager.rollAnimation.btnLoadAnimation.pressed()
					)
					else lb.message.show "Preset not found in asset's nodeInfo, tool closing "
				)

				lb.assetManager.rollMain.tbTabs.selectedTabPageIndex = 2
				--Alineamos la base y las ik's a los puntos que se habian crreado antes
				_pointsToDelete = #()
				if not _isPrpSetAsset then
				(
					for _node in _assetsToUse[1].nodes do
					(
						if (matchpattern _node.name pattern: "*base*") then 
						(
							for _point in helpers do 
							(
								if (matchpattern _point.name pattern: "*base*") then 
								(
									_node.transform = _point.transform
									append _pointsToDelete _point
								)
							)
						)
						if (matchpattern _node.name pattern: "*l_handCross*") then 
						(
							for _point in helpers do 
							(
								if (matchpattern _point.name pattern: "*l_handCross*") then 
								(
									_node.transform = _point.transform
									append _pointsToDelete _point
								)
							)
						)
						if (matchpattern _node.name pattern: "*r_handCross*") then 
						(
							for _point in helpers do 
							(
								if (matchpattern _point.name pattern: "*r_handCross*") then 
								(
									_node.transform = _point.transform
									append _pointsToDelete _point
								)
							)
						)
					)
					delete _pointsToDelete
				)
				--Volvemos al tab inicial
			) else lb.message.show "Select only 1 asset."
		
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollCacheReloadAssetDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCacheReloadAssetDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCacheReloadAssetDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)

	)--rollCacheReloadAssetDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollExample1Def | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollCopiesVariationsDef "Copy Variations"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		checkbox chkVariationsEnable "enabled" pos:[5,0] width:75 checked:true
		
		label lblVariationPos "Pos" pos:[5,20] width:30 height:15
		spinner spnVariationPosX "" pos:[55,20] width:50 height:16 range:[-100000,100000,0]
		spinner spnVariationPosY "" pos:[105,20] width:50 height:16 range:[-100000,100000,0]
		spinner spnVariationPosZ "" pos:[155,20] width:50 height:16 range:[-100000,100000,0]
		
		label lblVariationRot "Rot" pos:[5,35] width:30 height:15
		spinner spnVariationRotX "" pos:[55,35] width:50 height:16 range:[-100000,100000,0]
		spinner spnVariationRotY "" pos:[105,35] width:50 height:16 range:[-100000,100000,0]
		spinner spnVariationRotZ "" pos:[155,35] width:50 height:16 range:[-100000,100000,0]
		
		label lblVariationScale "scale%" pos:[5,50] width:35 height:15
		spinner spnVariationScaleX "" pos:[55,50] width:50 height:16 range:[0,100000,0]
		spinner spnVariationScaleY "" pos:[105,50] width:50 height:16 range:[0,100000,0] enabled:false --visible:false
		-- 		label lblVariationScaleYdisabled "" pos:[106,32] width:38 height:15 enabled:false visible:true style_sunkenedge:true
		spinner spnVariationScaleZ "" pos:[155,50] width:50 height:16 range:[0,100000,0] enabled:false --visible:false
		-- 		label lblVariationScaleZdisabled "" pos:[156,32] width:38 height:15 enabled:false visible:true style_sunkenedge:true
		checkButton ckbVariationScaleLock "" pos:[42,50] width:13 height:16 images:#(iconpath + "LockButtonExt_i.bmp", undefined, 2, 2, 1, 1, 1,true) checked:true border:false
		
		button btnVariationReset "Reset" pos:[5,75] width:200 height:20
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollCopiesVariationsDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollCopiesVariationsDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		----------------------------------------------------------------------------------
		--actualiza el interface con los locks
		----------------------------------------------------------------------------------
		on ckbVariationScaleLock changed state do
		(
			spnVariationScaleY.value = spnVariationScaleZ.value = spnVariationScaleX.value
			
			spnVariationScaleY.enabled = not state
			-- 			spnVariationScaleY.visible = not state
			-- 			lblVariationScaleYdisabled.visible = state
			
			spnVariationScaleZ.enabled = not state
			-- 			spnVariationScaleZ.visible = not state
			-- 			lblVariationScaleZdisabled.visible = state
		)
		
		----------------------------------------------------------------------------------
		--habilita o deshabilita las variaciones
		----------------------------------------------------------------------------------
		on chkVariationsEnable changed state do
		(
			lblVariationPos.enabled = state
			spnVariationPosX.enabled = state
			spnVariationPosY.enabled = state
			spnVariationPosZ.enabled = state
			
			lblVariationRot.enabled = state
			spnVariationRotX.enabled = state
			spnVariationRotY.enabled = state
			spnVariationRotZ.enabled = state
			
			lblVariationScale.enabled = state
			spnVariationScaleX.enabled = state
			spnVariationScaleY.enabled = state and not ckbVariationScaleLock.checked
			spnVariationScaleZ.enabled = state and not ckbVariationScaleLock.checked
			ckbVariationScaleLock.enabled = state
			
			btnVariationReset.enabled = state
		)
			
		----------------------------------------------------------------------------------
		--resetea los valores de los spinners
		----------------------------------------------------------------------------------
		on btnVariationReset pressed do
		(
			spnVariationPosX.value = spnVariationPosY.value = spnVariationPosZ.value = 0
			spnVariationRotX.value = spnVariationRotY.value = spnVariationRotZ.value = 0
			spnVariationScaleX.value = spnVariationScaleY.value = spnVariationScaleZ.value = 0
		)
		
		----------------------------------------------------------------------------------
		--actualiza los valores de escala
		----------------------------------------------------------------------------------
		on spnVariationScaleX changed val do
			if ckbVariationScaleLock.checked then
				spnVariationScaleY.value = spnVariationScaleZ.value = val		

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollCopiesVariationsDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCopiesVariationsDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCopiesVariationsDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollCopiesVariationsDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollExample1Def | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollExample1Def "Example rollout 1"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		--@control | controlName | Plantilla de comentario para controles
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollExample1Def.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollExample1Def.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollExample1Def resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollExample1Def open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollExample1Def close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollExample1Def
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollpreCamFramesDef | Pone en la escena el keyfocus X frames antes del Cam range start de la camara.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollpreCamFramesDef "Set Start Time"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		spinner spnOffsetTime "" range:[-1000000,1000000,10] type:#integer pos:[5,7] width:80 height:20 enabled:true
		button btnGo "Go to frame!" pos:[90, 5] width:80 height:20 enabled:true
		button btnZero "0!" pos:[180,5] width:20 height:20 enabled:true
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		fn setPreCamXFrames numframes _optionValue=
		(
			_cameras = lb.cameraFunctions.getSceneCameras()
			if _cameras.count == 0 then
			(
				lb.message.show "Debe de haber una camara en escena"
			)
			else if cameras.count >0 then
			( 
				if not lb.cameraFunctions.hasCamInfo _cameras[1] then 
				(
					lb.cameraFunctions.addCamInfo _cameras[1]
					_camRange = lb.animation.getAnimRange _cameras[1]
		 			_cameras[1].camInfo.recStart = _camRange.start
		 			_cameras[1].camInfo.recEnd 	= _camRange.end
	 			)
				case _optionValue of
				(
					1:
					(
						firstFrame = _cameras[1].camInfo.recStart - numframes
					)
					2:
					(
						firstFrame = 0
					)
				)
				-------------------------------------------------------------------------------------------------
				--deja el rango de anomacion adaptado
				animationRange = interval firstFrame _cameras[1].camInfo.recEnd
				----------------------------------------------------------------------------------------
				sliderTime = firstFrame

			)
		)
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollExample1Def.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollExample1Def.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		on btnGo pressed do 
		(
			setPreCamXFrames spnOffsetTime.value 1
		)

		on btnZero pressed do 
		(
			setPreCamXFrames spnOffsetTime.value 2
		)
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollpreCamFramesDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollpreCamFramesDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollpreCamFramesDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollpreCamFramesDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollExample1Def | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollClothOverrideDef "Cloth Override"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		spinner spnStartFrame "" range:[-1000000,1000000,0] type:#integer pos:[5,7] width:100 height:20 enabled:true
		button btnOverride "Override!" pos:[120, 5] width:80 height:20 enabled:true
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollClothOverrideDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollClothOverrideDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------

		on btnOverride pressed do 
		(
			_mod = modPanel.getCurrentObject()
			if classof _mod == Cloth then
			(	
				_mod.startframe = spnStartFrame.value
				lb.message.show ("<" + _mod.name + ">:\n\n Simulation start frame set to " + (spnStartFrame.value As String))	
			)
			else
			(
				lb.message.show "You must select cloth modifier"
			)
		)

		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollClothOverrideDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollClothOverrideDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollClothOverrideDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollClothOverrideDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollPrepareAnimDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollPrepareAnimDef "Prepare animation"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		button btnPrepareAnimation "Prepare animation" pos:[5,5] width:197 height:20 toolTip:"Prepares the animation file deleting all the keys previous to the current animation range and creating zero poses 10 and 20 frames before the animation."
		spinner spnPreAnimationFrames "Pre animation frames" pos:[5,30] type:#integer range:[1,99999,20]
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollPrepareAnimDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollPrepareAnimDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		------------------------------------------------
		--prepara el asset para que tenga animacion previa al rango, para telas y pelos
		------------------------------------------------
		on btnPrepareAnimation pressed do 
		(
			if (querybox "This operation can't be undo. Do you want to continue?") then
			(
				setWaitCursor() --pone el cursor de espera
				
				firstFrame = animationRange.start --	primer fotograma del rango de animación
				
				-------------------------------------------------------------------------------------------------
				--Assets a procesar. Solo tratamos los assets de tipo Character.
				assetsToProcess = for a in lb.assetManager.getSelectedAssets() where a.type == lb.nc.NC_chrPrefix collect a
				-------------------------------------------------------------------------------------------------
				
				--	creamos una clave a todas las piezas animables al princpio del rango de animación y borramos la animación que pueda haber antes.
				--	creamos la pose zero tantos frames antes de la animación como indique el spinner.
				with undo off
				(					
					for a in assetsToProcess do lb.asset.prepareAnimation a spnPreAnimationFrames.value
				)
				
				-------------------------------------------------------------------------------------------------
				--deja el rango de anomacion adaptado
				animationRange = interval (firstFrame - spnPreAnimationFrames.value) animationRange.end
				-------------------------------------------------------------------------------------------------
				
				completeRedraw() --redibuja el viewport
				setArrowCursor() --deja el cursor en modo flecha
			)
		)

		on rollPrepareAnimDef rolledUp state do 
		(
			parent.heightAdjust 4
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollPrepareAnimDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollPrepareAnimDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollPrepareAnimDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollPrepareAnimDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollClothGeneralDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollClothGeneralDef "Cloth Visualization"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		groupBox grpClothVisModes "Cloth Visualization Modes" pos:[5,5] width:200 height:47
		button btnVMcloth "Cloth" pos:[10,21] width:40 height:25
		button btnVMskinCloth "Skin + Cloth" pos:[55,21] width:65 height:25
		button btnTurbosmoothEnable "" pos:[152,21] width:22 height:25 images:#(iconpath + "patches_24i.bmp", undefined, 2, 2, 2, 2, 2,true) tooltip:"Enable asset/s turbosmooth"
		button btnTurbosmoothDisable "" pos:[178,21] width:20 height:25 images:#(iconpath + "patches_24i.bmp", undefined, 2, 1, 1, 1, 1,true) tooltip:"Disable asset/s turbosmooth"
		button btnModifiersClothEnable ""  pos:[127,21] width:20 height:25 images:#(iconpath + "IsolateSelection_16i.bmp", undefined, 1, 1, 1, 1, 1,true) tooltip:"Enable/Disable asset modifiers above current cloth modifier selected "
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------

		----------------------------------------------------------------------------------
		--devuelve un array con los assets con los que trabajar segun la opcion de usar
		--los seleccionados en la escena o en el listado
		----------------------------------------------------------------------------------
		fn getAssetsToWork =
		(
			_assetsToWork = #() --array para almacenar los assets que se pondran en el modo de visualizacion
			
			_assetsToWork = lb.assetManager.getSelectedAssets()
			
			_assetsToWork --devuelve los assets con los que trabajar
		)	

		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollClothGeneralDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollClothGeneralDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------

		----------------------------------------------------------------------------------
		--cambia los assets que proceda a modo cloth
		----------------------------------------------------------------------------------
		on btnVMcloth pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion cloth
			with undo off			
				for ast in _assetsToWork do lb.asset.setAssetClothMode ast
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
				
			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		
		----------------------------------------------------------------------------------
		--cambia los assets que proceda a modo skin + cloth
		----------------------------------------------------------------------------------
		on btnVMskinCloth pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			setWaitCursor()			
			disableSceneRedraw()
			suspendEditing()
				
			--pone cada asset en el modo de visualizacion skin + cloth
			with undo off
				for ast in _assetsToWork do lb.asset.setAssetSkinClothMode ast
				
			resumeEditing()
			enableSceneRedraw()
			completeRedraw()
			setArrowCursor()
				
			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		----------------------------------------------------------------------------------
		--activa los modificadores por encima del modificador seleccionado (de cloth) para todo el asset
		----------------------------------------------------------------------------------
		on btnModifiersClothEnable pressed do
		(
			_selection = getCurrentSelection()
			if _selection.count == 1 then
			(
				_mod = modPanel.getCurrentObject() 
				if classOf _mod == Cloth then
				(
					_done = false
					for i = 1 to _selection[1].modifiers.count do
					(
						if (not _done) do
						(
							_selection[1].modifiers[i].enabled = (not _mod.enabled)
						)
					if _mod == _selection[1].modifiers[i] do _done = true
					)
					
					_assetsToUse = lb.assetManager.getSelectedAssets()
					for _asset in _assetsToUse do
					(
						_hasClothModifiers = false
						for _node in _asset.nodes where _node.name != _selection[1].name do
						(
							_limit = 0
							for i = _node.modifiers.count to 1 by -1 do
							(
								if (classOf _node.modifiers[i] == Cloth) and not _hasClothModifiers do 
								(
									_limit = i
									_hasClothModifiers = true
								)
							)
							if _hasClothModifiers do
							(
								for i = 1 to _limit do
								(
									_node.modifiers[i].enabled = _mod.enabled
								)
							)
						)
					)
					suspendEditing()
					resumeEditing()
				)
				else lb.message.show "Selecciona un modificador de cloth de un asset para Activar/Desactivar"
			)
			else lb.message.show "Selecciona un objeto de un asset"

		)

		----------------------------------------------------------------------------------
		--activa los turbosmooths
		----------------------------------------------------------------------------------
		on btnTurbosmoothEnable pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			for ast in _assetsToWork do lb.asset.enableAssetTurbosmooths ast --activa los turbosmooths
		)
		
		----------------------------------------------------------------------------------
		--desactiva los turbosmooths
		----------------------------------------------------------------------------------
		on btnTurbosmoothDisable pressed do
		(
			_assetsToWork = getAssetsToWork() --obtiene los assets con los que trabajar
			for ast in _assetsToWork do lb.asset.disableAssetTurbosmooths ast --desactiva los turbosmooths
		)

		------------------------------------------------
		--COMMON
		------------------------------------------------

		on rollClothGeneralDef rolledUp state do 
		(
			parent.heightAdjust 4
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollClothGeneralDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollClothGeneralDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollClothGeneralDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollClothGeneralDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollClothImportExportDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollClothImportExportDef "Cloth Import"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------

		checkbutton chkOperateOnSelAssetsCloth "Sel Assets" pos:[11,5] width:90 height:20 checked:true
		checkbutton ckbOperateOnSelectionCloth "Sel Objects" pos:[109,5] width:90 height:20
		
		button btnImportCloth "Import Selected Asset/s Cloth" pos:[5,35] width:195 height:20


		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollClothImportExportDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollClothImportExportDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------

		----------------------------------------------------------------------------------
		--cambia las opciones en funcion de los checkbuttons inciales, para elegir con que assets trabaja
		----------------------------------------------------------------------------------
		on chkOperateOnSelAssetsCloth changed state do
		(
			if state then
				ckbOperateOnSelectionCloth.checked = false
			else
				chkOperateOnSelAssetsCloth.checked = true
		)	
			
		on ckbOperateOnSelectionCloth changed state do
		(
			if state then
				chkOperateOnSelAssetsCloth.checked = false
			else
				ckbOperateOnSelectionCloth.checked = true
		)

		on btnImportCloth pressed do 
		(
			_assetsToUse = #()
			_selNodes = #()

			if chkOperateOnSelAssetsCloth.checked then --almacena solo los assets seleccionados
			(
				_assetsToUse = lb.assetManager.getSelectedAssets()
			)
			else if ckbOperateOnSelectionCloth.checked then --busca los assets de los objetos seleccionados y almacena un array de arrys de nodos y otro de nodos a renombrar
			(
				_selNodes = getCurrentSelection()
				if _selNodes.count != 0 then
				(
					_assetsToUse = lb.asset.getAssetsFromNodes _selNodes --mira que assets son los dueños de las piezas seleccionadas
				)
				else lb.message.show "Select at least 1 object"					
			)--if
			_filesInScene = #()
			
			for _asset in _assetsToUse do
			(
				for _node in _asset.meshNodesAll where lb.nodeInfo.hasNodeInfo _node do
				(
					for _fileHistory in _node.nodeInfo.fileHistory do
					(
						if matchpattern _fileHistory pattern: ("*" + lb.nc.NC_presetFolderName+ "*") do appendIfUnique _filesInScene _fileHistory
					)
				) 
			)
			
			for _file in _filesInScene do 
			(
				_routeParts = filterString _file "\\"
				_route = _routeParts[1] + "\\" + _routeParts[2] + "\\" + _routeParts[3] + "\\" + _routeParts[4] + "\\" + _routeParts[5] + "\\" + lb.nc.NC_versionFolderName + "\\" + lb.nc.NC_baseFolderName + "\\"
				_routeFileName = (filterString _file "\\")[8]
				_routeFileName = filterString _routeFileName "_"
				_routeFileName = _routeFileName[1] + "_" + _routeFileName[2] + "_" + lb.nc.NC_clothFileName + "_v01" 

				_clothFile = getOpenFileName filename:(_route+_routeFileName) caption: ("Archivo de cloth para "+ (_routeFileName))
				
				if _clothFile != undefined then
				(
					--Hacemos un set del frame de animacion en 0
					lb.assetManager.rollpreCamFrames.setPreCamXFrames 10 2

					--Activamos el modo skin + cloths
					--Activamos la pestaña de crear para que vaya más fluido
					max create mode
					
					setWaitCursor()			
					disableSceneRedraw()
					suspendEditing()
						
					--pone cada asset en el modo de visualizacion skin + cloth
					with undo off
						for ast in _assetsToUse do lb.asset.setAssetSkinClothMode ast
						
					resumeEditing()
					enableSceneRedraw()
					completeRedraw()
					setArrowCursor()
						
					lb.assetManager.rollAdvanced.fillLayerControls()
					
					--Cargamos el fichero de cloth del base via merge.
					_ast = lb.asset.loadAsset _clothFile #merge

					if ckbOperateOnSelectionCloth.checked then
					(
						_notDeleteNodes = #()
						for _astNode in _ast do 
						(
							for _nodeSel in _selNodes do 
							(
								_nodeSelPart5 = (filterString _nodeSel.name "_")[5]
								_astNodePart5 = (filterString _astNode.name "_")[5]
								if matchPattern _astNodePart5 pattern: ("*-"+_nodeSelPart5+"*") do appendIfUnique _notDeleteNodes _astNode
							)
						)
						for i = _ast.count to 1 by -1 do
						(
							if (findItem _notDeleteNodes _ast[i]) == 0 do
							(
								_objToDelete = _ast[i]
								deleteItem _ast i
								delete _objToDelete	
							) 
						)
						if _ast.count == 0 then lb.message.show "Los objetos seleccionados no tienen ninguna pieza de cloth"
					)

					
					--Por ahora asumiremos que en la carga del asset, solo existe un personaje de cada tipo en escena, y cargaremos el cloth al "base"
					if _ast != undefined then
					(
						_astLayer = _ast[1].layer

						for _astNode in _ast do
						(

							--recalculamos la ruta de la carpeta de skin del asset
							_route = _routeParts[1] + "\\" + _routeParts[2] + "\\" + _routeParts[3] + "\\" + _routeParts[4] + "\\" + _routeParts[5] + "\\" + lb.nc.NC_rigFolderName + "\\" + "skin" + "\\"
							_versionNumber = _astNode.nodeInfo.FileHistory[_astNode.nodeInfo.FileHistory.count]
							_versionNumber = (filterString _versionNumber "\\")[8] 
							_versionNumber = (filterString _versionNumber "_")[4]
							_versionNumber = (filterString _versionNumber ".")[1]
							_route = _route + _versionNumber + "\\"
							
							--quitamos el #00X y redirigimos el asset a la capa correspondiente, borrando la que queda vacía
							_astNode.name = (lb.nc.removeAssetNumber (_astNode.name))
							target = LayerManager.getLayerFromName (lb.nc.removeAssetNumber (_astNode.layer.name))
							target.addNode _astNode

							--Cargaremos los skins a las piezas de cloth
							--Añadir el modificador skin
							lb.skin.addSkinModifier _astNode

							--Añadir la info de skin de cloth 	
							_skinMod = lb.modifiers.getNodeModifier _astNode skin

							if (_skinMod != undefined) then
							(
								_filename = _astNode.nodeInfo.nameHistory[_astNode.nodeInfo.nameHistory.count] 
								_skinFile = _route+_filename+".skn"
								if not doesFileExist (_route+_filename+".skn") then 
								(
									_skinFile = getOpenFileName filename:(_route+_filename+".skn") caption: ("Archivo de skin para "+ (_astNode.name))
								)
								
								if _skinFile != undefined do lb.skin.loadSkin _skinFile _skinMod
							)
							
							
							--Hay que borrar los skins/Skin Morph de las piezas de mesh que tengan su drv, y hacer un skin wrap a éstas
							_astNodeNamePart5 = (filterString _astNode.name  "_")[5]
							if  not matchpattern _astNodeNamePart5 pattern: "*col-*" do
							(
								_astNodeNamePart5 =( filterString _astNodeNamePart5 "-")[2]
								for _asset in _assetsToUse do
								(
									for _node in _asset.nodes do 
									(
										_nodePart5 = (filterString _node.name  "_")[5]
										if _astNodeNamePart5 == _nodePart5 then
										(
											--borramos los modificadores
											for j=_node.modifiers.count to 1 by -1 do
											(

												if classOf _node.modifiers[j] == Skin then
												(
													deleteModifier _node _node.modifiers[j]
												)
												if classOf _node.modifiers[j] == Skin_Morph then
												(
													deleteModifier _node _node.modifiers[j]
												)
											)
											--Añadimos Skin wrap al drv
											_skinWrap = skin_Wrap()
											addModifier _node _skinWrap before:20
											--Configuramos el target del _skinWrap
											append _skinWrap.meshlist _astNode

											--Rompemos el XRef del objeto
											objXRefMgr.MergeXRefItemsIntoScene _node.baseObject
											objXRefMgr.MergeXRefItemsIntoScene _node.baseObject.controller
										)
									)
								)
							)
							
							--Configuramos el Frame incial del cloth con el frame inicial de la camara (donde empezar a simular)
							for _modifier in _astNode.modifiers where classof _modifier == Cloth do
							(
								_cameras = lb.cameraFunctions.getSceneCameras()								 
								_modifier.startframe = _cameras[1].camInfo.recStart - 10
							)

						) 
						--Con la capa vacía, la podemos borrar.
						layerManager.deleteLayerByName _astLayer.name
					)
					--Volvemos a dejar la camara como estaba, en su rango inicial
					lb.assetManager.rollpreCamFrames.setPreCamXFrames 0 1
					gc()
				)
			)
		)


		------------------------------------------------
		--COMMON
		------------------------------------------------

		on rollClothImportExportDef rolledUp state do 
		(
			parent.heightAdjust 4
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollClothImportExportDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollClothImportExportDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollClothImportExportDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollClothImportExportDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollClothDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollClothDef "Cloth"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual		
		
		local minRollWidth = 225	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 100	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		/*groupBox grpClothVisModes "Cloth Visualization Modes" pos:[5,220] width:200 height:47
		button btnVMcloth "Cloth" pos:[10,236] width:40 height:25
		button btnVMskinCloth "Skin + Cloth" pos:[55,236] width:65 height:25
		button btnTurbosmoothEnable "" pos:[142,236] width:25 height:25 images:#(iconpath + "patches_24i.bmp", undefined, 2, 2, 2, 2, 2,true) tooltip:"Enable asset/s turbosmooth"
		button btnTurbosmoothDisable "" pos:[172,236] width:25 height:25 images:#(iconpath + "patches_24i.bmp", undefined, 2, 1, 1, 1, 1,true) tooltip:"Disable asset/s turbosmooth"*/

		/*checkbutton chkOperateOnSelAssetsCloth "Sel Assets" pos:[11,5] width:90 height:20 checked:true
		checkbutton ckbOperateOnSelectionCloth "Sel Objects" pos:[109,5] width:90 height:20

		button btnLoadCloth "Load" pos:[11,30] width:25 height:25 images:#(iconpath + "bip_general_i.bmp", undefined, 30, 5, 5, 6, 6,true) tooltip:"Load Cloth"
		button btnSaveCloth "Save" pos:[39,30] width:25 height:25 images:#(iconpath + "bip_general_i.bmp", undefined, 30, 7, 7, 8, 8,true) tooltip:"Save Cloth"*/

		/*button btnImportCloth "Import Sel" pos:[75,30] width:60 height:25 
		button btnLoadFromCloth "Load From" pos:[138,30] width:60 height:25 */

		groupBox grpClothModifier "Cloth Modifier" pos:[5,5] width:200 height:75 
		button btnAddClothModifier "Add Cloth" pos:[11,21] width:90 height:25 
		button btnAddCollisionModifier "Add Collision" pos:[110,21] width:90 height:25 
		button btnSetInitialState "Set Initial State" pos:[11,50] width:90 height:25 
		button btnResetClothModifier "Reset Cloth" pos:[110,50] width:90 height:25 

		groupBox grpClothFixes "Cloth Fix" pos:[5,85] width:200 height:75 
		button btnFixPoly "Edit Poly Fix" pos:[11,101] width:90 height:25 
		button btnFixMesh "Edit Mesh Fix" pos:[110,101] width:90 height:25 
		button btnFixPush "Edit Push Fix" pos:[11,131] width:90 height:25 
		button btnFixRelax "Edit Relax Fix" pos:[110,131] width:90 height:25

		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		----------------------------------------------------------------------------------
		--devuelve un array con los assets con los que trabajar segun la opcion de usar
		--los seleccionados en la escena o en el listado
		----------------------------------------------------------------------------------
		fn getAssetsToWork =
		(
			_assetsToWork = #() --array para almacenar los assets que se pondran en el modo de visualizacion
			
			_assetsToWork = lb.assetManager.getSelectedAssets()
			
			_assetsToWork --devuelve los assets con los que trabajar
		)

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollClothDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollClothDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		/*----------------------------------------------------------------------------------
		--cambia las opciones en funcion de los checkbuttons inciales, para elegir con que assets trabaja
		----------------------------------------------------------------------------------
		on chkOperateOnSelAssetsCloth changed state do
		(
			if state then
				ckbOperateOnSelectionCloth.checked = false
			else
				chkOperateOnSelAssetsCloth.checked = true
		)	
			
		on ckbOperateOnSelectionCloth changed state do
		(
			if state then
				chkOperateOnSelAssetsCloth.checked = false
			else
				ckbOperateOnSelectionCloth.checked = true
		)*/

		on btnFixMesh pressed do
		(
		    fix_editMesh = (Edit_Mesh())
		    
		    fix_editMesh.name = "Fix_editMesh_01"
		        
		    index = 0
		        
		    filterName = undefined

			if lb.asset.listedAssets.count != 0 then
			(
				_objectsToUse = #()
				/*if chkOperateOnSelAssetsCloth.checked then --almacena todos los objetos de los assets seleccionados
				(
					for _asset in lb.assetManager.getSelectedAssets() do
						_objectsToUse += _asset.clothNodesAll
				)
				else if ckbOperateOnSelectionCloth.checked then --filtra en los objetos seleccionados aquellos que sean de cloth
				(*/
				_objectsToUse = for o in getCurrentSelection() where (lb.nc.getObjectType o) == lb.nc.NC_classCloth collect o
		-- 				)--if

			    for o in _objectsToUse do
			    (
			        for m in o.modifiers where (classOf m == Edit_Mesh) do
			        (
			                index = index +1
			                filterName = filterString m.name "_"
			        )
			        
			        if filterName != undefined then
			        (
			            filterName[3] = "0" + (((execute filterName[3]) + index) as string)

			            finalName = filterName[1] + "_" + filterName[2] + "_" + filterName[3]
			            
			            fix_editMesh.name = finalName
			            
			            addModifier o fix_editMesh
			        )
			        else
			            addModifier o fix_editMesh
			    )
			)		    
		)

		on btnFixPoly pressed do
		(
			fix_editPoly = (edit_poly())
	    
		    fix_editPoly.name = "Fix_editPoly_01"
		        
		    index = 0
		        
		    filterName = undefined

			if lb.asset.listedAssets.count != 0 then
			(
				_objectsToUse = #()
				/*if chkOperateOnSelAssetsCloth.checked then --almacena todos los objetos de los assets seleccionados
				(
					for _asset in lb.assetManager.getSelectedAssets() do
						_objectsToUse += _asset.clothNodesAll
				)
				else if ckbOperateOnSelectionCloth.checked then --filtra en los objetos seleccionados aquellos que sean de cloth
				(*/
				objectsToUse = for o in getCurrentSelection() where (lb.nc.getObjectType o) == lb.nc.NC_classCloth collect o
		-- 				)--if
			    for o in _objectsToUse do
			    (
			        for m in o.modifiers where (classOf m == edit_poly) do
			        (
			                index = index +1
			                filterName = filterString m.name "_"
			        )
			        
			        if filterName != undefined then
			        (
			            filterName[3] = "0" + (((execute filterName[3]) + index) as string)

			            finalName = filterName[1] + "_" + filterName[2] + "_" + filterName[3]
			            
			            fix_editPoly.name = finalName
			            
			            addModifier o fix_editPoly
			        )
			        else
			            addModifier o fix_editPoly
			    )
			)		    
		)

		on btnFixPush pressed do
		(
		    fix_Push = (Push())
		    
		    fix_Push.name = "Fix_push_01"
		        
		    index = 0
		        
		    filterName = undefined

			if lb.asset.listedAssets.count != 0 then
			(
				_objectsToUse = #()
				/*if chkOperateOnSelAssetsCloth.checked then --almacena todos los objetos de los assets seleccionados
				(
					for _asset in lb.assetManager.getSelectedAssets() do
						_objectsToUse += _asset.clothNodesAll
				)
				else if ckbOperateOnSelectionCloth.checked then --filtra en los objetos seleccionados aquellos que sean de cloth
				(*/
				_objectsToUse = for o in getCurrentSelection() where (lb.nc.getObjectType o) == lb.nc.NC_classCloth collect o
		-- 				)--if

			    for o in _objectsToUse do
			    (
			        for m in o.modifiers where (classOf m == Push) do
			        (
			                index = index +1
			                filterName = filterString m.name "_"
			        )
			        
			        if filterName != undefined then
			        (
			            filterName[3] = "0" + (((execute filterName[3]) + index) as string)

			            finalName = filterName[1] + "_" + filterName[2] + "_" + filterName[3]
			            
			            fix_push.name = finalName
			            
			            addModifier o fix_push
			        )
			        else
			            addModifier o fix_push
			    )			
			)		    
		)

		on btnFixRelax pressed do
		(
		    fix_relax = (Relax())
		    
		    fix_relax.name = "Fix_relax_01"
		        
		    index = 0
		        
		    filterName = undefined
			if lb.asset.listedAssets.count != 0 then
			(
				_objectsToUse = #()
				/*if chkOperateOnSelAssetsCloth.checked then --almacena todos los objetos de los assets seleccionados
				(
					for _asset in lb.assetManager.getSelectedAssets() do
						_objectsToUse += _asset.clothNodesAll
				)
				else if ckbOperateOnSelectionCloth.checked then --filtra en los objetos seleccionados aquellos que sean de cloth
				(*/
				_objectsToUse = for o in getCurrentSelection() where (lb.nc.getObjectType o) == lb.nc.NC_classCloth collect o
			-- 				)--if

			    for o in _objectsToUse do
			    (
			        for m in o.modifiers where (classOf m == Relax) do
			        (
			                index = index +1
			                filterName = filterString m.name "_"
			        )
			        
			        if filterName != undefined then
			        (
			            filterName[3] = "0" + (((execute filterName[3]) + index) as string)

			            finalName = filterName[1] + "_" + filterName[2] + "_" + filterName[3]
			            
			            fix_relax.name = finalName
			            
			            addModifier o fix_relax
			        )
			        else
			            addModifier o fix_relax
			    )
			)		    
		)

		on btnAddClothModifier pressed do
		(
			if lb.asset.listedAssets.count != 0 then
			(
				_objectsToUse = getCurrentSelection()
				for i=1 to _objectsToUse.count do
				(
					lb.cloth.addClothModifier _objectsToUse[i] type:#cloth
				)
			)
		)

		on btnAddCollisionModifier pressed do
		(
			if lb.asset.listedAssets.count != 0 then
			(
				_objectsToUse = getCurrentSelection()
				for i=1 to _objectsToUse.count do
				(
					lb.cloth.addClothModifier _objectsToUse[i] type:#collision
				)
			)
		)

		on btnResetClothModifier pressed do
		(
			if lb.asset.listedAssets.count != 0 then
			(
				-- Nos aseguramos que estamos en el panel modificar
				if (getCommandPanelTaskMode()) != #modify then setCommandPanelTaskMode #modify
					
				-- Capturamos el modificador actual seleccionado
				_mod = modPanel.getCurrentObject() 
					
				if classof _mod == Cloth then
				(
					_objectsToUse = getCurrentSelection()
					for i=1 to _objectsToUse.count do
					(
						lb.cloth.resetClothModifier _objectsToUse[i] _mod 
					)
				)
			)
		)

		on btnSetInitialState pressed do
		(
			if lb.asset.listedAssets.count != 0 then
			(
				_objectsToUse = getCurrentSelection()
				for i=1 to _objectsToUse.count do
				(
					lb.cloth.setInitialStateCloth _objectsToUse[i]
				)
			)
		)

		on rollClothDef rolledUp state do 
		(
			parent.heightAdjust 5
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollClothDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollClothDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollClothDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollClothDef
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollCopiesDef | Contiene la herramienta plantilla.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollCopiesDef "Asset Copies"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual	

		local minRollWidth = 180	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 450	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------

		local lvSelItemsArray = #()	-- array de índices de elementos seleccionados del listView. Se usa para poder restablecerlos después.
		local lastCopyOption = 3 --ultima opcion de copia elegida
		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		checkbutton ckbAssetsBySelObjects "Asts by Selection" pos:[5,0] width:86 height:20 tooltip:"Assets from selected objects"
		checkbutton chkOperateOnSelAssets "Sel Assets" pos:[94,0] width:57 height:20 tooltip:"Selected assets from asset list"
		checkbutton ckbOperateOnSelection "Sel Objs" pos:[154,0] width:52 height:20 tooltip:"Selected objects" checked:true
				
		checkbutton ckbStartCopy "Copy" pos:[5,30] width:200 height:20
		--checkbox chkDependents "dependents" pos:[130,33] width:100 height:15 checked:true
		
		groupBox grpCopyModes "Copy Modes" pos:[5,52] width:202 height:35
		radiobuttons rdoCopyModes pos:[10,69] width:190 height:20 labels:#("Paint        ", "Place", "Make") columns:3 default:3
		
		groupBox grpCopyOptions "Copy Options" pos:[5,90] width:202 height:85
		radioButtons rdoCopyOptions pos:[10,107] width:190 height:20 labels:#("instance   ", "reference", "copy") columns:3 default:3
		editText edtSufix pos:[7,130] width:160 height:15
		label lblSufix "Sufix" pos:[170,132] width:30
		spinner spnNumberCopies "number of copies:" pos:[60,152] width:80 height:15 range:[1,10000,1] type:#integer
		checkbox chkAutogrid "autogrid" pos:[10,152] width:60 height:15 checked:true
		checkbox chkNormalAlign "normalAlign" pos:[70,152] width:75 height:15 checked:true
		checkbox chkByGroup "byGroup" pos:[145,152] width:60 height:15 checked:true

		groupBox grpCopyOffsets "Copy Offsets" pos:[5,178] width:202 height:95
		label lblOffsetPos "Pos" pos:[10,195] width:30 height:15
		spinner spnOffsetPosX "" pos:[55,195] width:50 height:16 range:[-100000,100000,0]
		spinner spnOffsetPosY "" pos:[105,195] width:50 height:16 range:[-100000,100000,0]
		spinner spnOffsetPosZ "" pos:[155,195] width:50 height:16 range:[-100000,100000,0]
		
		label lblOffsetRot "Rot inc" pos:[10,210] width:60 height:15
		checkbox chkOffsetRotIncrementals pos:[42,210] width:13 checked:true tooltip:"enable/disable incremental rotation"
		spinner spnOffsetRotX "" pos:[55,210] width:50 height:16 range:[-100000,100000,0]
		spinner spnOffsetRotY "" pos:[105,210] width:50 height:16 range:[-100000,100000,0]
		spinner spnOffsetRotZ "" pos:[155,210] width:50 height:16 range:[-100000,100000,0]
		
		label lblOffsetScale "scale%" pos:[10,225] width:35 height:15
		spinner spnOffsetScaleX "" pos:[55,225] width:50 height:16 range:[0,100000,100]
		spinner spnOffsetScaleY "" pos:[105,225] width:50 height:16 range:[0,100000,100] enabled:false --visible:false
		-- 		label lblOffsetScaleYdisabled "" pos:[106,32] width:38 height:15 enabled:false visible:true style_sunkenedge:true
		spinner spnOffsetScaleZ "" pos:[155,225] width:50 height:16 range:[0,100000,100] enabled:false --visible:false
		-- 		label lblOffsetScaleZdisabled "" pos:[156,32] width:38 height:15 enabled:false visible:true style_sunkenedge:true
		checkButton ckbOffsetScaleLock "" pos:[42,225] width:13 height:16 images:#(iconpath + "LockButtonExt_i.bmp", undefined, 2, 2, 1, 1, 1,true) checked:true border:false
		
		button btnOffsetReset "Reset" pos:[10,245] width:195 height:20

		groupBox grpRandom "Random Options" pos:[5,275] width:202 height:115
		checkbox chkVariationsEnable "enabled" pos:[10,290] width:75 checked:true
		label lblVariationPos "Pos" pos:[10,310] width:30 height:15
		spinner spnVariationPosX "" pos:[55,310] width:50 height:16 range:[-100000,100000,0]
		spinner spnVariationPosY "" pos:[105,310] width:50 height:16 range:[-100000,100000,0]
		spinner spnVariationPosZ "" pos:[155,310] width:50 height:16 range:[-100000,100000,0]
		
		label lblVariationRot "Rot" pos:[10,325] width:30 height:15
		spinner spnVariationRotX "" pos:[55,325] width:50 height:16 range:[-100000,100000,0]
		spinner spnVariationRotY "" pos:[105,325] width:50 height:16 range:[-100000,100000,0]
		spinner spnVariationRotZ "" pos:[155,325] width:50 height:16 range:[-100000,100000,0]
		
		label lblVariationScale "scale%" pos:[10,340] width:35 height:15
		spinner spnVariationScaleX "" pos:[55,340] width:50 height:16 range:[0,100000,0]
		spinner spnVariationScaleY "" pos:[105,340] width:50 height:16 range:[0,100000,0] enabled:false --visible:false
		-- 		label lblVariationScaleYdisabled "" pos:[106,32] width:38 height:15 enabled:false visible:true style_sunkenedge:true
		spinner spnVariationScaleZ "" pos:[155,340] width:50 height:16 range:[0,100000,0] enabled:false --visible:false
		-- 		label lblVariationScaleZdisabled "" pos:[156,32] width:38 height:15 enabled:false visible:true style_sunkenedge:true
		checkButton ckbVariationScaleLock "" pos:[42,340] width:13 height:16 images:#(iconpath + "LockButtonExt_i.bmp", undefined, 2, 2, 1, 1, 1,true) checked:true border:false
		
		button btnVariationReset "Reset" pos:[10,360] width:195 height:20

		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		----------------------------------------------------------------------------------
		--actualiza el interface comun
		----------------------------------------------------------------------------------
		fn updateUI =
		(
			-- 			chkDependents.enabled = not ckbOperateOnSelection.checked
			
			case rdoCopyModes.state of
			(
				1:--Paint
				(
					ckbStartCopy.caption = "Copy: Paint"
			-- 					ckbStartCopy.caption = "Copy: Place"
					
					spnNumberCopies.enabled = false
					spnNumberCopies.visible = false
					
					chkAutogrid.enabled = true
					chkAutogrid.visible = true
					
					chkNormalAlign.enabled = chkAutogrid.checked
					chkNormalAlign.visible = true
				)--Paint
				
				2:--Place
				(
					ckbStartCopy.caption = "Copy: Place"
					
					spnNumberCopies.enabled = false
					spnNumberCopies.visible = false
					
					chkAutogrid.enabled = true
					chkAutogrid.visible = true
					
					chkNormalAlign.enabled = chkAutogrid.checked
					chkNormalAlign.visible = true
				)--Place
				
				3:--Make
				(
					ckbStartCopy.caption = "Copy: Make"
					
					spnNumberCopies.enabled = true
					spnNumberCopies.visible = true
					
					chkAutogrid.enabled = false
					chkAutogrid.visible = false
					chkNormalAlign.enabled = false
					chkNormalAlign.visible = false
				)--Place
			)--case of
		)
		
		----------------------------------------------------------------------------------
		--obtiene los assets seleccionados del listado en un array que se deben copiar
		--se devuelven en un array de arrays en el que cada array es un grupo de dependencia
		--se devuelven por grupos de dependencia porque hay que copiarlos en bloque
		--si el asset principal de un grupo de dependencia no estaba seleccionado, los assets dependientes de ese grupo no se copian
		--mode: #fromSelection -- obtiene los assets de los objetos seleccionados de la escena
		--mode: #fromSelAssets -- obtiene los assets de los seleccionados en el listado del assetManager
		--
		--devuelve algo de este tipo: #(#(), #(), #())
		----------------------------------------------------------------------------------
		fn getAssetsToCopy mode:#fromSelection dependents:true allAssets:#() =
		(
			depGroups = #() --array de arrays para guardar los grupos de dependencia de assets
			asts = #() --array de assets del que sacar los grupos de dependencia
			
			--si no se han pasado assets donde buscar los dependientes, usa sceneassets
			if allAssets.count == 0 then allAssets = lb.asset.sceneAssets
			
			case mode of
			(
				#fromSelection: --obtiene los assets de la seleccion de la escena
				(
					asts = lb.asset.getAssetsFromNodes (getCurrentSelection()) --obtiene los assets según la seleccion de objetos de la escena
				)--#fromSelection
				
				#fromSelAssets: --obtiene los assets del listado del assetManager
				(
					asts = for index in selAssets collect listedAssets[index]
				)--#fromSelAssets
				
			)--case mode
			
			if dependents then --si tiene que coger los dependientes tambien
				for ast in asts do --recorre los assets obteniendo los grupos de dependencia
				(
					depG = (lb.asset.getDependencyGroup ast allAssets)
					if depG.count != 0 then
					(
						found = false
						for dg in depGroups where dg[1].fullname == depG[1].fullname do
							found = true
						
						if not found then append depGroups depG
					)
				)
			else --si no tiene que coger los dependientes
				for ast in asts do
				(
					depG = (lb.asset.getDependencyGroup ast asts)
					
					if depG.count != 0 then
					(
						found = false
						for dg in depGroups where dg[1].fullname == depG[1].fullname do
							found = true
						
						if not found then append depGroups depG
					)
					else
						append depGroups #(ast)
				)
				
			depGroups
		)
		
		---------------------------------------------------------------------------
		-- averigua cual de los dos elementos pasados está más cercano.
		---------------------------------------------------------------------------
		fn sortByHitDistance n1 n2 = if n1[3] < n2[3] then -1 else if n1[3] > n2[3] then 1 else 0
		----------------------------------------------------------------------------------------------------------------
		--------------------------------------------------- TOOLS ---------------------------------------------------
		----------------------------------------------------------------------------------------------------------------
			
		----------------------------------------------------------------------------------
		--Hace copias de asset o de objeto, haciendo place en el lugar pinchado
		----------------------------------------------------------------------------------
		tool toolPlaceCopies
		(
			local newNodes = #() 						--array donde ir almacenando los nuevos objetos copiados
			
			local placeCount = 0						--contador de copias por place
			local normalAlign = false					--flag para saber si hay que alinear las copias a la normal donde se ha hecho click
			local incrementalRot = false				--indica si la rotacion entre una copia  y otra es incremental
			
			local offsetPos = [0,0,0]					--offset de posicion
			local offsetRot = quat 0					--offset de rotacion
			local offsetScale = [1,1,1]				--offset de escala
			
			local varPos = [0,0,0]						--variacion de posicion
			local varRot = eulerangles 0 0 0			--variacion de rotacion positiva
			local varRotNeg = eulerangles 0 0 0	--variacion de rotacion negativa
			local varScale = [1,1,1]					--variacion de escala positiva
			local varScaleNeg = [1,1,1]				--variacion de escala negativa
			
			local varScaleLock = true					--indica si la variacion de escala es igual en los tres ejes
			
			local prevRot = quat 1						--rotacion previa de cada copia, necesario para hacer la roación incremental
			
			local copyMode = #copy					--modo de copia, #copy, #instance, #reference
			local sufix = ""								--sufijo que añadir a las copias
			
			local nodes = #()							--array de nodos que copiar
			local hierarchies = #()						--array de jerarquias obtenidas de los nodos que copiar
				
			--arrays de matrices de transformacion que habrá que aplicar a los objetos que se copiarán
			local auxHierarchyParent = undefined	--si hay que hacer las copias relativas, se necesita un padre auxiliar general que ir moviendo
			local auxHierarchyParents = #() --padres auxiliares de cada jerarquia para ir averiguando esas transformaciones
			
			local initPosition = [0,0,0] --posicion inicial del auxHierarchyParent
			local initRotation = quat 1 --rotacion inicial del auxHierarchyParent
			local initScale = [1,1,1] --escala inicial del auxHierarchyParent
			
			local initPositions = #() --array de posiciones iniciales de cada jerarquia
			local initRotations = #() --array de rotaciones iniciales de cada jerarquia
			local initScales = #() --array de escalas iniciales de cada jerarquia
			
			local copiesTransforms = #() --array de matrices de transformacion que habrá que aplicar a los objetos que se copiarán
			-----------------------------------------------------------------------------------------------------
			
			on mousePoint clickNumber do ----------------------------------------------
			(
				if clickNumber > 1 then -- Los click 1 y 2 se lanzan simultáneamente. Ignoramos el primero.
				(
					--Obtiene los valores de los offsets y las variaciones ---------------------------------------------------------------------------
					if clickNumber == 2 then --solo lo obtiene una vez
					(
						placeCount = 1
						normalAlign = parent.rollCopies.chkNormalAlign.checked and parent.rollCopies.chkAutoGrid.checked
								
						--Valores comunes 
						offsetPos = [spnOffsetPosX.value, spnOffsetPosY.value, spnOffsetPosZ.value]
						offsetRot = ((eulerangles -spnOffsetRotX.value -spnOffsetRotY.value -spnOffsetRotZ.value) as quat)
						offsetScale = [spnOffsetScaleX.value, spnOffsetScaleY.value, spnOffsetScaleZ.value]/100.0
						if offsetScale == [0,0,0] then offsetScale = [1,1,1]								
						incrementalRot = chkOffsetRotIncrementals.checked
						
						varPos = [0,0,0]
						varRot = eulerangles 0 0 0
						varRotNeg = eulerangles 0 0 0
						varScale = [1,1,1]
						varScaleNeg = [1,1,1]
						
						if chkVariationsEnable.checked then
						(
							varPos = [spnVariationPosX.value, spnVariationPosY.value, spnVariationPosZ.value]
							
							varRot = (eulerangles -spnVariationRotX.value -spnVariationRotY.value -spnVariationRotZ.value)
							varRotNeg = (eulerangles spnVariationRotX.value spnVariationRotY.value spnVariationRotZ.value)
							
							varScale = [(100 + spnVariationScaleX.value),(100 + spnVariationScaleY.value),(100 + spnVariationScaleZ.value)]/100.0
							varScaleNeg = [amax #(0,100 - spnVariationScaleX.value),amax #(0,100 - spnVariationScaleY.value),amax #(0,100 - spnVariationScaleZ.value)]/100.0
							
							varScaleLock = ckbVariationScaleLock.checked
						)
						
						copyMode = if rdoCopyOptions.state == 3 then #copy else if rdoCopyOptions.state == 1 then #instance else #reference
						sufix = edtSufix.text
						
						nodes = getCurrentSelection() --obtiene la seleccion actual
						hierarchies = lb.rig.getHierarchiesFromNodes nodes --obtiene las jerarquías de los objetos  seleccionados
						
						if hierarchies.count != 0 then
							seed (hierarchies[1][1].pivot.x + hierarchies[1][1].pivot.y + hierarchies[1][1].pivot.z)
						
						lb.assetManager.rollCopies.removeSceneEvents() --desactiva los callbacks de la herramienta deforma temporal
					)-- si es el primer click ------------------------------------------------------------------------------------------
					
					--crea los objetos auxiliares de los que va a coger las transformaciones para cada jerarquia
					--almacena tambien las transformaciones iniciales de cada jerarquia
					for h in hierarchies do
					(
						auxDummy = dummy pos:[0,0,0]
						append auxHierarchyParents auxDummy
						
						auxDummy.transform = h[1].transform
						append initPositions h[1].transform.pos
						append initRotations h[1].transform.rotation
						append initScales h[1].transform.scale
						
						append copiesTransforms #()
					)--for
					
					--si hay que hacer la copia por grupo, primero creamos una pieza auxiliar en la parte central
					--del bounding box general de todos los objetos, después emparentamos cada auxHierarchyParent
					--a dicha pieza para que sean una sola jerarquía y así copiarlos de una sola vez.
					---------------------------------------------------------------------------------------
					auxParent = undefined --pieza auxiliar a la que emparentar todas las jerarquías
					if chkByGroup.checked and hierarchies.count > 1 then
					(
						auxBB = lb.geometry.getNodesBoundingBox nodes (matrix3 1) --bounding box de los nodos seleccionados
						auxHierarchyParent = dummy pos:((auxBB[1] + auxBB[2])/2.0)
						
						initPosition = auxHierarchyParent.transform.pos
						initRotation = auxHierarchyParent.transform.rotation
						initScale = auxHierarchyParent.transform.scale
						
						for ah in auxHierarchyParents do ah.parent = auxHierarchyParent
					)
					
					copiesTransforms = #()
					---------------------------------------------------------------------------------------
					
					newPos = worldPoint --posicion del grid donde ha hecho click el raton
					newDir = [0,0,1] --direccion del grid donde se ha hecho click con el raton
					
					if chkAutogrid.checked then -----------------------------------------
					(
						clickRay = mapScreenToWorldRay mouse.pos
							
						try --lo metemos en un try ya que no logramos averiguar en que ocasiones salta (cuando hay un set por xrefScene)
						(
							collisionObjects = objects as array --almacenamos toda la geometria (incluidos huesos) de la escena (excepto los xrefScene objects que no los reconoce como tal)
								
							intersectedFound = #() --array de intersecciones encontradas
								
							for o in collisionObjects do --busca la interseccion del rayo con cada objeto
							(
								auxRay = intersectRay o clickRay --lanza la interseccion
								if auxRay != undefined do append intersectedFound (#(o, auxRay))
							)
									
							if intersectedFound.count != 0 do --si el rayo ha colisionado con algun objeto de la escena
							(
								auxItersected = for item in intersectedFound where not item[1].isHidden collect #(item[1], item[2], (distance clickRay.pos item[2].pos))
								qsort auxItersected sortByHitDistance
									
								newPos = auxItersected[1][2].pos
								newDir = auxItersected[1][2].dir
							)
						)
						catch (lb.message.show "Place couldn't be made on picked surface. It will be placed on the ground." type:#message pos:undefined size:[300,75] modal:true)
						
					)--if chkAutoGrid ----------------------------------------------------------
					
					-----------------------------------------------------------------------------------------------------------------
					--copia del asset u objeto seleccionado y su colocacion en el lugar pinchado con la orientación adecuada
						
					--si el modo de trabajo es por asset-------------
					if ckbAssetsBySelObjects.checked or chkOperateOnSelAssets.checked then
					(
						print "place de asset"
					)
					else if ckbOperateOnSelection.checked then --si el modo de trabajo es por objeto
					(
						with undo off
						(
							--ahora calculamos las matrices de transformacion de cada jerarquia, en funcion de los objetos axiliares creados para cada una de elloas
							if auxHierarchyParent != undefined then --si hay que hacerlo en grupo
							(
								--calculo de los offset y las variaciones de Posicion Rotacion y Escala-------------------------
								auxPos = newPos + offsetPos + (random -varPos varPos) --calcula la nueva posicion del asset
								
								tempRot = prevRot + offsetRot --calcula la rotacion nueva, que puede ser incremental respecto a la anterior o no
								randRot = ((random varRotNeg varRot) as quat)
								auxRot = initRotation + tempRot + randRot --calcula la nueva rotacion del asset
								if incrementalRot then prevRot = tempRot --si tiene que haber rotacion incremental
								
								randScale = (random varScale varScaleNeg)
								if varScaleLock then randScale = [randScale.x,randScale.x,randScale.x]
								auxScale = initScale*offsetScale*randScale --calcula la nueva escala del asset
								------------------------------------------------------------------------------------------------------
								
								--si hay que alinear a la normal las copias, alinea el auxHierarchyParent primero y luego aplicamos el resto de offsets y variaciones
								if normalAlign and newDir != [0,0,1] then
								(
									normalTransform = matrixFromNormal newDir
									auxHierarchyParent.transform = normalTransform
									
									--nueva rotacion, si hay que alinear a la normal, lo hace en local
									defRot = auxRot as eulerangles 
									in coordsys local rotate auxHierarchyParent defRot
								)
								else
								(
									--nueva rotacion, si no hay que alinear a la normal, se hace absoluta respecto al mundo
									defRot = (initRotation - auxHierarchyParent.transform.rotation - auxRot) as eulerangles
									rotate auxHierarchyParent defRot
								)
								
								--aplica la nueva posicion
								auxHierarchyParent.pos = auxPos
								
								--aplica la nueva escala a cada padre auxiliar de jerarquia,
								--y almacena la transformación de cada uno de ellos en un array
								--para aplicarla mas tarde a la copias
								for j=1 to auxHierarchyParents.count do
								(
									auxHierarchyParents[j].scale = auxScale
									append copiesTransforms auxHierarchyParents[j].transform
								)--for j
							)
							else --si hay que hacerlo individual para cada jerarquia-------------------------------
							(
								tempRot = prevRot + offsetRot --calcula la rotacion nueva, que puede ser incremental respecto a la anterior o no
								auxPos = newPos + offsetPos + (random -varPos varPos) --calcula la nueva posicion, es comun para todas las jerarquias
								
								for j=1 to auxHierarchyParents.count do
								(
									--calculo de los offset y las variaciones de Posicion Rotacion y Escala-------------------------
									randRot = ((random varRotNeg varRot) as quat)
									auxRot = initRotations[j] + tempRot + randRot --calcula la nueva rotacion del asset
										
									randScale = (random varScale varScaleNeg)
									if ckbVariationScaleLock.checked then randScale = [randScale.x,randScale.x,randScale.x]
									auxScale = initScales[j]*offsetScale*randScale --calcula la nueva escala del asset
									------------------------------------------------------------------------------------------------------
									
									--si hay que alinear a la normal las copias, alinea el auxHierarchyParent primero y luego aplicamos el resto de offsets y variaciones
									if normalAlign and newDir != [0,0,1] then
									(
										normalTransform = matrixFromNormal newDir
										auxHierarchyParents[j].transform = normalTransform
										
										--nueva rotacion, si hay que alinear a la normal, lo hace en local
										defRot = auxRot as eulerangles 
										in coordsys local rotate auxHierarchyParents[j] defRot
									)
									else
									(
										--nueva rotacion, si no hay que alinear a la normal, se hace absoluta respecto al mundo
										defRot = (initRotation - auxHierarchyParents[j].transform.rotation - auxRot) as eulerangles
										rotate auxHierarchyParents[j] defRot
									)
									
									--aplica la nueva posicion
									auxHierarchyParents[j].pos = auxPos
										
									--aplica la nueva escala
									auxHierarchyParents[j].scale = auxScale
										
									append copiesTransforms auxHierarchyParents[j].transform
								)--for j
								
								if incrementalRot then prevRot = tempRot --guarda la rotacion para que sea incremental
							)--------------------------------------------------------------------------------------
						
							placeCount += 1 --incrementa el contador de copias por place
							
							--Elimina los elementos auxiliares---------------------------------------------------------------
							if isValidnode auxHierarchyParent then (delete auxHierarchyParent; auxHierarchyParent = undefined)
							if auxHierarchyParents.count != 0 then (delete auxHierarchyParents; auxHierarchyParents = #())
							-----------------------------------------------------------------------------------------------------
						)--undo off
						
						undo "Place Copy Objects" on
						(
							stop = false --flag de parada
							
							--recorre las jerarquias haciendo tantas copies de cada una como se haya indicado
							for i=1 to hierarchies.count where not stop do
							(
								newNodes += lb.asset.copyObjects hierarchies[i] mode:copyMode sufix:sufix index:(placeCount as string) transform:copiesTransforms[i] --pos:newPos rot:newRot scale:newScale
								
								if keyboard.escPressed then stop = queryBox "Do you want to stop copy process?"
							)
							
			-- 							--*** Si no metemos el cambio de seleccion en el undo, deja podrido el undo personalizado que estamos haciendo ***--
			-- 							if newNodes.count != 0 then --si hay objetos nuevos, los selecciona
			-- 								select newNodes
							
						)--undo off
					)--if ckbOperateOnSelection
					-----------------------------------------------------
					
					--restaura los arrays de nodos seleccionados y de jerarquias-------------------------
			-- 					nodes = getCurrentSelection() --obtiene la seleccion actual
			-- 					hierarchies = lb.rig.getHierarchiesFromNodes nodes --obtiene las jerarquías de los objetos  seleccionados
					--------------------------------------------------------------------------------------------
					
					-----------------------------------------------------------------------------------------------------------------
					-----------------------------------------------------------------------------------------------------------------
				)--if clickNumber --------------------------------------------------------------
			)--on mousePoint -------------------------------------------------------------------
				
			on stop do --para de hacer place
			(
				--*** Si no metemos el cambio de seleccion en unl undo, deja podrido los undo personalizados de cada place que estamos haciendo ***--
				if newNodes.count != 0 then --si hay objetos nuevos, los selecciona
					undo "Select all new copies" on
						select newNodes
				
				completeRedraw() --redibujado completo
				lb.assetManager.rollMain.createSceneEvents() --reactiva los callbacks de la herramienta
				lb.assetManager.rollMain.removeSceneEvents()
				
				ckbStartCopy.checked = false
			)
		)

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollCopiesDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollCopiesDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				
			)--if
			------------------------------------------------------------------------------
		)

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--lb.xml.setAttribute parent.cfgFile ("rollExample1/cateagory") "paramName" "paramValue"
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--_param = (lb.xml.getAttribute parent.cfgFile ("rollExample1/category") "paramName") as <value type>
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		----------------------------------------------------------------------------------
		--actualiza el interface con los locks
		----------------------------------------------------------------------------------
		on ckbOffsetScaleLock changed state do
		(
			spnOffsetScaleY.value = spnOffsetScaleZ.value = spnOffsetScaleX.value
			
			spnOffsetScaleY.enabled = not state
			-- 			spnOffsetScaleY.visible = not state
			-- 			lblOffsetScaleYdisabled.visible = state
			
			spnOffsetScaleZ.enabled = not state
			-- 			spnOffsetScaleZ.visible = not state
			-- 			lblOffsetScaleZdisabled.visible = state
		)
		
		----------------------------------------------------------------------------------
		--resetea los valores de los spinners
		----------------------------------------------------------------------------------
		on btnOffsetReset pressed do
		(
			chkOffsetRotIncrementals.checked = true
			spnOffsetPosX.value = spnOffsetPosY.value = spnOffsetPosZ.value = 0
			spnOffsetRotX.value = spnOffsetRotY.value = spnOffsetRotZ.value = 0
			spnOffsetScaleX.value = spnOffsetScaleY.value = spnOffsetScaleZ.value = 100
		)
		
		----------------------------------------------------------------------------------
		--actualiza los valores de escala
		----------------------------------------------------------------------------------
		on spnOffsetScaleX changed val do
		(
			if val == 0.0 then val = 100
			if ckbOffsetScaleLock.checked then
				spnOffsetScaleX.value = spnOffsetScaleY.value = spnOffsetScaleZ.value = val
		)
		
		on spnOffsetScaleY changed val do
		(
			if val == 0.0 then
			(
				val = 100
				spnOffsetScaleY.value = val
			)
		)	
			
		on spnOffsetScaleZ changed val do
		(
			if val == 0.0 then
			(
				val = 100
				spnOffsetScaleZ.value = val
			)
		)

		----------------------------------------------------------------------------------
		--actualiza el interface con los locks
		----------------------------------------------------------------------------------
		on ckbVariationScaleLock changed state do
		(
			spnVariationScaleY.value = spnVariationScaleZ.value = spnVariationScaleX.value
			
			spnVariationScaleY.enabled = not state
			-- 			spnVariationScaleY.visible = not state
			-- 			lblVariationScaleYdisabled.visible = state
			
			spnVariationScaleZ.enabled = not state
			-- 			spnVariationScaleZ.visible = not state
			-- 			lblVariationScaleZdisabled.visible = state
		)
		
		----------------------------------------------------------------------------------
		--habilita o deshabilita las variaciones
		----------------------------------------------------------------------------------
		on chkVariationsEnable changed state do
		(
			lblVariationPos.enabled = state
			spnVariationPosX.enabled = state
			spnVariationPosY.enabled = state
			spnVariationPosZ.enabled = state
			
			lblVariationRot.enabled = state
			spnVariationRotX.enabled = state
			spnVariationRotY.enabled = state
			spnVariationRotZ.enabled = state
			
			lblVariationScale.enabled = state
			spnVariationScaleX.enabled = state
			spnVariationScaleY.enabled = state and not ckbVariationScaleLock.checked
			spnVariationScaleZ.enabled = state and not ckbVariationScaleLock.checked
			ckbVariationScaleLock.enabled = state
			
			btnVariationReset.enabled = state
		)
			
		----------------------------------------------------------------------------------
		--resetea los valores de los spinners
		----------------------------------------------------------------------------------
		on btnVariationReset pressed do
		(
			spnVariationPosX.value = spnVariationPosY.value = spnVariationPosZ.value = 0
			spnVariationRotX.value = spnVariationRotY.value = spnVariationRotZ.value = 0
			spnVariationScaleX.value = spnVariationScaleY.value = spnVariationScaleZ.value = 0
		)
		
		----------------------------------------------------------------------------------
		--actualiza los valores de escala
		----------------------------------------------------------------------------------
		on spnVariationScaleX changed val do
			if ckbVariationScaleLock.checked then
				spnVariationScaleY.value = spnVariationScaleZ.value = val		

		----------------------------------------------------------------------------------
		-- comienza la copia de assets u objetos
		----------------------------------------------------------------------------------
		on ckbStartCopy changed state do
		(
			if state then
			(
				max create mode
				
				--Valores comunes 
				--Obtiene los valores de los offsets y las variaciones ---------------------------------------------------------------------------
				offsetPos = [spnOffsetPosX.value, lb.assetManager.rollCopies.spnOffsetPosY.value, lb.assetManager.rollCopies.spnOffsetPosZ.value]
				offsetRot = ((eulerangles (-spnOffsetRotX.value) (-spnOffsetRotY.value) (-spnOffsetRotZ.value)) as quat)
				offsetScale = [ spnOffsetScaleX.value, spnOffsetScaleY.value, spnOffsetScaleZ.value]/100.0
				if offsetScale == [0,0,0] then offsetScale = [1,1,1]								
				incrementalRot =  chkOffsetRotIncrementals.checked
				
				varPos = [0,0,0]
				varRot = eulerangles 0 0 0
				varRotNeg = eulerangles 0 0 0
				varScale = [1,1,1]
				varScaleNeg = [1,1,1]
				
				varScaleLock =  ckbVariationScaleLock.checked
				
				if chkVariationsEnable.checked then
				(
					varPos = [spnVariationPosX.value, spnVariationPosY.value, spnVariationPosZ.value]
					
					varRot = (eulerangles -spnVariationRotX.value -spnVariationRotY.value -spnVariationRotZ.value)
					varRotNeg = (eulerangles spnVariationRotX.value spnVariationRotY.value spnVariationRotZ.value)
					
					varScale = [(100 + spnVariationScaleX.value),(100 + spnVariationScaleY.value),(100 + spnVariationScaleZ.value)]/100.0
					varScaleNeg = [amax #(0,100 - spnVariationScaleX.value),amax #(0,100 - spnVariationScaleY.value),amax #(0,100 - spnVariationScaleZ.value)]/100.0
				)
				------------------------------------------------------------------------------------------
				
				--segun el modo de copia seleccionado hay que entrar en el modo paint, place o make
				case rdoCopyModes.state of
				(
					1:--modo paint
					(
						print "paint"
					)--modo paint
					
					2:--modo place
					(
						proceed = true --flag para saber si empezar a hacer place
						
						--si es copia por objeto o por assets por objetos seleccionados debe haber algo seleccionado en la escena para poder trabajar.
						if (ckbOperateOnSelection.checked or ckbAssetsBySelObjects.checked) and selection.count == 0 then
						(
							proceed = false
							lb.message.show "You cannot copy without selecting objects." type:#message pos:undefined size:[300,75] modal:true
						)
						
						if proceed do startTool toolPlaceCopies prompt:"Coping objects: place mode"--inicia la tool de hacer copias
					)--modo place
					
					3:--modo make
					(
						--arrays de matrices de transformacion que habrá que aplicar a los objetos que se copiarán
						auxHierarchyParent = undefined	--si hay que hacer las copias relativas, se necesita un padre auxiliar general que ir moviendo
						auxHierarchyParents = #() --padres auxiliares de cada jerarquia para ir averiguando esas transformaciones
						
						initPosition = [0,0,0] --posicion inicial del auxHierarchyParent
						initRotation = quat 1 --rotacion inicial del auxHierarchyParent
						initScale = [1,1,1] --escala inicial del auxHierarchyParent
						
						initPositions = #() --array de posiciones iniciales de cada jerarquia
						initRotations = #() --array de rotaciones iniciales de cada jerarquia
						initScales = #() --array de escalas iniciales de cada jerarquia
						
						copiesTransforms = #() --arrays de matrices de transformacion que habrá que aplicar a los objetos que se copiarán
						-----------------------------------------------------------------------------------------------------
						
						lb.assetManager.rollMain.removeSceneEvents() --desactiva los callbacks de la herramienta deforma temporal
						setWaitCursor() --coloca el cursor de espera
						
						--si el modo de trabajo es por asset----------------------------------------------------------------
						if ckbAssetsBySelObjects.checked or chkOperateOnSelAssets.checked then
						(
							mode = if chkOperateOnSelAssets.checked then #fromSelAssets else if ckbAssetsBySelObjects.checked then #fromSelection else #none
							newAssets = #() --array donde almacenar los nuevos assets
							
							--devuelve los assets a copiar, en grupos de dependencia
							depGroups = getAssetsToCopy mode:mode dependents:lb.assetManager.rollMain.chkaffectDependentAssets.checked
							
							undo "Copy Assets" on
							--with undo off --realiza las operaciones sin almacenar undos
							(
								stop = false
								
								--recorre los grupos de dependencia haciendo la copia de los assets de cada uno de ellos
								for d in depGroups where not stop do
								( 	 
									setWaitCursor() --coloca el cursor de espera
									
									depAssets = for i=2 to d.count collect d[i]
									
									nodeRoot = lb.asset.getAssetRootNode d[1]
									
									astPos = lb.asset.getAssetPosition d[1] nodeRoot:nodeRoot --obtenemos la posicion del asset
									astRot = lb.asset.getAssetRotation d[1] nodeRoot:nodeRoot--obtenemos la rotación del asset
									astScale = lb.asset.getAssetScale d[1] nodeRoot:nodeRoot --obtenemos la escala del asset
									
									prevRot = quat 1 --rotacion previa de cada copia, necesario para hacer la roación incremental
									
									seed (if nodeRoot != undefined then (nodeRoot.pivot.x + nodeRoot.pivot.y + nodeRoot.pivot.z) else 12345)
									
									for i=1 to spnNumberCopies.value where not stop do --hace tantas copias como se hayan pedido
									(
										--calculo de los offset y las variaciones de Posicion Rotacion y Escala-------------------------
										newPos = astPos + (i*offsetPos) + (random -varPos varPos) --calcula la nueva posicion del asset
										
										auxRot = prevRot + offsetRot --calcula la rotacion nueva, que puede ser incremental respecto a la anterior o no
										randRot = ((random varRotNeg varRot) as quat)
										--if randRot == quat 1 then randRot = quat 0
										newRot = astRot + auxRot + randRot --calcula la nueva rotacion del asset
										if incrementalRot then prevRot = auxRot
										
										randScale = (random varScale varScaleNeg)
										if ckbVariationScaleLock.checked then randScale = [randScale.x,randScale.x,randScale.x]
										newScale = astScale*offsetScale*randScale --calcula la nueva escala del asset
										------------------------------------------------------------------------------------------------------
										
										newAssets += lb.asset.copyAsset d[1] dependentAssets:depAssets pos:newPos rot:newRot scale:newScale
										
										if keyboard.escPressed then stop = queryBox "Do you want to stop copy process?"
									)
								)--for
								
							)--undo off
							
							if newAssets.count != 0 then --si hay assets nuevos, los selecciona
							(
								clearSelection()
								for ast in newAssets do
								(
									rNode = lb.asset.getAssetRootNode ast
									if rNode != undefined then
										selectMore rNode
								)
							)
							
							if (lb.assetList != undefined) and (lb.assetList.rollMain != undefined) and lb.assetList.isOpen() then
							(
								lb.assetList.rollMain.updateControls()
								lb.assetList.rollMain.updateGridViewSelection()
							)
						)-------------------------------------------------------------------------------------------------------
						else if ckbOperateOnSelection.checked then --si el modo de trabajo es por objeto
						(
							copyMode = if rdoCopyOptions.state == 3 then #copy else if rdoCopyOptions.state == 1 then #instance else #reference
							sufix = edtSufix.text
							
							newNodes = #() --array donde ir almacenando los nuevos objetos copiados
							nodes = getCurrentSelection() --obtiene la seleccion actual
							
							hierarchies = lb.rig.getHierarchiesFromNodes nodes --obtiene las jerarquías de los objetos  seleccionados
							
							--------------------------------------------------------------------------------------
							with undo off --no almacena undos
							(
								--crea los objetos auxiliares de los que va a coger las transformaciones para cada jerarquia
								--almacena tambien las transformaciones iniciales de cada jerarquia
								for h in hierarchies do
								(
									auxDummy = dummy pos:[0,0,0]
									append auxHierarchyParents auxDummy
									
									auxDummy.transform = h[1].transform
									append initPositions h[1].transform.pos
									append initRotations h[1].transform.rotation
									append initScales h[1].transform.scale
									
									append copiesTransforms #()
								)--for
								
								--si hay que hacer la copia por grupo, primero creamos una pieza auxiliar en la parte central
								--del bounding box general de todos los objetos, después emparentamos cada auxHierarchyParent
								--a dicha pieza para que sean una sola jerarquía y así copiarlos de una sola vez.
								---------------------------------------------------------------------------------------
								auxParent = undefined --pieza auxiliar a la que emparentar todas las jerarquías
								if chkByGroup.checked and hierarchies.count > 1 then
								(
									auxBB = lb.geometry.getNodesBoundingBox nodes (matrix3 1) --bounding box de los nodos seleccionados
									auxHierarchyParent = dummy pos:((auxBB[1] + auxBB[2])/2.0)
									
									initPosition = auxHierarchyParent.transform.pos
									initRotation = auxHierarchyParent.transform.rotation
									initScale = auxHierarchyParent.transform.scale
									
									for ah in auxHierarchyParents do ah.parent = auxHierarchyParent
								)
								---------------------------------------------------------------------------------------
								
								--ahora calculamos las matrices de transformacion de cada jerarquia, en funcion de los objetos axiliares creados para cada una de elloas
								if auxHierarchyParent != undefined then --si hay que hacerlo en grupo
								(
									prevRot = quat 1 --rotacion previa de cada copia, necesario para hacer la roación incremental
									seed (auxHierarchyParent.pivot.x + auxHierarchyParent.pivot.y + auxHierarchyParent.pivot.z)
									
									for i=1 to spnNumberCopies.value do --calcula la nueva posicion, rotacion y escala para cada numero de copia
									(
										--calculo de los offset y las variaciones de Posicion Rotacion y Escala-------------------------
										newPos = initPosition + (i*offsetPos) + (random -varPos varPos) --calcula la nueva posicion del asset
										
										auxRot = prevRot + offsetRot --calcula la rotacion nueva, que puede ser incremental respecto a la anterior o no
										randRot = ((random varRotNeg varRot) as quat)
										newRot = initRotation + auxRot + randRot --calcula la nueva rotacion del asset
										if incrementalRot then prevRot = auxRot
										
										randScale = (random varScale varScaleNeg)
										if varScaleLock then randScale = [randScale.x,randScale.x,randScale.x]
										newScale = initScale*offsetScale*randScale --calcula la nueva escala del asset
										------------------------------------------------------------------------------------------------------
										
										--aplica la nueva posicion
										auxHierarchyParent.pos = newPos
										
										--aplica la nueva rotacion
										defRot = (initRotation - auxHierarchyParent.transform.rotation - newRot) as eulerangles
										rotate auxHierarchyParent defRot
										
										--aplica la nueva escala a cada padre auxiliar de jerarquia,
										--y almacena la transformación de cada uno de ellos en un array
										--para aplicarla mas tarde a la copias
										for j=1 to auxHierarchyParents.count do
										(
											auxHierarchyParents[j].scale = newScale
											append copiesTransforms[j] auxHierarchyParents[j].transform
										)--for j
									)--for i
								)
								else --si hay que hacerlo individual para cada jerarquia-------------------------------
								(
									for j=1 to auxHierarchyParents.count do
									(
										prevRot = quat 1 --rotacion previa de cada copia, necesario para hacer la roación incremental
										seed (auxHierarchyParents[j].pivot.x + auxHierarchyParents[j].pivot.y + auxHierarchyParents[j].pivot.z)
										
										for i=1 to spnNumberCopies.value do --calcula la nueva posicion, rotacion y escala para cada numero de copia
										(
											--calculo de los offset y las variaciones de Posicion Rotacion y Escala-------------------------
											newPos = initPositions[j] + (i*offsetPos) + (random -varPos varPos) --calcula la nueva posicion del asset
											
											auxRot = prevRot + offsetRot --calcula la rotacion nueva, que puede ser incremental respecto a la anterior o no
											randRot = ((random varRotNeg varRot) as quat)
											newRot = initRotations[j] + auxRot + randRot --calcula la nueva rotacion del asset
											if incrementalRot then prevRot = auxRot
											
											randScale = (random varScale varScaleNeg)
											if ckbVariationScaleLock.checked then randScale = [randScale.x,randScale.x,randScale.x]
											newScale = initScales[j]*offsetScale*randScale --calcula la nueva escala del asset
											------------------------------------------------------------------------------------------------------
											
											--aplica la nueva posicion
											auxHierarchyParents[j].pos = newPos
											
											--aplica la nueva rotacion
											defRot = (initRotations[j] - auxHierarchyParents[j].transform.rotation - newRot) as eulerangles
											rotate auxHierarchyParents[j] defRot
											
											--aplica la nueva escala
											auxHierarchyParents[j].scale = newScale
											
											--almacena las transformaciones del auxHierarchyParents[j] para esa copia
											append copiesTransforms[j] auxHierarchyParents[j].transform
										)--for i	
									)--for j										
								)--------------------------------------------------------------------------------------
								
								delete auxHierarchyParents
								if auxHierarchyParent != undefined do delete auxHierarchyParent
							)--undo off
							--------------------------------------------------------------------------------------
							
							--------------------------------------------------------------------------------------
							undo "Copy Objects" on
							(
								stop = false --flag de parada
								
								--recorre las jerarquias haciendo tantas copies de cada una como se haya indicado
								for i=1 to hierarchies.count where not stop do
								(
									copyLimit = spnNumberCopies.value
									digitNumber = (copyLimit as string).count
									
									--hace tantas copias como se hayan pedido
									for j=1 to copyLimit where not stop do
									(
										newIndex = j as string
										while newIndex.count < digitNumber do newIndex = "0" + newIndex
										
										--realiza la copia
										newNodes += lb.asset.copyObjects hierarchies[i] mode:copyMode sufix:sufix index:newIndex transform:copiesTransforms[i][j] --pos:newPos rot:newRot scale:newScale
										
										if keyboard.escPressed then stop = queryBox "Do you want to stop copy process?"
									)
								)
								
								--*** Si no metemos el cambio de seleccion en el undo, deja podrido el undo personalizado que estamos haciendo ***--
								if newNodes.count != 0 then --si hay objetos nuevos, los selecciona
									select newNodes
							)--undo on
							
						)						
						--------------------------------------------------------------------------------------------------------
						
						completeRedraw() --redibujado completo
						setArrowCursor() --coloca el cursor en modo flecha
						
						lb.assetManager.rollMain.createSceneEvents()
						lb.assetManager.rollMain.removeSceneEvents()

						
					)--modo make
					
				)--case rdoCopyModes
				
				--al final de la copia resetea el estado del boton
				ckbStartCopy.checked = false
			)
			else
			(
				stopTool toolPlaceCopies
			)
		)
		
		----------------------------------------------------------------------------------
		--cambia las opciones en funcion de los checkbuttons inciales, para elegir con que assets trabaja
		----------------------------------------------------------------------------------
		on chkOperateOnSelAssets changed state do
		(
			if state then
			(
				ckbOperateOnSelection.checked = ckbAssetsBySelObjects.checked = false
				
				--si no esta en modo selObjs entonces hay que ocultar las opciones de copia por referencia, instancia o copia normal.
				if rdoCopyOptions.enabled then lastCopyOption = rdoCopyOptions.state
				rdoCopyOptions.enabled = false
				rdoCopyOptions.state = 3
				------------------------------------------------------------------------------------------------
			)
			else
				chkOperateOnSelAssets.checked = true
			
			-- 			chkDependents.enabled = chkOperateOnSelAssets.checked
		)
				
		on ckbAssetsBySelObjects changed state do
		(
			if state then
			(
				ckbOperateOnSelection.checked = chkOperateOnSelAssets.checked = false
				
				--si no esta en modo selObjs entonces hay que ocultar las opciones de copia por referencia, instancia o copia normal.
				if rdoCopyOptions.enabled then lastCopyOption = rdoCopyOptions.state
				rdoCopyOptions.enabled = false
				rdoCopyOptions.state = 3
				------------------------------------------------------------------------------------------------
			)
			else
				ckbAssetsBySelObjects.checked = true
			
			-- 			chkDependents.enabled = not chkOperateOnSelAssets.checked
		)
		
		on ckbOperateOnSelection changed state do
		(
			if state then
			(
				chkOperateOnSelAssets.checked = ckbAssetsBySelObjects.checked = false
				
				--si esta en modo selObjs entonces hay que mostar las opciones de copia por referencia, instancia o copia normal.
				rdoCopyOptions.enabled = true
				rdoCopyOptions.state = lastCopyOption
				------------------------------------------------------------------------------------------------
			)
			else
				ckbOperateOnSelection.checked = true
			
			-- 			chkDependents.enabled = chkOperateOnSelAssets.checked
		)
		
		----------------------------------------------------------------------------------
		--cambios en los botones de settings
		----------------------------------------------------------------------------------
		on ckbOffsets changed state do
		(
			if state then
			(
				updateUI()
			)
			else
				ckbOffsets.state = true
		)
		
		on ckbVariations changed state do
		(
			if state then
			(
				updateUI()
			)
			else
				ckbVariations.state = true
		)
		
		on ckbBrush changed state do
		(
			if state then
			(
				updateUI()
			)
			else
				ckbBrush.state = true
		)
		
		on ckbPivot changed state do
		(
			if state then
			(
				updateUI()
			)
			else
				ckbPivot.state = true
		)

		----------------------------------------------------------------------------------
		--actualizacion de interface en funcion del modo de copia	
		----------------------------------------------------------------------------------
		on rdoCopyModes changed state do
		(		
			ckbStartCopy.enabled = not (state == 1)
			updateUI()
		)
		
		----------------------------------------------------------------------------------
		--actualizacion de interface cuando se pulsa el check de autogrid
		----------------------------------------------------------------------------------
		on chkAutogrid changed state do
			updateUI()

		on rollCopiesDef rolledUp state do 
		(
			parent.heightAdjust 4
		)

		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollCopiesDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCopiesDef open do
		(
			loadSettings()
			createSceneEvents() --crea los callbacks

			updateUI()

			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollCopiesDef close do
		(
			removeSceneEvents() --elimina los callbacks
			saveSettings()
		)
	)--rollCopiesDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollMainDef | Contiene el listado de overrides permitidos.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollMainDef "Asset Manager"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual
		
		local minRollWidth = 220	--@var: minRollWidth | Minimun tool width.
		local minRollHeight = 192	--@var: minRollHeight | Minimun tool height.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		local opening = false --@var: opening | Flag para que no salte el evento de cambio de tab y no pise el valor cargado del archivo .cfg
		local iconpath = if (maxVersion())[1] >= 15000 then (getDir #maxRoot) + "UI_ln\\Icons\\" else (getDir #ui) + "/icons/"		-- ruta de los iconos de Max.
		local rMenu = dotnetobject "System.Windows.Forms.ContextMenuStrip" --pos:[115,265] width:40 height:14 visible:false-- menu botón derecho ratón
		local menuAssetList = dotnetobject "System.Windows.Forms.ContextMenuStrip" --pos:[115,265] width:40 height:14 visible:false

		local _projectUnit = "z:\\"
		local _assetOffset = 0			--	Solo hay 6 botones para representar los Assets de la escena. _assetOffset indica si
		local numObjects = undefined --numero de objetos de la escena
		
		--colors------------------------------------------------------------------------------
		local backColor = (dotNetClass "System.Drawing.Color").beige		-- fondo del listado
		local meshColor = (dotNetClass "System.Drawing.Color").fromargb 200 190 105		-- layers Mesh
		local hiddenColor = (dotNetClass "System.Drawing.Color").fromargb 100 100 100	-- layers Hidden
		local animColor = (dotNetClass "System.Drawing.Color").fromargb 160 190 100		-- layers Anim
		local fxColor = (dotNetClass "System.Drawing.Color").blue									-- layers FX
		
		local beige = (color 245 245 220)															--color beige
		
		local dgBackColor = (dotNetClass "System.Drawing.Color").beige					-- fondo
		local dgForeColor = (dotNetClass "System.Drawing.Color").gray					-- texto
		local dgSelBackColor = (dotNetClass "System.Drawing.Color").black	-- fondo de items seleccionados
		local dgSelForeColor = (dotNetClass "System.Drawing.Color").white				-- texto de items seleccionados

		local showLayers = true			-- Indica si se están mostrando o no los controles de layers
			
		local updateAvailable = false	--flag para saber si se puede actualizar el listado de layers
		
		local clipboardObj = dotNetClass "System.Windows.Forms.Clipboard"  -- crea un clipboard de puntonet	

		local affectedRollouts = #()

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------

		dotNetControl tbTabs "DevExpress.XtraTab.XtraTabControl" pos:[0,320] width:350 height:21 --25

		-- Controles de dotNet
		dotNetControl dgAssetIcons "System.Windows.Forms.DataGridView" pos:[5,25] width:200 height:25
		dotNetControl dgAssetIconsHscroll "System.Windows.Forms.HScrollBar" pos:[5,50] width:200 height:10

		timer tmClock interval:500 active:true
		
		label lblSeparator01 "|" pos:[40,5] enabled:false
		label lblSeparator02 "|" pos:[85,5] enabled:false
		
		button btnAddAsset "+" pos:[0,0] width:20 height:24 images:#(iconpath + "parameterCollector_i.bmp", undefined, 28, 7, 7, 7, 7,true) border:false toolTip:"Add asset"	
		button btnDeleteAsset "X" pos:[20,0] width:20 height:24 images:#(iconpath + "MeditTools_i.bmp", undefined, 44, 7, 7, 8, 8,true) border:false toolTip:"Remove asset"	
		
		checkbutton ckbAssetList "list" pos:[44,0] width:23 height:24 images:#(iconsPath + "displayIcons001_24i.bmp", undefined, 50, 1,1,1,1,false) border:false toolTip:"Shows complete asset list"
		button btnAssetsFromNodes "get" pos:[63,0] width:23 height:24 images:#(iconsPath + "displayIcons001_24i.bmp", undefined, 50, 4,4,4,4,false) border:false toolTip:"obtains assets from selected nodes, and select then in the list"
		
		checkbutton ckb_CHRs "chr" pos:[90,3] width:20 height:20 highlightcolor:(lb.asset.chrAssetColor) images:#(iconsPath + "displayIcons001_24i.bmp", undefined, 50, 5,5,5,5,false) border:false tooltip:"Filter Character assets" checked:true
		checkbutton ckb_PRPs "prp" pos:[110,3] width:20 height:20 highlightcolor:(lb.asset.prpAssetColor) images:#(iconsPath + "displayIcons001_24i.bmp", undefined, 50, 6,6,6,6,false) border:false tooltip:"Filter Prop assets" checked:true
		checkbutton ckb_SPRs "spr" pos:[130,3] width:20 height:20 highlightcolor:(lb.asset.sprAssetColor) images:#(iconsPath + "displayIcons001_24i.bmp", undefined, 50, 7,7,7,7,false) border:false tooltip:"Filter SetProp assets" checked:true
		checkbutton ckb_SETs "set" pos:[150,3] width:20 height:20 highlightcolor:(lb.asset.setAssetColor) images:#(iconsPath + "displayIcons001_24i.bmp", undefined, 50, 8,8,8,8,false) border:false tooltip:"Filter Set assets" checked:true
		checkbutton ckb_LITs "lit" pos:[170,3] width:20 height:20 highlightcolor:(lb.asset.litAssetColor) images:#(iconsPath + "displayIcons001_24i.bmp", undefined, 50, 10,10,10,10,false) border:false tooltip:"Filter Light assets" checked:true
		checkbutton ckb_FXs "fx" pos:[190,3] width:20 height:20 highlightcolor:(lb.asset.fxAssetColor) images:#(iconsPath + "displayIcons001_24i.bmp", undefined, 50, 9,9,9,9,false) border:false tooltip:"Filter FX assets" checked:true

		groupBox grpAffects "" pos:[5,58] width:202 height:66
		groupBox grpConnection "" pos:[104,58] width:103 height:66
		
		button btnHide "hide" pos:[6,65] width:25 height:20 toolTip:"Hide current asset" 
		button btnShow "show" pos:[31,65] width:25 height:20 toolTip:"Shows current asset if it's not visible"
		button btnUnhideAll "all" pos:[56,65] width:20 height:20 toolTip:"Unhide all assets"
		button btnSolo "solo" pos:[76,65] width:25 height:20 toolTip:"Hide all assets except selected"
		
		button btnConnection "Con" pos:[105,65] width:24 height:20 toolTip:"Connect/Disconnect Rig"
		
		button btnVMpuppet "P" pos:[134,65] width:13 height:20 toolTip:"Puppet Mode"
		button btnVMpuppetHead "PH" pos:[147,65] width:17 height:20 toolTip:"Puppet + Head Mode"
		button btnVMhead "H" pos:[164,65] width:13 height:20 toolTip:"Head Mode"
		button btnVMskin "S" pos:[177,65] width:13 height:20 toolTip:"Skin Mode"
		button btnVMskinBox "SB" pos:[190,65] width:17 height:20 toolTip:"Skin + Box Mode"
		
		checkbox chkaffectAllAssets "all assets" pos:[10,90] toolTip:"affect all assets"
		checkbox chkaffectDependentAssets "dependents" pos:[10,107] checked:true toolTip:"affect dependent assets"
		
		checkbox chkaffectFFDs "FFDs" pos:[110,90] checked:true toolTip:"Disable FFDs in HEAD and PUPPET+HEAD mode"
		checkbox chkaffectHair "Hair" pos:[160,90] checked:true toolTip:"Hide HAIR and disable HAIR SKIN in HEAD and PUPPET+HEAD mode"
		checkbox chkDisSecPuppets "SP" pos:[110,107] checked:true toolTip:"Enable/Disable Secondary Puppets in HEAD ans PUPPET+HEAD mode"
		checkbox chkShowExtraControls "EC" pos:[160,107] width:43 height:15 checked:true toolTip:"Show/Hide extra animation controls in SKIN+BOX Mode"

		------------------------------------------------------------------------------------------------
		--SUBROLLOUTS
		------------------------------------------------------------------------------------------------

		subrollout subRollAdvanced "subRollAdvanced" pos:[0,140] width:minRollWidth height:175 --@control | subRollContainer | SubRollouts container.
		subrollout subRollContainer "subRollouts" pos:[0,341] width:minRollWidth height:0 --@control | subRollContainer | SubRollouts container.

		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		---------------------------------------------------------------------------
		--inicializa el gridview
		---------------------------------------------------------------------------
		fn initIconsDG =
		(
			dgAssetIcons.rows.clear()
			dgAssetIcons.columns.clear()
			
			dgAssetIcons.allowUsertoaddRows = false
			dgAssetIcons.allowUserToResizeRows = false
			dgAssetIcons.allowUserToResizeColumns = false
			
			dgAssetIcons.ColumnHeadersVisible = false	--para que las colunas no tengan titulo
			dgAssetIcons.rowheadersvisible = false		--para que las filas no tengan titulo
			
			dgAssetIcons.foreColor = (dotNetClass "System.Drawing.Color").black
			dgAssetIcons.backgroundcolor = dgForeColor									-- color del fondo
			--dgAssetIcons.rowsdefaultcellstyle.backcolor = dgForeColor				-- color por defecto de las celdas
			dgAssetIcons.GridColor = dgForeColor
			
			dgAssetIcons.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 7.5					
			
			rollMainDef.dgAssetIcons.scrollBars = (dotNetClass "System.Windows.Forms.ScrollBars").none --hace que no tenga scroll
			
			dgAssetIcons.readonly = true
		)

		---------------------------------------------------------------------------
		--rellena el gridView de iconos
		---------------------------------------------------------------------------
		fn fillIconsDG =
		(
			_cellWidth = _cellHeight = 25
			dgAssetIcons.rows.clear() --limpia las filas
			dgAssetIcons.columns.clear() --limpia las columnas

			--recorre los assets que pasan los filtros para mostrarlos en el listado
			if lb.asset.listedAssets != undefined then --si la variable no esta indefinida
			(
				if lb.asset.listedAssets.count <= 8 then
				(
					dgAssetIconsHscroll.enabled = false
				)
				else
				(
					dgAssetIconsHscroll.enabled = true
					_large = (100 - (lb.asset.listedAssets.count - 8)*25)
					dgAssetIconsHscroll.LargeChange = if _large < 10 then 10 else _large
					dgAssetIconsHscroll.SmallChange = 25
				)
				
				for i=1 to lb.asset.listedAssets.count do
				(
					icon = lb.asset.getAssetIconFiles lb.asset.listedAssets[i] --obtiene los iconos del asset
					
					if icon.count != 0 then
					(
						dgAssetIcons.columns.add (dotnetobject "System.Windows.Forms.DataGridViewImageColumn")
					)

					else
						dgAssetIcons.columns.add (dotnetobject "System.Windows.Forms.DataGridViewTextBoxColumn")
					
					dgAssetIcons.columns.item[dgAssetIcons.columns.count - 1].ToolTipText = lb.asset.listedAssets[i].fullname
					dgAssetIcons.columns.item[dgAssetIcons.columns.count - 1].width = _cellWidth
				)--for
			)
			
			if dgAssetIcons.columns.count > 0 then
			(
				row = (dotnetobject "System.Windows.Forms.DataGridViewRow")
				row.height = _cellWidth
				dgAssetIcons.rows.add row --añade la fila
			)
			
			if dgAssetIcons.rows.count == 1 then --si ha conseguido añadir la fila
			(
				for i=1 to lb.asset.listedAssets.count do
				(
					--elige el color de fondo de la linea
					colDotnetColor = dgBackColor
					colColor = dgBackColor
					case lb.asset.listedAssets[i].type of
					(
						(lb.nc.NC_chrPrefix):
						(
							colDotnetColor = (dotNetClass "System.Drawing.Color").fromargb lb.asset.chrAssetColor.x lb.asset.chrAssetColor.y lb.asset.chrAssetColor.z
							colColor = lb.asset.chrAssetColor as color
						)
						
						(lb.nc.NC_prpPrefix):
						(
							colDotnetColor = (dotNetClass "System.Drawing.Color").fromargb lb.asset.prpAssetColor.x lb.asset.prpAssetColor.y lb.asset.prpAssetColor.z
							colColor = lb.asset.prpAssetColor as color
						)
						
						(lb.nc.NC_sprPrefix):
						(
							colDotnetColor = (dotNetClass "System.Drawing.Color").fromargb lb.asset.sprAssetColor.x lb.asset.sprAssetColor.y lb.asset.sprAssetColor.z
							colColor = lb.asset.sprAssetColor as color
						)
						
						(lb.nc.NC_setPrefix):
						(
							colDotnetColor = (dotNetClass "System.Drawing.Color").fromargb lb.asset.setAssetColor.x lb.asset.setAssetColor.y lb.asset.setAssetColor.z
							colColor = lb.asset.setAssetColor as color
						)
						
						(lb.nc.NC_litPrefix):
						(
							colDotnetColor = (dotNetClass "System.Drawing.Color").fromargb lb.asset.litAssetColor.x lb.asset.litAssetColor.y lb.asset.litAssetColor.z
							colColor = lb.asset.litAssetColor as color
						)
						
						(lb.nc.NC_fxPrefix):
						(
							colDotnetColor = (dotNetClass "System.Drawing.Color").fromargb lb.asset.fxAssetColor.x lb.asset.fxAssetColor.y lb.asset.fxAssetColor.z
							colColor = lb.asset.fxAssetColor as color
						)
					)--case
					
					dgAssetIcons.columns.item[i-1].defaultCellStyle.BackColor = colDotnetColor
					
					_icon = lb.asset.getAssetIcon lb.asset.listedAssets[i] --obtiene los iconos del asset
					
					if _icon != undefined then
					(
						(dgAssetIcons.item (i-1) 0).ToolTipText = lb.asset.listedAssets[i].fullname
						(dgAssetIcons.item (i-1) 0).value = _icon
					)
					else --no hay icono
					(
						(dgAssetIcons.item (i-1) 0).ToolTipText = lb.asset.listedAssets[i].fullname
						(dgAssetIcons.item (i-1) 0).value = substring lb.asset.listedAssets[i].name 1 3
					)
				)--for
				
				if dgAssetIcons.columns.count != 0 and lb.asset.selAssets.count == 0 then
					(dgAssetIcons.item 0 0).selected = false
			)
		)
		

		----------------------------------------------------------------------------------
		-- inicia las variables CHKs_V, CHKs_F y selLayerBtns
		----------------------------------------------------------------------------------
		fn initControlsVariables =
		(
			CHKs_V = #()	
			CHKs_F = #()
			selLayerBtns = #()
			
			for c in rollMainDef.controls do
			(
				if (findstring c.name "chk" != undefined) then
				(
					if (findstring c.name "_V" != undefined) then append CHKs_V c
					if (findstring c.name "_F" != undefined) then append CHKs_F c
				)
				if (findstring c.name "btnSel_" != undefined) then append selLayerBtns c
			)
		)

		----------------------------------------------------------------------------------
		--	selecciona en el interface un Asset por su nombre
		----------------------------------------------------------------------------------
		fn selectAssetByName assetName =	
		(
			assetNum = lb.asset.findAssetByName lb.asset.listedAssets assetName
			if assetNum != 0 then 
			(
				if (assetNum > _assetOffset + 7) or (assetNum <= _assetOffset - 7) then
				(
					_assetOffset = assetNum - 7 
					if _assetOffset < 0 then _assetOffset = 0
				)
				--selAsset = assetNum
				lb.asset.selAssets = #(assetNum)
			)
			else
			(
				--selAsset = 0
				lb.asset.selAssets = #()
			)
			
			rollMainDef.refreshControls()
		)



		----------------------------------------------------------------------------------
		--actualiza el listado de layers
		----------------------------------------------------------------------------------
		fn updateLayerControls =
		(
			updateAvailable = true
		)

		-----------------------------------------------------------------------------
		--actualiza las variables de assets seleccionados
		-----------------------------------------------------------------------------
		fn setSelectedAssets pressed newSelectedIndex ctrlPressed:"false" =
		(
			if pressed then --si se ha presionado
			(
				if ctrlPressed then
				(
					appendIfUnique lb.asset.selAssets (newSelectedIndex + _assetOffset)
				)
				else
				(
					--selAsset = newSelectedIndex + _assetOffset
					lb.asset.selAssets = #((newSelectedIndex + _assetOffset))
				)
			)
			else if ctrlPressed and lb.asset.selAssets.count > 1 then --si se esta soltando con control
			(
				index = findItem lb.asset.selAssets (newSelectedIndex + _assetOffset)
				if index != 0 then
				(
					deleteItem lb.asset.selAssets index
					--selAsset = selAssets[1]
				)
			)
			else --si se esta volviendo a pulsar solo uno de los assets ya seleccionados
			(
				--selAsset = newSelectedIndex + _assetOffset
				lb.asset.selAssets = #((newSelectedIndex + _assetOffset))
			)
			
			sort lb.asset.selAssets
			
			-- 			btnLeft.enabled = (selAssets[1] > 1)
			-- 			btnRight.enabled = (selAssets[selAssets.count] < lb.asset.listedAssets.count)
		)

		----------------------------------------------------------------------------------
		-- actualiza el listado de assets con los seleccionados
		----------------------------------------------------------------------------------
		fn updateDGassetIconsSelection =
		(
			for i=1 to lb.asset.listedAssets.count do
				(dgAssetIcons.item (i - 1) 0).selected = (findItem lb.asset.selAssets i != 0)	
		)

		----------------------------------------------------------------------------------
		--	actualiza el estado de los controles del rollout
		----------------------------------------------------------------------------------
		fn updateRollMainControls =
		(
			chrModes = #("P", "P+H", "H", "S", "S+B")
			chrWithNoMeshModes = #("P")
			chrWithNoFacialModes = #("P", "S", "S+B")
			prpModes = #("P", "S", "S+B")
			sprModes = #("P", "S", "S+B")
			setAnimModes = #("P", "S", "S+B")
			setModes = #("S")
			fxModes = #("S","S+B")
			
			selAssetsTypes = #()
			hasPuppets = false
			
			for index in lb.asset.selAssets do --tipos de assets seleccionados
			(
				case lb.asset.listedAssets[index].type of
				(
					"chr":
					(
						if lb.asset.listedAssets[index].meshNodesAll.count == 0 then appendIfUnique selAssetsTypes "chrNoMesh"
						else if lb.asset.listedAssets[index].facialNodesAll.count == 0 then appendIfUnique selAssetsTypes "chrNoFacial"
						else appendIfUnique selAssetsTypes "chr"
					)
					
					"set":
					(
						if lb.asset.listedAssets[index].animNodesAll.count != 0 then appendIfUnique selAssetsTypes "setAnim"
						else appendIfUnique selAssetsTypes "set"
					)
					
					default:
					(
						appendIfUnique selAssetsTypes lb.asset.listedAssets[index].type
					)
				)--case
				
				if lb.asset.listedAssets[index].type != "chr" then
					appendIfUnique selAssetsTypes lb.asset.listedAssets[index].type
				else
				(
					if lb.asset.listedAssets[index].meshNodesAll.count == 0 then
						appendIfUnique selAssetsTypes "chrNoMesh"
					else if lb.asset.listedAssets[index].facialNodesAll.count == 0 then
						appendIfUnique selAssetsTypes "chrNoFacial"
					else
						appendIfUnique selAssetsTypes "chr"
				)--if else
				
				if lb.asset.listedAssets[index].hasPuppets then hasPuppets = true
			)--for
			
			modesToEnable = #()
						
			if findItem selAssetsTypes "chr" != 0 do modesToEnable += chrModes
			if findItem selAssetsTypes "chrNoMesh" != 0 do modesToEnable += chrWithNoMeshModes
			if findItem selAssetsTypes "chrNoFacial" != 0 do modesToEnable += chrWithNoFacialModes
			if findItem selAssetsTypes "prp" != 0 do modesToEnable += prpModes
			if findItem selAssetsTypes "spr" != 0 do modesToEnable += sprModes
			if findItem selAssetsTypes "set" != 0 do modesToEnable += setModes
			if findItem selAssetsTypes "setAnim" != 0 do modesToEnable += setAnimModes
			if findItem selAssetsTypes "fx" != 0 do modesToEnable += fxModes
				
			modesToEnable = makeUniqueArray modesToEnable
			
			btnVMpuppet.enabled = (findItem modesToEnable "P" != 0) and (hasPuppets or (findItem selAssetsTypes "chr" != 0))
			btnVMpuppetHead.enabled = (findItem modesToEnable "P+H" != 0) and (hasPuppets or (findItem selAssetsTypes "chr" != 0))
			btnVMhead.enabled = (findItem modesToEnable "H" != 0)	
			btnVMskin.enabled = (findItem modesToEnable "S" != 0)	
			btnVMskinBox.enabled = (findItem modesToEnable "S+B" != 0)
			
			chkaffectFFDs.enabled = btnVMhead.enabled or btnVMpuppetHead.enabled
			chkaffectHair.enabled = btnVMhead.enabled or btnVMpuppetHead.enabled
			chkDisSecPuppets.enabled = btnVMpuppet.enabled or btnVMpuppetHead.enabled
			
			
			--	calculamos el estado del tick chkShowExtraControls en función de la visibilidad
			--	de los controles de animación extra.
			animExtraNodes = #()
			
			for a in (lb.assetManager.getSelectedAssets()) do
				join animExtraNodes (lb.asset.getAssetNodesByType a #(lb.nc.NC_classAnim, lb.nc.NC_classFacial) flags:#(lb.nc.NC_controlFlag,lb.nc.NC_extraFlag))
			
			/*--ESTO SE HA QUITADO PORQUE SE FUERZA QUE ESTE ACTIVO SEGUN EL MODO DE VISUALIZACION
			--	solo habilitamos el tick si alguno de los assets seleccionados tiene controles de animación extra
			chkShowExtraControls.enabled = btnVMskinBox.enabled and (animExtraNodes.count > 0)
			
			if chkShowExtraControls.enabled then
			(				
				if animExtraNodes.count > 0 then
				(
					chkShowExtraControls.checked = not animExtraNodes[1].isHidden
					for o in animExtraNodes where (chkShowExtraControls.checked != (not o.isHidden)) do 
						chkShowExtraControls.tristate = 2
				)					
			)
			else
				chkShowExtraControls.checked = false
			*/
		)

		----------------------------------------------------------------------------------
		-- actualiza el estado de los controles para el manejo de los Assets
		----------------------------------------------------------------------------------
		fn refreshControls updateLayers:true =
		(
			updateDGassetIconsSelection()						-- actualiza el listado de assets con los seleccionadoso
 			if updateLayers then lb.assetManager.rollAdvanced.fillLayerControls()			-- rellenamos todos los controles para el Asset seleccionado.
			updateRollMainControls()										-- actualiza el setado de habilitado o no de los controles de modos de visualizacion de assets
			try rollMiscDef.updateMiscControls() catch()		--Actualizamos los controles del rollout de miscellaneous con un try por si está cerrado.
			
			if lb.assetList != undefined and lb.assetList.isOpen() then
				lb.assetList.rollMain.updateGridViewSelection()
		)

		----------------------------------------------------------------------------------
		-- reinicia el listado de Assets
		----------------------------------------------------------------------------------
		fn resetSceneAssets = 
		(
			--limpia las variables antes de nada
			lb.asset.sceneAssets = #()	
			lb.asset.listedAssets = #()
			lb.asset.selAssets = #()
			lb.asset.selAsset = undefined
			lb.asset.assetFilters = #()

			--Miramos la ruta del archivo y rellenamos la variable de la unidad.
			if maxFilePath != "" then _projectUnit = (filterString maxFilePath "\\")[1] + "\\"
			else _projectUnit = "z:\\"

			if lb.asset.selAssets == undefined then lb.asset.selAssets = #()
			if lb.asset.listedAssets == undefined then lb.asset.listedAssets = #()
			if lb.asset.selAssets.count != 0 then selAssetName = lb.asset.listedAssets[lb.asset.selAssets[1]].fullName
			--selAsset = 0
			
			_assetOffset = 0
			lb.asset.sceneAssets = lb.asset.getSceneAssets()										-- miramos qué Assets hay en la escena
			
			-- rellenamos el array de filtros de assets
			if ckb_CHRs.checked then append lb.asset.assetFilters lb.nc.NC_chrPrefix
			if ckb_PRPs.checked then append lb.asset.assetFilters lb.nc.NC_prpPrefix
			if ckb_SPRs.checked then append lb.asset.assetFilters lb.nc.NC_sprPrefix
			if ckb_SETs.checked then append lb.asset.assetFilters lb.nc.NC_setPrefix
			if ckb_FXs.checked then append lb.asset.assetFilters lb.nc.NC_fxPrefix
			if ckb_LITs.checked then append lb.asset.assetFilters lb.nc.NC_litPrefix

			-- iniciamos los assets que se van a lb.asset.listedLayersObjs
			for ast in lb.asset.sceneAssets do
			(
				tp = ast.type
				if ckb_CHRs.checked and tp == lb.nc.NC_chrPrefix then append lb.asset.listedAssets ast
				if ckb_PRPs.checked and tp == lb.nc.NC_prpPrefix then append lb.asset.listedAssets ast
				if ckb_SPRs.checked and tp == lb.nc.NC_sprPrefix then append lb.asset.listedAssets ast
				if ckb_SETs.checked and tp == lb.nc.NC_setPrefix then append lb.asset.listedAssets ast
				if ckb_FXs.checked and tp == lb.nc.NC_fxPrefix then append lb.asset.listedAssets ast
				if ckb_LITs.checked and tp == lb.nc.NC_litPrefix then append lb.asset.listedAssets ast
			)
			
			-- Si hay lb.asset.listedAssets seleccionamos el primero
			if lb.asset.listedAssets.count > 0 then lb.asset.selAssets = #(1) else lb.asset.selAssets = #()
			fillIconsDG() --rellena el listado de asssets
			refreshControls()
							
			--si el rollout global de assets esta abierto, hay que actualizarlo
			if lb.assetList != undefined and lb.assetList.isOpen() then
			(
				lb.assetList.rollMain.updateControls()
				lb.assetList.rollMain.updateGridViewSelection()
			)
			-----------------------------------------------------------------------
		)

		----------------------------------------------------------------------------------
		-- función que crea el menú del botón derecho del ratón
		----------------------------------------------------------------------------------
		fn createRMenu x y =
		(
			rMenu.items.clear()
			rMenuItems = #()
			rMenuConfigureItems = #()
			
			rmenu.rendermode = (dotnetclass "System.Windows.Forms.ToolStripRenderMode").professional
			rMenu.showImageMargin = false
			
			append rMenuItems "Select objects"
			append rMenuItems "Select all objects in asset" 
			
			for i = 1 to rMenuItems.count do rMenu.items.add rMenuItems[i]
			
			-- si no hay ningún asset seleccionado desactivamos las opciones
			for i = 0 to (rMenu.items.count - 1)  do
				rMenu.items.item[i].enabled = (lb.asset.selAssets.count != 0) 
			
			rMenu.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Microsoft Sans Serif") 7.5
			
			rMenu.show this.rollAdvanced.lvLayers x y
		)

		----------------------------------------------------------------------------------
		--cera el listado de assets de la escena en un menu
		----------------------------------------------------------------------------------
		fn showAsseListMenu =
		(
			menuItems = #() --elementos del listado
				
			menuAssetList.items.clear() --vacia el menu
			
			--propiedades de visualizacion del menu
			menuAssetList.rendermode = (dotnetclass "System.Windows.Forms.ToolStripRenderMode").professional
			menuAssetList.showImageMargin = false
			menuAssetList.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Microsoft Sans Serif") 7.5
			
			for ast in lb.asset.listedAssets do --obtiene los nombres de los assets listados
				append menuItems ast.fullName
			
			for item in menuItems do --añade los nombres al menu
				menuAssetList.items.add item
			
			menuAssetList.Show (rollFltAssetManager.pos.x + 145) (rollFltAssetManager.pos.y + 40)
		)

		-----------------------------------------------------------------------------
		--selecciona las piezas del asset que tengan los flags pasados por parametro
		--mode indica si hacer un #and o un #or con los flags 
		-----------------------------------------------------------------------------
		fn selectPiecesByFlag flags flagsMode:#and allLayers:false =
		(
			if flags.count != 0 then
			(
				clearSelection()
				selObjs = #()
				types = #()
				
				if allLayers then
					for i = 1 to this.rollAdvanced.lvLayers.rows.count do
						append types (this.rollAdvanced.lvLayers.item 0 (i-1)).value
				else
					for i = 1 to lvSelItems.count do
						append types (lvSelItems.item[i-1].value as string)
				
				selObjs =#()
				
				for s in lb.asset.selAssets do
					selObjs += lb.asset.getAssetNodesByType lb.asset.listedAssets[s] types flags:flags flagsMode:flagsMode
				
				select selObjs
			)
		)
		
		-----------------------------------------------------------------------------
		--muestra un rollout con los Flags disponibles
		-----------------------------------------------------------------------------
		fn showAvailableFlags =
		(
			rolloutDef = "rollout rollAssetManagerFlags \"Select by Flag\" width:380\n"
			rolloutDef = rolloutDef + "(\n"
			rolloutDef = rolloutDef + "	radiobuttons rdoFlagsMode pos:[5,5] labels:#(\"and\", \"or\")\n"
			rolloutDef = rolloutDef + "	radiobuttons rdoLayersMode pos:[105,5] labels:#(\"selected layers\", \"all layers\")\n"
			
			for i=2 to lb.nc.NC_flags.count do
			(	
				rolloutDef = rolloutDef + "checkbox chkFlag" + ((i-1) as string) + " \"" + (lb.nc.NC_flags[i]) + ": " + (lb.nc.NC_flagsDesc[i]) + "\" pos:[5," + ((35 + 20*(i-2)) as string) + "] width:400 height:15 tooltip:\"" + (lb.nc.NC_flagsDesc[i]) + "\"\n"
			)
			
			rolloutDef = rolloutDef + "button btnOk \"OK\" pos:[5," + ((45 + 20*(lb.nc.NC_flags.count-1)) as string) + "] width:50 height:20\n"
			
			rolloutDef = rolloutDef + "\n"
			rolloutDef = rolloutDef + "on btnOk pressed do (\n"
			rolloutDef = rolloutDef + "		flags = #()"
			
			for i=2 to lb.nc.NC_flags.count do
			(
				rolloutDef = rolloutDef + "	if chkFlag" + ((i-1) as string) + ".checked then\n"
				rolloutDef = rolloutDef + "	append flags \"" + (lb.nc.NC_flags[i]) + "\"\n"
			)
			
			rolloutDef = rolloutDef + "		sort flags\n"
			rolloutDef = rolloutDef + "		rollMainDef.selectPiecesByFlag flags flagsMode:(if rdoFlagsMode.state == 1 then #and else #or) allLayers:(if rdoLayersMode.state == 1 then false else true)\n"
			rolloutDef = rolloutDef + "		destroydialog rollAssetManagerFlags\n"
			rolloutDef = rolloutDef + ")\n"
			rolloutDef = rolloutDef + ")\n"
			
			execute rolloutDef
			
			try
				createDialog rollAssetManagerFlags lockWidth:true style:#(#style_border,#style_resizing,#style_toolwindow,#style_sysmenu) modal:true			
			catch()
		)

		-----------------------------------------------------------------------------
		--funcion de actualizacion llamada desde ASSETLIST
		-----------------------------------------------------------------------------
		fn updateFromAssetList sceneAstsUpdated:false listedAstsUpdated:false selAstsUpdated:false =
		(
			if lb.assetList != undefined and lb.assetList.isOpen() then
			(
				
				--actualiza el estado de los filtros de asset
				ckb_CHRs.checked = lb.assetList.rollMain.ckb_CHRs.checked
				ckb_PRPs.checked = lb.assetList.rollMain.ckb_PRPs.checked
				ckb_SPRs.checked = lb.assetList.rollMain.ckb_SPRs.checked
				ckb_SETs.checked = lb.assetList.rollMain.ckb_SETs.checked
				ckb_FXs.checked = lb.assetList.rollMain.ckb_FXs.checked
				ckb_LITs.checked = lb.assetList.rollMain.ckb_LITs.checked
				
				if selAstsUpdated then
				(
					fillIconsDG()
					refreshControls()
				)
			)				
			else
			(
				ckbAssetList.checked = false
				updateToolbarButtons()
			)--if rollAssetList.opened
		)

		------------------------------------------------
		--@fn: undefined | updateDepententRollouts | actualiza los rollouts dependientes de este (otras herramientas)
		------------------------------------------------	
		fn updateDepententRollouts sceneAstsUpdated:false listedAstsUpdated:false selAstsUpdated:false =
		(
			for roll in affectedRollouts where roll.open do
				roll.updateFromAssetManager sceneAstsUpdated:sceneAstsUpdated listedAstsUpdated:listedAstsUpdated selAstsUpdated:selAstsUpdated
		)

		-----------------------------------------------------------------------------
		--añade el subrollout advanzed del interfaz
		-----------------------------------------------------------------------------										
		fn addAdvancedControls = 
		(
			AddSubRollout subRollAdvanced parent.rollAdvanced rolledUp:false 
			parent.rollAdvanced.resize [parent.rollMain.width, parent.rollMain.height]
		)

		------------------------------------------------
		--@fn: undefined | initUI | Inicializa los controles del UI.
		------------------------------------------------
		fn initUI =
		(	
			tbTabs.paintstylename = "PropertyView"
			tbTabs.borderStyle = (dotnetclass "DevExpress.XtraEditors.Controls.BorderStyles").noBorder
			tbTabs.TabPageWidth = 100			
			
			tbTabs.Appearance.BackColor = (dotnetclass "system.drawing.color").fromArgb 68 68 68
			tbTabs.Appearance.BackColor2 = (dotnetclass "system.drawing.color").fromArgb 68 68 68
			tbTabs.Appearance.BorderColor = (dotnetclass "system.drawing.color").fromArgb 100 100 100

			_imageList = dotnetObject "DevExpress.Utils.ImageCollection"
			_tabIconFiles = getFiles ((lb.config.getToolsIconsPath()) + "assetManager\\*.png")
			_imageDraw = dotnetClass "System.Drawing.Image"

			for icon in _tabIconFiles do
			(
				_putImage = _imageDraw.FromFile icon
				_imageList.addImage _putImage
			)

			tbTabs.Images = _imageList



			--LEER IMAGENES I METERLAS
		)

		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			_width = (lb.xml.getAttribute parent.cfgFile ("rollMain/size") "width") as integer
			_height = (lb.xml.getAttribute parent.cfgFile ("rollMain/size") "height") as integer
				
			--posicion
			_posX = (lb.xml.getAttribute parent.cfgFile ("rollMain/pos") "x") as integer
			_posY = (lb.xml.getAttribute parent.cfgFile ("rollMain/pos") "y") as integer

			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonCHRstate" (ckb_CHRs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonPRPstate" (ckb_PRPs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonSETstate" (ckb_SETs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonSPRstate" (ckb_SPRs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonFXstate" (ckb_FXs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonLITstate" (ckb_LITs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonPRPstate" (ckb_PRPs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonSETstate" (ckb_SETs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonSPRstate" (ckb_SPRs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonFXstate" (ckb_FXs.checked as string)
			
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "subRollLayersOpen" (showLayers as string)
				
			--establece minimos
			if _width < minRollWidth then _width = minRollWidth
			if _height < minRollHeight then _height = minRollHeight
			if _posX < 0 then _posX = 0
			if _posY < 0 then _posY = 0
				
			--aplica los valores
			rollMainDef.width = _width
			rollMainDef.height = _height
			setDialogPos rollMainDef [_posX,_posY]

			--aplica el tab seleccionado
			parent.selectedTabIndex = (lb.xml.getAttribute parent.cfgFile "rollMain/options" "selectedTabIndex") as integer
			if parent.selectedTabIndex == 0 then parent.selectedTabIndex = 1
		)
		
		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--almacena posicion
			lb.xml.setAttribute parent.cfgFile ("rollMain/pos") "x" (((getDialogPos rollMainDef).x) as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/pos") "y" (((getDialogPos rollMainDef).y) as string)
			
			--almacena tamaño
			lb.xml.setAttribute parent.cfgFile ("rollMain/size") "width" (rollMainDef.width as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/size") "height" (rollMainDef.height as string)

			--almacena las opciones de UI
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "selectedTabIndex" (parent.selectedTabIndex as string)

			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonCHRstate" (ckb_CHRs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonPRPstate" (ckb_PRPs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonSETstate" (ckb_SETs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonSPRstate" (ckb_SPRs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonFXstate" (ckb_FXs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonLITstate" (ckb_LITs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonPRPstate" (ckb_PRPs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonSETstate" (ckb_SETs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonSPRstate" (ckb_SPRs.checked as string)
			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "buttonFXstate" (ckb_FXs.checked as string)

			lb.xml.setAttribute parent.cfgFile ("rollMain/options") "subRollLayersOpen" (showLayers as string)
		)

		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks de este rollout.
		------------------------------------------------
		fn createSceneEvents =
		(
			_id = ((parent.className + "_" + (substituteString parent.rollMain.name "Def" "")) as name)

			callbacks.addscript #filePostOpenProcess 	"lb.assetManager.rollMain.resetSceneAssets()" id:_id
			callbacks.addscript #filePostMerge 			"lb.assetManager.rollMain.resetSceneAssets()" id:_id
			callbacks.addscript #systemPostReset 		"lb.assetManager.rollMain.resetSceneAssets()" id:_id
			callbacks.addscript #layerCreated 			"lb.assetManager.rollMain.resetSceneAssets()" id:_id
			callbacks.addscript #layerDeleted 			"lb.assetManager.rollMain.resetSceneAssets()" id:_id
			
			callbacks.addscript #nodeFreeze				"lb.assetManager.rollMain.updateLayerControls()" id:_id
			callbacks.addscript #nodeUnfreeze 			"lb.assetManager.rollMain.updateLayerControls()" id:_id
			callbacks.addscript #nodeHide	 			"lb.assetManager.rollMain.updateLayerControls()" id:_id
			callbacks.addscript #nodeUnhide 			"lb.assetManager.rollMain.updateLayerControls()" id:_id
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Elimina los callbacks de este rollout.
		------------------------------------------------
		fn removeSceneEvents =
		(
			_id = ((parent.className + "_" + (substituteString parent.rollMain.name "Def" "")) as name)
			callbacks.removescripts id:_id
		)

		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si el tamaño es menor que el minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollMainDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollMainDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento de tamaño
			_increment = [size.x - minRollWidth, size.y - minRollHeight]

			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				--zona de subRollouts
				--subRollContainer.height = 574 + _increment.y				
			)--if
			------------------------------------------------------------------------------

			------------------------------------------------------------------------------
			--redimension en horizonal
			if _increment.x != 0 then --si hay incremento
			(				
				tbTabs.width = 350 + _increment.x
				if tbTabs.tabPages.count != 0 then tbTabs.TabPageWidth = (minRollWidth + _increment.x)/(tbTabs.tabPages.count) - 12
				subRollContainer.width = size.x

				parent.addTabRollouts()
			)--if
			------------------------------------------------------------------------------						
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------

		on tmClock tick do
		(
			if objects.count != numObjects do
			(
				
				if lb.asset.sceneAssets == undefined then
				(
					lb.asset.sceneAssets = lb.asset.getSceneAssets()
					lb.asset.selAssets = #()
				)
				
				selAssetsFullNames = #()
				for s in lb.asset.selAssets do
					append selAssetsFullNames lb.asset.sceneAssets[s].fullname
				
				rollMainDef.resetSceneAssets()
				
				lb.asset.selAssets = #()
				for i=1 to lb.asset.sceneAssets.count do
					for s in selAssetsFullNames do
						if lb.asset.sceneAssets[i].fullname == s then
							append lb.asset.selAssets i
				rollMainDef.refreshControls()
					
				numObjects = objects.count
			)
		)

		------------------------------------------------
		--EVENTS
		------------------------------------------------

		----------------------------------------------------------------------------------
		--actualiza el listado en funcion del valor del scroll
		----------------------------------------------------------------------------------
		on dgAssetIconsHscroll ValueChanged e do
		(
			newVal = (dgAssetIconsHscroll.value * 100.0)/(100 - dgAssetIconsHscroll.LargeChange)
			newVal = ((dgAssetIcons.columns.count * 25) - (200))/100.0*newVal
			if newVal >= 0 then dgAssetIcons.HorizontalScrollingOffset = newVal
		)
		
		----------------------------------------------------------------------------------
		--actualiza la seleccion de assets
		----------------------------------------------------------------------------------
		on dgAssetIcons MouseUp e do
		(
			lb.asset.selAssets = #()
			for i=1 to dgAssetIcons.columns.count where (dgAssetIcons.item (i-1) 0).selected do
				append lb.asset.selAssets i
			
			refreshControls()
		)

		----------------------------------------------------------------------------------
		--Al hacer doble click en un icono de un asset selecciona todas las piezas de ese asset
		----------------------------------------------------------------------------------
		on dgAssetIcons CellMouseDoubleClick e do
		(
			if not keyboard.controlPressed do clearSelection() --primero limpiamos la seleccion si no estamos pulsando ctrl
			
			for index in lb.asset.selAssets do --recorre los assets seleccionados para seleccionar sus piezas
			(
				depGroup = #(lb.asset.listedAssets[index])
					
				if chkaffectDependentAssets.checked and (not lb.asset.listedAssets[index].isDependent) then
					depGroup = (lb.asset.getDependencyGroup lb.asset.listedAssets[index] lb.asset.listedAssets)
				
				nodesToSelect = #()
				for a in depGroup do nodesToSelect += a.nodes --selectMore a.nodes
					
				selectMore nodesToSelect
			)
		)

		----------------------------------------------------------------------------------
		on ckb_CHRs changed val do
		(
			resetSceneAssets()
			updateDepententRollouts listedAstsUpdated:true selAstsUpdated:true
		)
		
		----------------------------------------------------------------------------------
		on ckb_PRPs changed val do
		(
			resetSceneAssets()
			updateDepententRollouts listedAstsUpdated:true selAstsUpdated:true
		)
		
		----------------------------------------------------------------------------------
		on ckb_SETs changed val do
		(
			resetSceneAssets()
			updateDepententRollouts listedAstsUpdated:true selAstsUpdated:true
		)
		
		----------------------------------------------------------------------------------
		on ckb_SPRs changed val do
		(
			resetSceneAssets()
			updateDepententRollouts listedAstsUpdated:true selAstsUpdated:true
		)
		
		----------------------------------------------------------------------------------
		on ckb_FXs changed val do
		(
			resetSceneAssets()
			updateDepententRollouts listedAstsUpdated:true selAstsUpdated:true
		)
		
		----------------------------------------------------------------------------------
		on ckb_LITs changed val do
		(
			resetSceneAssets()
			updateDepententRollouts listedAstsUpdated:true selAstsUpdated:true
		)

		----------------------------------------------------------------------------------
		on btnAddAsset pressed do
		(
			if keyboard.controlPressed do lb.assetBrowser.run()
		)			

		----------------------------------------------------------------------------------
		on btnDeleteAsset pressed do
		(
			if lb.asset.selAssets.count != 0 then
			(
				assetsToDelete = #()
				
				assetsToDelete = parent.getSelectedAssets()
				deleteMessage = ""
				
				if chkaffectAllAssets.checked then
					deleteMessage = "Delete ALL scene assets?"
				else if chkaffectDependentAssets.checked then
					deleteMessage = "Delete SELECTED and DEPENDENT assets?"
				else
					deleteMessage = "Delete SELECTED assets?"
				
				if queryBox deleteMessage then
				(			
					--pasa los assets a borrar al modo Puppet para evitar fallos de dependencias.
					--asi no falla porque las conexiones y modificadores estan desactivados
					for ast in assetsToDelete do
						lb.asset.setAssetPuppetMode ast
					
					setWaitCursor()
					
					undo "Delete Assets" on
						for ast in assetsToDelete do
							lb.asset.deleteAsset ast includeDependents:false
					
					resetSceneAssets()
						
					setArrowCursor()
				)
			)
		)
		
		----------------------------------------------------------------------------------
		on btnShowHideLayers mouseDown events do
		(
			showLayers = not ShowLayers
			btnShowHideLayers.text = if showLayers then "- Advanced" else "+ Advanced"
			rollMainDef.height += if showLayers then layersHeight else (-layersHeight)
			autoAdjustFloaterHeight()
		)

		----------------------------------------------------------------------------------
		on ckbAssetList changed val do
		(
			if val then
			(
				lb.assetList.run()
			)
			else
			(
				lb.assetList.close()
			)
		)
		
		----------------------------------------------------------------------------------
		on btnAssetsFromNodes pressed do
		(
			sceneSelectedAssets = lb.asset.getAssetsFromNodes (getCurrentSelection()) --obtine los assets seleccionados en la escena
				
			if sceneSelectedAssets.count != 0 then --si ha obtenido algun asset seleccionado en la escena
			(
				lb.asset.selAssets = #()
				
				for ast in sceneSelectedAssets do
				(
					depGroup = #(ast)
					
					if chkaffectDependentAssets.checked then
						depGroup = (lb.asset.getDependencyGroup ast lb.asset.sceneAssets)
					
					for a in depGroup do
						for i=1 to lb.asset.listedAssets.count do
							if a.fullname == lb.asset.listedAssets[i].fullname then
								appendIfUnique lb.asset.selAssets i
				)
				
				refreshControls()
			)--if
		)

		----------------------------------------------------------------------------------
		on btnUnhideAll pressed do 
		(
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			with undo off
				for ast in lb.asset.listedAssets do
					if lb.asset.getAssetvismode ast == "" then
						lb.asset.resetAsset ast
			
			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		
		----------------------------------------------------------------------------------
		on btnShow pressed do
		(
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
			(
				for a in assetsToChangeVis do
					if lb.asset.getAssetvismode a == "" then
						lb.asset.resetAsset a
			)
			
			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		
		----------------------------------------------------------------------------------
		on btnHide pressed do
		(
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
			(
				for a in assetsToChangeVis do
					lb.asset.hideAsset a
			)
			
			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		
		----------------------------------------------------------------------------------
		on btnSolo pressed do
		(
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
			(
				for a in assetsToChangeVis do
					if (lb.asset.getAssetvismode a) == "" then
						lb.asset.resetAsset a	
				
				if assetsToChangeVis.count != 0 then
					lb.asset.isolateAssets assetsToChangeVis lb.asset.sceneAssets
			)
				
			lb.assetManager.rollAdvanced.fillLayerControls()
		)

		----------------------------------------------------------------------------------
		--actualiza el modo de visualizacion del asset seleccionado
		----------------------------------------------------------------------------------
		on btnVMpuppet pressed do
		(
			-- 			_bkpCP = getCommandPanelTaskMode()
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
				for a in assetsToChangeVis do
				(
					lb.asset.setAssetPuppetMode a disableSecPuppets:(not chkDisSecPuppets.checked)
			-- 					showExtraControls a #all _hide:(not chkShowExtraControls.checked)
			-- 					showExtraControls a #connect _hide:(not chkShowExtraControls.checked)
				)
				
			setCommandPanelTaskMode #modify

			completeRedraw()
				
			lb.assetManager.rollAdvanced.fillLayerControls()
				
			-- 			chkShowExtraControls.enabled = true --false
			-- 			chkShowExtraControls.checked = false
		)
		
		----------------------------------------------------------------------------------
		--actualiza el modo de visualizacion del asset seleccionado
		----------------------------------------------------------------------------------
		on btnVMpuppetHead pressed do
		(
			-- 			_bkpCP = getCommandPanelTaskMode()
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
				for a in assetsToChangeVis do
				(
					lb.asset.setAssetPuppetHeadMode a disableFFDs:(not chkaffectFFDs.checked) disableHair:(not chkaffectHair.checked) disableSecPuppets:(not chkDisSecPuppets.checked)
					lb.asset.showExtraControls a #facial _hide:(not chkShowExtraControls.checked)
					lb.asset.showExtraControls a #connect _hide:(not chkShowExtraControls.checked)
				)
			
			setCommandPanelTaskMode #modify

			completeRedraw()
			
			lb.assetManager.rollAdvanced.fillLayerControls()
				
			-- 			chkShowExtraControls.enabled = true
			-- 			chkShowExtraControls.checked = true
		)
		
		----------------------------------------------------------------------------------
		--actualiza el modo de visualizacion del asset seleccionado
		----------------------------------------------------------------------------------
		on btnVMhead pressed do
		(
			-- 			_bkpCP = getCommandPanelTaskMode()
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
				for a in assetsToChangeVis do
				(
					lb.asset.setAssetHeadMode a disableFFDs:(not chkaffectFFDs.checked) disableHair:(not chkaffectHair.checked)
					lb.asset.showExtraControls a #facial _hide:(not chkShowExtraControls.checked)
				)
			
			setCommandPanelTaskMode #modify

			completeRedraw()
				
			lb.assetManager.rollAdvanced.fillLayerControls()
				
			-- 			chkShowExtraControls.enabled = true
			-- 			chkShowExtraControls.checked = true
		)
		
		----------------------------------------------------------------------------------
		--actualiza el modo de visualizacion del asset seleccionado
		----------------------------------------------------------------------------------
		on btnVMskin pressed do
		(
			-- 			_bkpCP = getCommandPanelTaskMode()

			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
				for a in assetsToChangeVis do
				(
					lb.asset.setAssetSkinMode a
					lb.asset.showExtraControls a #all _hide:(not chkShowExtraControls.checked)
				)
			
			setCommandPanelTaskMode #modify
			
			completeRedraw()
				
			lb.assetManager.rollAdvanced.fillLayerControls()
				
			-- 			chkShowExtraControls.enabled = true --false
			-- 			chkShowExtraControls.checked = false
		)
		
		----------------------------------------------------------------------------------
		--actualiza el modo de visualizacion del asset seleccionado
		----------------------------------------------------------------------------------
		on btnVMskinBox pressed do
		(
			-- 			_bkpCP = getCommandPanelTaskMode()
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			suspendEditing()
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
				for a in assetsToChangeVis do
				(
					lb.asset.setAssetSkinBoxMode a disableSecPuppets:(not chkDisSecPuppets.checked)
					lb.asset.showExtraControls a #anim _hide:(not chkShowExtraControls.checked)
					lb.asset.showExtraControls a #connect _hide:(not chkShowExtraControls.checked)
				)
			
			setCommandPanelTaskMode #modify
			
			resumeEditing()
			completeRedraw()
			
			lb.assetManager.rollAdvanced.fillLayerControls()
			updateRollMainControls()
				
			-- 			chkShowExtraControls.enabled = true
			-- 			chkShowExtraControls.checked = true
		)	

		----------------------------------------------------------------------------------
		--actualiza el modo de visualizacion del asset seleccionado
		----------------------------------------------------------------------------------
 		on btnConnection pressed do
		(
			-- 			_bkpCP = getCommandPanelTaskMode()
			
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			suspendEditing()
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
				for a in assetsToChangeVis do
					lb.asset.setAssetSkinConnectionMode a
			
			setCommandPanelTaskMode #modify

			resumeEditing()
			completeRedraw()
			
			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		
		----------------------------------------------------------------------------------
		--actualiza la seleccion de assets
		----------------------------------------------------------------------------------
		on chkaffectAllAssets changed state do
		(
			
			-- 			selAssets = #()
			-- 			for i=1 to lb.asset.listedAssets.count do
			-- 				append selAssets (i + _assetOffset)
			-- 			
			-- 			refreshControls()
			-- 			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		
		----------------------------------------------------------------------------------
		--actualiza la seleccion de assets
		----------------------------------------------------------------------------------
		on chkaffectDependentAssets changed state do
		(
			-- 			lb.assetManager.rollAdvanced.fillLayerControls()
		)
		
		----------------------------------------------------------------------------------
		--oculta/muestra los puppets secundarios
		----------------------------------------------------------------------------------
		on chkDisSecPuppets changed state do
		(
			--Activamos la pestaña de crear para que vaya más fluido
			max create mode
			
			assetsToChangeVis = parent.getSelectedAssets()
			
			with undo off
			(
				for a in assetsToChangeVis do
					if not state then
						lb.asset.hideSecPuppets a
					else
						lb.asset.showSecPuppets a	
			)
		)
		
		----------------------------------------------------------------------------------
		on chkShowExtraControls changed state do
		(
			/*animExtraObjs = #() 
			
			for a in (parent.getSelectedAssets()) do
				join animExtraObjs (lb.asset.getAssetNodesByType a #(lb.nc.NC_classAnim, lb.nc.NC_classFacial) flags:#(lb.nc.NC_controlFlag,lb.nc.NC_extraFlag))
					
			animExtraObjs.isHidden = not state*/
			
			for a in (parent.getSelectedAssets()) do
			(
				_visMode = lb.asset.getAssetvismode a
				
				case _visMode of
				(
					"P":
					(					
						lb.asset.showExtraControls a #connect _hide:(not state)
			-- 						lb.asset.showExtraControls a #facial _hide:(not state)
						
					)

					"P+H": 
					(
						lb.asset.showExtraControls a #facial _hide:(not state)
						lb.asset.showExtraControls a #connect _hide:(not state)
					)
					"H": lb.asset.showExtraControls a #facial _hide:(not state)
					"S+B":
					(
						
						lb.asset.showExtraControls a #connect _hide:(not state)
					)
					default: lb.asset.showExtraControls a #all _hide:(not state)
				)--case
			)
		)	

		----------------------------------------------------------------------------------
		on rMenu itemclicked events do
		(
			item = (events.clickeditem.tostring())
			
			case item of
			(
				"Select objects":	btnSel.pressed()
				"Select all objects in asset": btnSelAll.pressed()
			)
		)
		
		----------------------------------------------------------------------------------
		on menuAssetList itemclicked events do
		(
			item = (events.clickeditem.tostring())
			
			stop = false
			cont = 1
				
			while not stop and cont <= lb.asset.listedAssets.count do
			(
				if lb.asset.listedAssets[cont].fullName == item then
				(
					stop = true
					
					--selAsset = cont + _assetOffset
					lb.asset.selAssets = #(cont + _assetOffset)
					refreshControls()
				)
				
				cont += 1
			)
		)

		------------------------------------------------
		--@event: selectedPageChanged | Evento que se lanza al cambiar de tab.
		--@control: DevExpress.XtraTab.XtraTabControl | tbTabs | Tabs.
		--@gets: event | events | Objeto devuelto por el evento.
		------------------------------------------------
		on tbTabs selectedPageChanged events do
		(
			if not opening then
			(
				parent.selectedTabIndex = tbTabs.selectedTabPageIndex + 1
				parent.addTabRollouts()
				parent.heightAdjust (tbTabs.selectedTabPageIndex + 1)
			)--if
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMainDef | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollMainDef resized size do
		(
			--SE DEJA COMENTADO PORQUE NO HACE FALTA Y ADEMAS HACE QUE SE RELLENEN DE NUEVO TODOS LOS TABS, CREANDO INCOHERENCIAS EN EL ROLLEDUP DE LOS SUBROLLOUTS
			--resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMainDef | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMainDef open do
		(
			initUI()
			loadSettings()

			affectedRollouts = #(lb.assetList.rollMain) --rellena los rollouts relacionados

			addAdvancedControls()

			--Miramos la ruta del archivo y rellenamos la variable de la unidad.
			if maxFilePath != "" then _projectUnit = (filterString maxFilePath "\\")[1] + "\\"
			else _projectUnit = "z:\\"

			opening = true --flag para que no salte el evento de cambio de tab y no pise el valor cargado del archivo .cfg
			numObjects = objects.count
			
			lb.asset.selAssets = #()
			initIconsDG()
			initControlsVariables()
			resetSceneAssets() --esto se ha pueto aqui porue hay veces que al abrir el asset manager no se rellena bien

			--------------------------------------------------	
			--averigua el estado en el que tiene que estar el checkbox EC			
			_state = false
			if lb.asset.sceneAssets.count != 0 then
			(
				_visMode = lb.asset.getAssetvismode lb.asset.sceneAssets[1]
				
				_class = lb.nc.NC_classAnim
				
				case _visMode of
				(
					"P+H": _class = lb.nc.NC_classFacial
					"H": _class = lb.nc.NC_classFacial
				)
				
				_extraControls = lb.asset.getAssetNodesByType lb.asset.sceneAssets[1] _class flags:#(lb.nc.NC_controlFlag, lb.nc.NC_extraFlag) flagsMode:#and excludeHidden:true excludeFrozen:true
				if _extraControls.count != 0 then _state = not _extraControls[1].ishidden
			)
			chkShowExtraControls.checked = _state
			--------------------------------------------------

			parent.fillTabsRolloutsDefs()
			parent.addTabs()
			parent.heightAdjust (tbTabs.selectedTabPageIndex + 1)

			createSceneEvents()
			if parent.rollMain != undefined then resize [parent.rollMain.width, parent.rollMain.height]

			opening = false --flag para que no salte el evento de cambio de tab y no pise el valor cargado del archivo .cfg
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMainDef | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMainDef close do
		(				
			removeSceneEvents()
			saveSettings()

			parent.opened = false
			updateToolbarButtons()		
		)	
	)--rollMainDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@struct: assetManager | Contiene la herramienta assetManager.
	------------------------------------------------------------------------------------------------------------------------------------------------
	struct tl_assetManager
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		def = (classof this),				--@var: def | Almacena la definicion del struct.
		defFile = getThisScriptFilename(),	--@var: defFile | Almacena la ruta del propio archivo de script que contiene la definicion.
		
		category = #main,					--@var: category | Categoria de la tool.
		className = lb.getFileToolName (getThisScriptFilename() as string),	--@var: className | Nombre de la tool.
		description = "Asset Manager",		--@var: description | Descripcion de la tool.
		
		cfgFile = (lb.config.getToolsIniPath()) + (lb.getFileToolName (getThisScriptFilename() as string)) + ".cfg",	--@var: cfgFile | Archivo de configuracion de la tool.
			
		opened = false,			--@var: opened | Indica si la herramienta está abierta.
		
		minWidth = 225,		--@var: minWidth | Ancho mínimo de la herramienta.
		minHeight = 600,		--@var: minHeight | Alto mínimo de la herramienta.

		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		tabForeColor = (dotnetclass "system.drawing.color").fromArgb 189 189 189,
		tabBorderColor = (dotnetclass "system.drawing.color").fromArgb 30 30 30,
		tabBackColor = (dotnetclass "system.drawing.color").fromArgb 60 60 60,
		tabBackColorActive = (dotnetclass "system.drawing.color").fromArgb 90 90 90,
		tabBackColor2 = (dotnetclass "system.drawing.color").fromArgb 55 55 55,
		tabBackColorActive2 = (dotnetclass "system.drawing.color").fromArgb 60 60 60,		

		------------------------------------------------------------------------------------------------
		--LIBRARIES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--ROLLOUTS
		------------------------------------------------------------------------------------------------

		rollCopies = rollCopiesDef,
		rollAdvanced = rollAdvancedDef,
		rollCloth = rollClothDef,
		rollClothOverride = rollClothOverrideDef,
		rollpreCamFrames = rollpreCamFramesDef,
		rollPrepareAnim = rollPrepareAnimDef,
		rollClothGeneral = rollClothGeneralDef,
		rollClothImportExport = rollClothImportExportDef,
		rollMain = rollMainDef,	--@var: rollMain | Main tool rollout.
		rollFX = rollFXDef,
		rollLoadFx = rollLoadFxDef,
		rollFxDetail = rollFxDetailDef,
		rollHair = rollHairDef,
		rollHairImport = rollHairImportDef,
		rollHairExportSim = rollHairExportSimDef,
		rollMisc = rollMiscDef,
		rollCameraAssets = rollCameraAssetsDef,
		rollCacheScene = rollCacheSceneDef,
		rollCacheExtras = rollCacheExtrasDef,
		rollCacheReloadAsset = rollCacheReloadAssetDef,
		rollAnimation = rollAnimationDef,
		rollSecondaryAnimation = rollSecondaryAnimationDef,
		rollCopiesVariations = rollCopiesVariationsDef,

		subRolloutsContainer = this.rollMain.subRollContainer, --@var: subRolloutsContainer | contenedor de subrollouts.
		subRollAdvancedContainer = this.rollMain.subRollAdvanced,

		--estos arrays se rellenan en la funcion fillTabsRolloutsDefs, que se llama al abrir la herramienta.
		--esto es solo la defincion de las variables y una ejemplo de estructura que luego se sobrescribe.
		tabNames = #("", "", "", "", "", "", "", ""), --@var: tambNames | Nombres de los tabs.
		tabRollouts = #(#(undefined), #(undefined), #(undefined), #(undefined), #(undefined), #(undefined), #(undefined), #(undefined)), --@var: mentalrayTabNames | Rollots de cada tab.
		tabRolloutsRolledUp = #(#(true), #(true), #(true), #(true), #(true), #(true), #(true), #(true)), --@var: tabRolloutsRolledUp | Estado de desplegado/plegado de cada rollout de cada tab.

		selectedTabIndex = 1, --@var: selectedTabIndex | Tab seleccionado. Para usar al abrir y cerrar la herramienta

		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
			
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------

		----------------------------------------------------------------------------------
		-- Devuelve un array con los assets seleccionados. Tiene en cuenta las opciones All Assets y Dependents.
		-- Esta función se utiliza en los subpaneles de animación, caché y copies.
		-- Si no hay nada seleccionado devuelve un array vacío.
		----------------------------------------------------------------------------------
		fn getSelectedAssets =
		(
			asts = #()
			
			if rollMainDef.chkaffectAllAssets.checked then
			(
				asts = lb.asset.sceneAssets
			)
			else if rollMainDef.chkaffectDependentAssets.checked then
			(
				for i in lb.asset.selAssets do
				(
					depGroup = (lb.asset.getDependencyGroup lb.asset.listedAssets[i] lb.asset.sceneAssets) --sceneAssets[i] sceneAssets)
					for a in depGroup do appendIfUnique asts a
				)
			)
			else
			(
				asts = for i in lb.asset.selAssets collect lb.asset.listedAssets[i] --selAssets collect sceneAssets[i]
			)
			
			asts			
		),

		------------------------------------------------
		--@fn: undefined | updateTabsColor | Actualiza el color de los tabs.
		------------------------------------------------
		fn updateTabsColor =
		(
			--actualiza los tabs
			for i=1 to this.tabNames.count do
			(
				--configura los colores de los tabs
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.Header.Font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 7
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.Header.ForeColor = this.tabForeColor
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.Header.BackColor = this.tabBackColor
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.Header.BackColor2 = this.tabBackColor2
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.Header.BorderColor = this.tabBorderColor
				
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.HeaderActive.Font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 8
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.HeaderActive.ForeColor = this.tabForeColor
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.HeaderActive.BackColor = this.tabBackColorActive
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.HeaderActive.BackColor2 = this.tabBackColorActive2
				this.rollMain.tbTabs.tabPages.item[i-1].Appearance.HeaderActive.BorderColor = this.tabBorderColor
			)--for
		),

		------------------------------------------------
		--@fn: undefined | fillTabsRolloutsDefs | Añade los tabs y las definiciones de los rollouts a los arrays correspondientes para que la herremienta sepa donde están.
		------------------------------------------------
		fn fillTabsRolloutsDefs =
		(
			this.tabNames = #("X", "Anim", "Cache", "Copy", "Cloth", "FX", "Hair", "Misc")
			this.tabRollouts = #(#(), #(lb.assetManager.rollAnimation,lb.assetManager.rollSecondaryAnimation), #(lb.assetManager.rollCacheScene, lb.assetManager.rollCacheExtras, lb.assetManager.rollCacheReloadAsset), #(lb.assetManager.rollCopies), #(lb.assetManager.rollClothGeneral, lb.assetManager.rollClothImportExport, lb.assetManager.rollCloth, lb.assetManager.rollPrepareAnim, lb.assetManager.rollClothOverride,lb.assetManager.rollpreCamFrames), #(lb.assetManager.rollFX, lb.assetManager.rollLoadFx, lb.assetManager.rollFxDetail), #(lb.assetManager.rollHair, lb.assetManager.rollHairImport, lb.assetManager.rollHairExportSim, lb.assetManager.rollPrepareAnim,lb.assetManager.rollpreCamFrames), #(lb.assetManager.rollMisc, lb.assetManager.rollCameraAssets))
			this.tabRolloutsRolledUp = #(#(), #(false,false), #(false, true,false), #(false), #(false,false,true,true,true,true), #(false, true, true), #(false, false, true, true,true), #(false,false))
		),

		------------------------------------------------
		--@fn: undefined | addTabs | Añade los tabs.
		------------------------------------------------
		fn addTabs =
		(
			--elimina los tabs actuales
			this.rollMain.tbTabs.tabPages.clear()

			--añade los tabs
			for i=1 to this.tabNames.count do
			(
				this.rollMain.tbTabs.tabPages.add this.tabNames[i] --añade el tab
				--Cojer el indice de imagen que le toca 
				if i > 1 then this.rollMain.tbTabs.tabPages.item[i-1].ImageIndex = (i-1)
			)
			
			if this.rollMain.tbTabs.tabPages.count != 0 then this.rollMain.tbTabs.TabPageWidth = (this.rollMain.width)/(this.rollMain.tbTabs.tabPages.count) - 12

			--selecciona el tab que estaba seleccionado la ultima vez que se abrio el override
			if this.rollMain.tbTabs.tabPages.count >= this.selectedTabIndex then
				this.rollMain.tbTabs.SelectedTabPage = this.rollMain.tbTabs.tabPages.item[this.selectedTabIndex - 1]
			
			this.updateTabsColor() --actualiza los colores de los tabs
			
			this.addTabRollouts()			
		),

		------------------------------------------------
		--@fn: undefined | removeAllTabRollouts | Elimina todos los subrollouts actuales
		------------------------------------------------
		fn removeAllTabRollouts =
		(
			--elimina los subRollouts actuales
			while this.subRolloutsContainer.rollouts.count != 0 do RemoveSubRollout this.subRolloutsContainer this.subRolloutsContainer.rollouts[1]
		),

		------------------------------------------------
		--@fn: undefined | addTabRollouts | Añade los rollouts del tab actual.
		------------------------------------------------
		fn addTabRollouts =
		(
			--elimina los subRollouts actuales
			this.removeAllTabRollouts()

			--añade los subRollouts
			for i=1 to this.tabRollouts[this.selectedTabIndex].count where this.tabRollouts[this.selectedTabIndex][i] != undefined do
			(
				AddSubRollout this.subRolloutsContainer this.tabRollouts[this.selectedTabIndex][i] rolledUp:this.tabRolloutsRolledUp[this.selectedTabIndex][i]
				this.tabRollouts[this.selectedTabIndex][i].resize [this.rollMain.width, this.rollMain.height]
			)
		),

		------------------------------------------------
		--@fn: undefined | heightAdjust | Ajusta las medidas del interfaz.
		------------------------------------------------
		fn heightAdjust senderIndex = 
		(
			_advancedIncrement = 150
			_toolHeight = 192
			if senderIndex == 0 then
			(
				if not this.rollAdvanced.open then _advancedIncrement = 0 - _advancedIncrement

				this.rollMain.tbTabs.pos.y += _advancedIncrement
				this.subRolloutsContainer.pos.y += _advancedIncrement
				this.subRollAdvancedContainer.height += _advancedIncrement
			)
			
			if this.rollAdvanced.open then _toolHeight += _advancedIncrement

			_rollHeight = 0
			_rollGap = 35
			_subRollouts = this.rollMain.subRollContainer.rollouts 

			for roll in _subRollouts do 
			(	
				--print roll.name
				--print roll.open
				
				if roll.open then 
				(
					_rollHeight += roll.height + 12
				)
				else 
				(
					_rollHeight += 15 --_rollGap
				)	
			)
			--print _rollHeight
			--print "-------------"
			--this.rollMain.subRollContainer.height = _rollHeight --+ _rollGap
			_rollHeightTotal = _rollHeight + _toolHeight + _rollGap
			
			this.rollMain.subRollContainer.height = _rollHeightTotal - _toolHeight
			this.rollMain.height = _rollHeightTotal
		),

		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: boolean | isOpen | Devuelve información true o false, si la herramienta está abierta o cerrada.
		------------------------------------------------
		fn isOpen =
		(
			this.opened
		),
		
		------------------------------------------------
		--@fn: undefined | refreshInterface | Refresca el interface inicial de la herramienta
		------------------------------------------------
		fn refreshInterface =
		(
			--refresca el interface de la herramienta
		),
		
		------------------------------------------------
		--@fn: undefined | createInterface | Crea el interface inicial de la herramienta
		------------------------------------------------
		fn createInterface =
		(
			--crea el interface, lo redimensiona y lo reposiciona
			createDialog this.rollMain lockwidth:true lockheight:true pos:[-10000,0] style:#(#style_toolwindow, #style_titlebar, #style_sysmenu, #style_resizing)
		),
		
		------------------------------------------------
		--@fn: undefined | destroyInterface | Destruye el interface de la herramienta.
		------------------------------------------------
		fn destroyInterface =
		(
			destroyDialog this.rollMain --cierra la herramienta.			
		),--destroyInterface
		
		------------------------------------------------
		--@fn: undefined | run | Lanza la herramienta.
		------------------------------------------------
		fn run =
		(
			this.createInterface() --crea el interface.
			this.opened = true --indica que la herramienta está abierta
		),--execute
		
		------------------------------------------------
		--@fn: undefined | close | Cierra la herramienta.
		------------------------------------------------
		fn close =
		(
			this.destroyInterface() --destruye el interface.
			this.opened = false --indica que la herramienta está cerrada.
		),
		
		------------------------------------------------
		--@fn: undefined | initSubLibraries | Inicializa todas las sublibrerías en el orden establecido.
		------------------------------------------------
		fn initSubLibraries =
		(
			_subLibraries = #()
			
			for sl in _subLibraries do sl.init()
		),
		
		------------------------------------------------
		--@fn: undefined | init | Inicializa la librería.
		------------------------------------------------
		fn init =
		(
			--this.rollMain.affectedRollouts = #(lb.assetList.rollMain)		
			this.initSubLibraries() --inicialza las librerías hijas
		),		
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--@event: create | Ejecución al crearse la instancia del struct.
		------------------------------------------------
		on create do
		(
			lb.addTool this --añade la tool a la libreria principal	
		)			
	)--tl_assetManager

	------------------------------------------------------------------------------------------------------------------------------------------------
	--EXECUTION
	------------------------------------------------------------------------------------------------------------------------------------------------	
	
	tl_assetManager() --crea la herramienta
)