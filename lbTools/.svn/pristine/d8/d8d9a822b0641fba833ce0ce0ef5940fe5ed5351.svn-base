------------------------------------------------------------------------------------------------------------------------------------------------
--Descripcion: libreria de assets
------------------------------------------------------------------------------------------------------------------------------------------------
(
	struct str_assetInfo
	(
		--	Todos los ejemplos del siguiente lote de variables reflejan el resultado para el asset "chr_tadeo-worker(body-openPocket)[dirty-all]#002_mesh-draft_v01.max"
		--	------------------------------------------------------------------------------------------------------------------------------------------------------------

		fullName = "", 			-- 	Nombre completo del asset, incluyendo prefijos y número de copia. 	Resultado: chr_tadeo-worker(body-openPocket)[dirty-all]#002
		
		type = "", 				-- 	Prefijo del tipo de asset (chr, prp, set).						Resultado: chr
		name = "", 				-- 	Nombre del asset sin prefijos ni números de copia 				Resultado: tadeo-worker
		
		subType = "",			--	Indica si el asset es de tipo mesh, anim, etc					Resultado: mesh-draft
		subTypePrefix = "",		--	Subtipo principal										Resultado: mesh
		subTypeSuffix = "",		--	Subtipo secundario										Resultado: draft
		
		namePrefix = "",			--	Primera parte del Name antes del guión medio. 					Resultado: tadeo
		nameSuffix = "",			--	Segunda parte del name después del guión medio sin ningún sufijo: 	Resultado: worker
		
		part = "",				--	Nombre completo de la parte que representa el asset				Resultado: body-openPocket
		partPrefix = "",			--	Nombre principal de la parte que representa el asset.				Resultado: body
		partSuffix = "",			--	Segunda parte del nombre que representa el asset.				Resultado: openPocket
		
		preset = "",			--	Preset desde el que se ha cargado el asset.					Resultado: dirty-all
		presetPrefix = "",		--	Nombre principal del preset que representa el asset				Resultado: dirty
		presetSuffix = "",			--	Segunda parte del nombre del preset 							Resultado: all
		
		copyNumber = 0,			--	Número de copia del asset. 								Resultado: 2
		
		folder = "", 			--	Carpeta en la que está almacenado el asset. Aquí se buscan los iconos
		filePath = "",			--	Ruta completa del archivo del que mergeó el asset
		files = #(),			--	Nombres de los ficheros de los que provienen las piezas
		filesLoadMode = #(),	--	Modo de carga de cada uno de los ficheros que componen el asset
		
		loadMode = #undefined,	--	Puede valer #merge, #xRefObjects o #xRefMeshObjects...
		version = -1,			--	Número de versión del asset. Se lee del NodeInfo de las piezas. -1 indica que no se ha conseguido leer.
		isXrefScene = false,	--	indica si el asset está cargado por XrefScene en la escena
		isXrefObject = false,	--	indica si el asset está cargado por XrefObjects en la escena
		isDraftAsset = false,	--	indica si el asset es de tipo draft
		isLayoutAsset = false,	--	indica si el asset es de tipo layout
		isCacheAsset = false,	--	indica si el asset es de tipo cache
		isDependent = false,	--	indica si el asset es un asset principal o un asset que depende de otro (FALSE:principal, TRUE:dependiente)
		mainAsset = "",			--	Almacena el fullName del asset del que depende este
		hasPuppets = false,		--	indica si el asset tiene alguna pieza de rig con puppet
		hasProxy = false,		--	Indica si el asset tiene modificadores de proxy
		layer = undefined, 		-- 	Layer en el que está contenido el asset
		
		nodes = #(),			--	Nodos del asset
		
		meshNodesAll	= #(),		--	Nodos de Tipo mesh TODOS
		--draftNodesAll	= #(),		--	Nodos de Tipo mesh de draft --ELIMINADA
		
		proxyNodesAll	= #(),		--	Nodos de Tipo proxy TODOS
		morphNodesAll	= #(),		--	Nodos de Tipo morph TODOS
		puppetNodesAll	= #(),		--	Nodos de Tipo puppet TODOS
		facialNodesAll	= #(),		--	Nodos de Tipo facial TODOS
		facialEditNodesAll	= #(),		--	Nodos de Tipo facial TODOS
		animNodesAll	= #(),		--	Nodos de Tipo rig de animacion TODOS
		animEditNodesAll	= #(),		--	Nodos de Tipo rig de edición TODOS
		skinNodesAll	= #(),		--	Nodos de Tipo skin TODOS
		hairNodesAll	= #(),		--	Nodos de tipo hair TODOS
		clothNodesAll	= #(),		--	Nodos de Tipo cloth TODOS
		dynNodesAll	= #(),			--	Nodos de Tipo dynaminc TODOS
		fxNodesAll		= #(),		--	Nodos de Tipo fx TODOS
		lightNodesAll = #(),			--	Nodos de Tipo light TODOS
		connectNodesAll = #(),			--	Nodos de Tipo connect TODOS
		
		fxAtmospherics = #()	--	Atmosféricos de los assets de fx.
	)
	
	struct str_sceneAssetInfo
	(
		assetFiles = #(),
		camFiles = #(),
		camNames = #()
	)
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@struct: asset | Contiene todas las funciones de assets.
	------------------------------------------------------------------------------------------------------------------------------------------------
	struct lib_asset
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		def = (classof this),								--@var: def | Almacena la definicion del struct.
		defFile = getThisScriptFilename(),					--@var: defFile | Almacena la ruta del propio archivo de script que contiene la definicion.
		
		category = #main,									--@var: category | Categoria de la libreria.
		className = lb.getFileLibName (getThisScriptFilename() as string),	--@var: className | Nombre de la libreria.
		description = "Libreria de funciones de assets",	--@var: description | Descripcion de la libreria.
		
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		assetInfo = str_assetInfo,
		sceneAssetInfo = str_sceneAssetInfo,

		sceneAssets = #(),		--@var: sceneAssets | Almacena el array de assets de la escena
		listedAssets = #(),
		selAssets = #(),
		selAsset = undefined,
		assetFilters = #(),
		listedLayersObjs = #(),
		
		chrAssetColor = [234,204,165],
		prpAssetColor = [175,209,238],
		setAssetColor = [230,234,108],
		sprAssetColor = [193,234,161],
		litAssetColor = [141,7,58],
		fxAssetColor = [193,169,225],

		--Este array se rellena en el onLoad, hay clases que varían de unas veriones de max a otras.
		fxParticleFlowClasses = #(),

		------------------------------------------------------------------------------------------------
		--LIBRARIES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
			
		------------------------------------------------
		--GETS
		------------------------------------------------

		----------------------------------------------------------------------------------
		--	devuelve en un array todas las capas de la escena, si no lo consigue devuelve
		--	un array vacio. Si se especifica un filtro por tipo, solo devuelve las 
		--	capas de ese tipo
		----------------------------------------------------------------------------------
		fn getSceneLayers type:#all =
		(
			layers = #()
			
			--recorre las capas de la escena
			for i=1 to LayerManager.count do
			(
				layer = (LayerManager.getLayer (i-1))
				
				if (lb.nc.ncOK layer.name type:#layer) then
				(
					--si el tipo es por defecto devuelve todas
					if type == #all then
						append layers layer
					else --sino, solo devuelve las de ese tipo
					(
						layerParts = filterString layer.name "_"
						if layerParts[1] == (type As String) then
							append layers layer
					)
				)
			)
			
			layers
		),

		----------------------------------------------------------------------------------
		-- 	Devuelve la escena Xref del asset AST pasado por parámetro. Si no
		--	la encuentra devuelve UNDEFINED
		----------------------------------------------------------------------------------
		fn getAssetXRefScene ast = 
		(
			local assetXrefScene = undefined
			local xRefFound = false
			local i = 1
			
			while not xRefFound and i <= xRefs.getXRefFileCount() do
			(
				try ( xref = (xRefs.getXrefFile i) ) catch()
			
				if xref != undefined and classof xref == XRefScene then
				(
					try --ha habido que poner un try porque a veces is hay un xrefscene duplicado, durante la carga del archivo da error hasta que no lo lee
					(
						astName = filterstring (getfilenamefile xref.filename) "_"
						astName = astName[1] + "_" + astName[2]
						
						if astName == ast.fullName then
						(
							assetXrefScene = xref
							xRefFound = true
						)
					)
					catch()
				)
				
				i += 1
			)
			
			assetXrefScene
		),
		
		----------------------------------------------------------------------------------
		-- 	busca los nodos del asset con nombre ASSETNAME entre los XRefScenes
		--	que están cargados en la escena. Devuelve un array con los nodos.
		--	Si no encuentra nada devuelve un array vacío.
		----------------------------------------------------------------------------------
		fn getAssetNodesFromXrefScenes ast =
		(
			local nodes = #()
			
			xRef = this.getAssetXRefScene ast
			if xRef != undefined then nodes = xref.tree.children
			
			nodes
		),

		----------------------------------------------------------------------------------
		-- funcion que busca un posible asset principal a partir de un asset y de un array de assets
		-- necesita un asset DEPENDENTASSET del que buscar un principal
		-- necesita un array de assets ALLASSETS donde buscar el principal
		-- devuelve un asset si ha encontrado un asset principal para el DEPENDENTASSET
		-- devuelve UNDEFINED si no encuentra un asset del que depende DEPENDENTASSET
		--MODE: #byName --elige la dependencia por nombre; #byExistingDependency
		----------------------------------------------------------------------------------
		fn getMainAsset dependentAsset allAssets mode:#byName =
		(
			mainAsset = undefined --asset principal del pasado por parametro
			
			cont = 1 --contador
			flag = true --flag de parada
			
			--los sets no deben ser dependientes.
			if dependentAsset.type == lb.nc.NC_setPrefix then flag = false
			
			--recorre el array de assets buscando uno que sea el principal
			while flag and cont <= allAssets.count do
			(
				ast = allAssets[cont] --obtenemos el asset actual
				_process = true --flag para saber si el asset puede ser el principal o no
				
				-- el asset dependiente es un spr, su principal solo puede ser un spr
				if dependentAsset.type == lb.nc.NC_sprPrefix and ast.type != lb.nc.NC_sprPrefix then _process = false
				
				if _process and dependentAsset.fullName != ast.fullName then --comprobamos que no sea el mismo asset
				(
					--comprobamos que sea su dependiente
					--si el nombre de uno esta contenido en el otro, puede ser su dependiente
					--si el numero de copia es igual, unido a lo anterior, hacer que pueda ser su dependiente
					--si el folder de los dos assets es el mismo puede ser su dependiente
					if (dependentAsset.folder == ast.folder /*or dependentAsset.type == lb.nc.NC_fxPrefix*/) and (dependentAsset.copyNumber == ast.copyNumber) then 
					(
						case mode of
						(
							#byName:
							(
	 							--print dependentAsset.name; print ast.name; print "----"
								if (findString dependentAsset.name ast.name != undefined) then
								(
									mainAsset = ast
									flag = false
								)--if
							)
							
							#byExistingDependency:
							(
								if (dependentAsset.mainAsset == ast.fullname) then
								(
									mainAsset = ast
									flag = false
								)--if
							)
						)--case
					)--if
					--Miramos si es un archivo de fx (con lo que los assets serán dependientes) y si el asset es de la misma carpeta
					else if (dependentAsset.folder != undefined) and (matchPattern dependentAsset.folder pattern: "*\\rig\\fx\\") and (substituteString dependentAsset.folder "rig\\fx\\" "") == ast.folder then 
					(
						--Si además la segunda parte del nombre del posible principal está contenida en la del dependiente entonces será su principal.
						if (findString (filterString (filterString dependentAsset.fullName "_")[2] "#")[1] (filterString (filterString ast.fullName "_")[2] "#")[1]) != undefined then
						(
							--Por último miraremos si alguno tiene índice y si son iguales (#001)
							if dependentAsset.copyNumber == ast.copyNumber then
							(
								mainAsset = ast
								flag = false
							)
						)
					)
				)--if
				
				cont +=1
			)--while
			
			mainAsset
		),
		
		----------------------------------------------------------------------------------
		-- funcion que busca los assets dependientes de uno pasado por parametro
		-- necesita un asset MAINASSET del que buscar los dependientes
		-- necesita un array de assets ALLASSETS donde buscar los dependientes
		-- devuelve un array con los assets dependientes encontrados, si no encuentra devuelve un array vacio
		----------------------------------------------------------------------------------
		fn getDependentAssets mainAsset allAssets =
		(
			dependents = #()
			
			for ast in allAssets where (ast.isDependent and (ast.mainAsset == mainAsset.fullName)) do
				append dependents ast
					
			dependents
		),

		----------------------------------------------------------------------------------
		--busca en la escena todos los objetos que lleven link constraint, point constraint o emparentamiento a alguna pieza del asset
		--si esas piezas son de un asset, añade todos los objetos de ese asset al array de objetos a devolver
		--si no, añade las piezas sin mas al array
		--la funcion es recursiva y si encuentra un asset que esta lincado al actual llama de nuevo a la funcion con ese asset
		--para no entrar en una recursividad infinita una vez encontrado un asset, lo pasamos a la siguiente llamada recursiva para que no lo vuelva a coger
		--searchByLinkConstraint: por defecto a TRUE indica que va a buscar los dependientes en los targets de los link cosntraint
		--searchByPointConstraint: por defecto a TRUE indica que va a buscar los dependientes en los targets de los point cosntraint
		--searchByParent: por defecto a TRUE indica que va a buscar los dependientes en los padres de los objetos
		----------------------------------------------------------------------------------
		fn getAssetDependentLinkedObjects ast allAssets:#() assetsToIgnore:#() searchByLinkConstraint:true searchByPointConstraint:true searchByParent:true =
		(
			if allAssets.count == 0 then allAssets = this.getSceneAssets() --si no se ha pasado el parametro allAssets lo autoRellena
			append assetsToIgnore ast
			
			linkedObjs = #() --objetos dependientes porque están lincados al asset AST, o pertenecen a un asset que tiene alguna pieza lincada a AST
			
			astObjs = ast.nodes --objetos del asset pasados por parametro
			
			------------------------------------------------------------------------------------------------------------------------------
			--recorre los objetos que no son de AST y lleven link constraint
			if searchByLinkConstraint then
				for obj in objects where (findItem ast.nodes obj == 0) and (classof obj.transform.controller == Link_Constraint) do
				(
					lc = obj.transform.controller --almacena el controlador
					numT = lc.getNumTargets() --obtiene el numero de targets
						
					for i=1 to numT do --recorre los targets para ver si son del propio AST o no
					(
						target = lc.getNode i
						
						if target != undefined and (findItem astObjs target != 0) then --si el target no es world y pertenece al AST actual
							appendIfUnique linkedObjs obj	
					)--for numT
				)--for objects
			------------------------------------------------------------------------------------------------------------------------------

			------------------------------------------------------------------------------------------------------------------------------
			--recorre los objetos que no son de AST y lleven link constraint
			if searchByPointConstraint then
				for obj in objects where (findItem ast.nodes obj == 0) and (lb.links.pointConstraint.hasPCAttribute obj) do
				(
					_pcData = lb.links.pointConstraint.getPointData obj

					for i=1 to _pcData.pointLinks.count do
					(
						target = getNodeByName _pcData.pointLinks[i][2]
						targetPoint = getNodeByName _pcData.pointTargets[i][2]

						--si el target no es world y pertenece al AST actual
						if target != undefined and (findItem astObjs target != 0) then
						(
							appendIfUnique linkedObjs obj
							if targetPoint != undefined then appendIfUnique linkedObjs targetPoint --añade el point de lincaje
						)--if
					)--for
				)--for objects
			------------------------------------------------------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------------------------------------------------------
			--obtiene todos los objetos de otros assets que están emparentados a alguna pieza de este asset
			if searchByParent then
				for obj in objects where (obj.parent != undefined and (findItem astObjs obj) == 0 and (findItem astObjs obj.parent) != 0) do
				(
					appendIfUnique linkedObjs obj
				)--for
			------------------------------------------------------------------------------------------------------------------------------
			
			linkedAssets = this.getAssetsFromNodes linkedObjs --busca los assets completos de los objetos lincados
			
			--------------------------------------------------------------------------------
			--elimina de linkedAssets los que estén en assetsToIgnore
			assetsToIgnoreNames = for a in assetsToIgnore collect a.fullname
			for i=linkedAssets.count to 1 by -1 where (findItem assetsToIgnoreNames linkedAssets[i].fullname != 0) do
				deleteItem linkedAssets i
			--------------------------------------------------------------------------------
			
			for a in linkedAssets do
			(
				linkedObjs += a.nodes
				linkedObjs += this.getAssetDependentLinkedObjects a allAssets:allAssets assetsToIgnore:assetsToIgnore
			)--for linkedAssets
			
			makeUniqueArray linkedObjs
		),	
		
		----------------------------------------------------------------------------------
		--busca en la escena los objetos a los que pueda estar lincada alguna pieza del asset actual
		--si esos objetos son de un asset, coge todos los objetos de ese asset y luego llama a la funcion recursivamente por si a su vez estabalincado a otro objeto.
		--si no, añade la pieza al array
		--searchByLinkConstraint: por defecto a TRUE indica que va a buscar los dependientes en los targets de los link cosntraint
		--searchByParent: por defecto a TRUE indica que va a buscar los dependientes en los padres de los objetos
		----------------------------------------------------------------------------------
		fn getAssetParentLinkedObjects ast allAssets:#() assetsToIgnore:#() searchByLinkConstraint:true searchByPointConstraint:true searchByParent:true =
		(
			if allAssets.count == 0 then allAssets = this.getSceneAssets() --si no se ha pasado el parametro allAssets lo autoRellena
			append assetsToIgnore ast
			
			linkedObjs = #() --objetos a los que esta lincado el asset AST, o pertenecen a un asset al que esta lincado el actual
			
			astObjs = ast.nodes --objetos del asset pasados por parametro
			
			------------------------------------------------------------------------------------------------------------------------------
			--obtiene todos los nodos a los que esté lincado por link constraint alguna pieza del asset---------------------------
			if searchByLinkConstraint then
				for obj in astObjs where (classof obj.controller != XRef_Controller) and (classof obj.transform.controller == Link_Constraint) do
				(
					lc = obj.transform.controller --almacena el controlador
					numT = lc.getNumTargets() --obtiene el numero de targets
					
					for i=1 to numT do --recorre los targets para ver si son del propio AST o no
					(
						target = lc.getNode i
						
						if target != undefined and (findItem astObjs target == 0) then --si el target no es world y pertenece al AST actual
							appendIfUnique linkedObjs target
					)
				)--for
			------------------------------------------------------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------------------------------------------------------
			if searchByPointConstraint then 
			(
				for obj in astObjs where lb.links.pointConstraint.hasPCAttribute obj do
				(
					_pcData = lb.links.pointConstraint.getPointData obj

					for i=1 to _pcData.pointLinks.count do
					(
						target = getNodeByName _pcData.pointLinks[i][2]
						targetPoint = getNodeByName _pcData.pointTargets[i][2]

						--si el target no es world y pertenece al AST actual
						if target != undefined and (findItem astObjs target == 0) then
						(
							appendIfUnique linkedObjs target
							if targetPoint != undefined then appendIfUnique linkedObjs targetPoint --añade el point de lincaje
						)--if
					)--for
				)--for objects
			)
			------------------------------------------------------------------------------------------------------------------------------

			------------------------------------------------------------------------------------------------------------------------------
			--obtiene todos los objetos de otros assets a los que está emparentada alguna pieza de este asset
			if searchByParent then
				for obj in astObjs where (obj.parent != undefined and (findItem astObjs obj.parent) == 0) do
				(
					appendIfUnique linkedObjs obj.parent
				)--for
			------------------------------------------------------------------------------------------------------------------------------
				
			linkedAssets = this.getAssetsFromNodes linkedObjs --busca los assets completos de los objetos lincados
			
			--------------------------------------------------------------------------------
			--elimina de linkedAssets los que estén en assetsToIgnore
			assetsToIgnoreNames = for a in assetsToIgnore collect a.fullname
			for i=linkedAssets.count to 1 by -1 where (findItem assetsToIgnoreNames linkedAssets[i].fullname != 0) do
				deleteItem linkedAssets i
			--------------------------------------------------------------------------------
			
			for a in linkedAssets do
			(
				linkedObjs += a.nodes
				linkedObjs += this.getAssetParentLinkedObjects a allAssets:allAssets assetsToIgnore:assetsToIgnore
			)--for linkedAssets
			
			makeUniqueArray linkedObjs
		),

		----------------------------------------------------------------------------------
		--funcion que busca todos los assets del mismo grupo de dependencia
		--es decir, que si el assets pasado es un asset dependiente, busca el asset del que depende y todos los que dependen de este.
		--si no es dependiente devuelve los dependientes del asset pasado por parametro
		----------------------------------------------------------------------------------
		fn getDependencyGroup dependentAsset allAssets =
		(
			groupAssets = #()
			
			mainAsset = dependentAsset
				
			if dependentAsset.isDependent then
				mainAsset = this.getMainAsset dependentAsset allAssets mode:#byExistingDependency
			
			if mainAsset != undefined then
				groupAssets = join #(mainAsset) (this.getDependentAssets mainAsset allAssets)
			
			groupAssets
		),

		------------------------------------------------------------------------------------------------------------------------
		-- Lee la lista de assets de la cámara que se encuentra en el archivo de produccón de la secuencia.
		-- Devuelve los assets por fullname en un array. Si no encuentra nada devuelve el array vacío.
		-- Como parámetros recibimos el numero de secuencia y de cámara.
		-- Si queremos que nos devuelva las rutas entonces lo que haremos será pasarle la variable showPaths a true.
		------------------------------------------------------------------------------------------------------------------------
		fn getCamAssetsFromProdFile seqNumber camNumber showPaths:false =
		(
			--Prefijo del nombre de cada archivo
			_sourceFilePrefix = "seq_"
			--Caracter mediante el cual definimos que un asset existe para una cámara en concreto y otro que es el que separa el asset de su ruta
			_yesCharacter = "X"
			_separatorChar = "@"
			
			--Definimos una variable para devolver los nombres de los assets que encontremos.
			_result = #()
			
			--Si el numero de secuencia y de cámara son numeros positivos procederemos a buscar.
			if seqNumber != undefined and ((substring seqNumber 1 3) As Number) >= 0 and camNumber != undefined and (camNumber As Number) >= 0 then
			(
	 			--Eliminamos la parte decimal de los números
	 			--seqNumber = seqNumber As Integer
	 			--camNumber = camNumber As Integer
	 			
	 			----Rellenamos los valores de secuencia y cámara en dos variables con los ceros que les hagan falta para llegar a tres dígitos.
	 			--if seqNumber < 10 then _thisSeq = "00" + (seqNumber As String)
	 			--else if seqNumber < 100 then _thisSeq = "0" + (seqNumber As String)
	 			--else _thisSeq = (seqNumber As String)
	 			
	 			--if camNumber < 10 then _thisCam = "00" + (camNumber As String)
	 			--else if camNumber < 100 then _thisCam = "0" + (camNumber As String)
	 			--else _thisCam = (camNumber As String)
				
				_thisSeq = seqNumber
				_thisCam = camNumber
				
	 				--print _thisSeq
	 				--print _thisCam
				--<TEST>
				--_thisSeq = "007"
				--_thisCam = "010"
				--</TEST>
				
				--Miramos si existe el archivo de secuencia
				if doesFileExist (lb.nc.NC_assetPerSeqProdFilesPath + _sourceFilePrefix + _thisSeq + ".txt") then
				(
					--Una vez tenemos la cámara sacamos los elementos correspondientes a esa cámara.
					_stream = openfile (lb.nc.NC_assetPerSeqProdFilesPath + _sourceFilePrefix+_thisSeq + ".txt") mode:"r"
					
					--Nos creamos un flag.
					_found = false
					--Me creo un contador para almacenar el indice de nuestra cámara
					_camIndex = 0
					
					--Recorremos el archivo hasta que encontramos el EOF
					while not (eof _stream) and not _found do
					(
						--Vamos a buscar la lista de camaras primero.
						_line = readLine _stream
	 						--print _line
						--Filtramos por tabuladores.
						_line = filterString _line "\t"
						
						--Si hemos encontrado la lista de los numeros de cámara buscamos el índice de la nuestra
						if lb.math.isNumeric _line[1] then
						(
							for i=1 to _line.count do
								--Si encuentro una cámara que tenga el mismo numero que mi archivo entonces lo que haré será quedarme con su índice.
								if (_line[i] As Number) == (_thisCam As Number) then
								(
	 								--print ("Linea: " + _line As String)
									--Cojo el índice más uno porque el la fila de un asset está el nombre primero y todo se desplaza hacia la derecha un número.
									_camIndex = i+1
	 								--print ("Indice de cámara: " + _camIndex As String)
								)
						)
						--Si hemos encontrado otra línea
						else if _line[1] != undefined then
						(
							--Primero miraremos si tenemos ya el índice de la cámara.
							if _camIndex !=0 then
							(
	 							--print _line
								--Ahora miraremos que no se sale de rango
								if _line[_camIndex] != undefined then
								(
									--Sacamos si para la cámara obtenida está el asset actual
									if (toUpper _line[_camIndex]) == _yesCharacter then
									(
										--Si lo que quiero es que se devuelva la ruta del asset
										if showPaths then
										(
											--Si existe tal ruta la pondré sino devolveré una cadena vacía.
											if (filterString _line[1] _separatorChar)[2] != undefined then
												append _result (filterString _line[1] _separatorChar)[1]
											else
												append _result ""
										)
										else
										(
											append _result (filterString _line[1] _separatorChar)[1]
										)
									)
								)
								--Si nos salimos de rango en algún momento quiere decir que el archivo de producción está mal así que vaciamos el resultado
								--y activamos _found = true para salir del while.
								else
								(
									_found = true
									_result = #()
								)
							)
						)
						
					)
					--print _camIndex
				)
			)
			
			_result
		),

		----------------------------------------------------------------------------------
		-- obtiene todos los assets de la escena y los devuelve en un array de structs asset
		-- si se especifica TYPE, solo se obtienen los assets de ese tipo
		--TYPE puede ser un string con un tipo, o un array de strings con los tipos
		--(para ver los tipos de asset consultar el naming convention data)
		--reconoce si el asset es una copia del otro asset de la escena y lo almacena como propiedad en el struct de asset
		----------------------------------------------------------------------------------
		fn getSceneAssets type:#All =
		(
			local allAssets = #()
			
			--obtiene las capas de la escena
			layers = this.getSceneLayers()
			
			if layers.count != 0 then --si ha obtenido capas
				for layer in layers do --recorre las capas obtenidas
				(
					--Saco los nodos de la capa y la ignoro si no tiene nodos dentro.
					_nodes = #()
					layer.nodes &_nodes
					if lb.nc.ncOK layer.name type:#layer and (layer.name != "0") and (findItem lb.nc.NC_nonAssetLayers layer.name == 0) \
					and (findString layer.name lb.nc.NC_layerAux == undefined) and (_nodes != undefined) and (_nodes.count !=0 )then
					(
						layerParts = filterString layer.name "#"
						copyN = layerParts[2]
						layerParts = filterString layerParts[1] "_"
						flag = true
						
						if type != #All then
						(
							if classof type == String and layerParts[1] != type then
								flag = false
							if classof type == Array then
								if findItem type layerParts[1] == 0 then
									flag = false
						)
						
						if flag then --si ese layer tiene un asset del tipo solicitado
						(						
							newAsset = (this.assetInfo layer:layer)
							this.fillAssetInfo newAsset layer --rellena la informacion del asset
							append allAssets newAsset
						)
					)--if & for
				)
				
			-- devolvemos el array ordenado
			allAssets = this.sortAssets allAssets
			
			--busca las dependencias entre los assets de la escena y almacena esa informacion el cada asset	
			this.setAssetDependencies allAssets
			
			allAssets
		),
		
		----------------------------------------------------------------------------------
		--devuelve los assets de la escena que sean animables
		----------------------------------------------------------------------------------
		fn getSceneAnimAssets =
		(
			local allSceneAssets = if this.sceneAssets != undefined and this.sceneAssets.count != 0 then this.sceneAssets else this.getSceneAssets()
			local animAssets = #() --almacena los assets animables de la escena
			
			for ast in allSceneAssets do
				if ast.type != lb.nc.NC_setPrefix then
					append animAssets ast
				
			animAssets
		),
		
		----------------------------------------------------------------------------------
		--devuelve un array de assets con los assets de las piezas pasadas por parametro
		--necesita un array de nodos
		--si nodes esta vacio no devuelve un array vacio
		----------------------------------------------------------------------------------
		fn getAssetsFromNodes nodes invert:false =
		(
			local nodesAssets = #() --array para almacanar los assets seleccionados
			local localSceneAssets = #()
			if classOf nodes != array then nodes = #(nodes)
			
			localSceneAssets = this.getSceneAssets() --obtiene los assets de la escena
			
			--si hay piezas seleccionadas y assets en los que buscar
			if nodes.count != 0 and localSceneAssets.count != 0 then
			(
				local nodesAssetsName = #()
				
				--recorre los objetos seleccionados obteniendo el fullName de los assets seleccionados
				for obj in nodes do
					if lb.nc.ncOK obj.name then
					(
						local nameParts = filterString obj.name "_"
						local fullName = nameParts[1] + "_" + nameParts[2]
						
						if obj.layer.name == fullName then --si el objeto no esta en la capa del mismo nombre no puede pertencer a ese asset
							appendIfUnique nodesAssetsName fullName
					)
				
				--recorre los assets de la escena, comprobando si su fullName esta entre los seleccionados
				--si es asi, almacena ese asset en el array de assets a devolver
				for ast in localSceneAssets do
					if findItem nodesAssetsName ast.fullName != 0 then
					(
						if not invert then
							append nodesAssets ast
					)
					else
					(
						if invert then
							append nodesAssets ast
					)
			)
			
			nodesAssets
		),
		
		----------------------------------------------------------------------------------
		-- obtiene los objetos del aset pasado por parametro
		--si no tiene objetos devuelve un array vacio
		----------------------------------------------------------------------------------
		fn getAssetNodes ast =
		(
			nodes = #() --array con los nodos 
			
			--rellena el array de los nodos
			if ast != undefined then
				nodes = ast.nodes
			
			nodes
		),

		----------------------------------------------------------------------------------
		-- busca los objetos de un tipo dentro de un asset
		-- necesita el asset y el tipo/s buscado/s
		-- devuelve un array con los objetos de ese tipo
		--si no encuentra objetos de ese tipo o el asset es undefined devuelve un array vacio
		--si flags no esta vacio, devuelve solo los objetos de ese tipo que posean esos flags
		--flagsMode indica si se debe hacer un #and o un #or con los flags
		----------------------------------------------------------------------------------
		fn getAssetNodesByType ast type flags:#() flagsMode:#and excludeHidden:false excludeFrozen:false =
		(	
			returnNodes = #() --array para almacenar los nodos de ese tipo
			
			if this.assetInfo != undefined then
			(
				--types son los tipos de assets que queremos obtener
				types = type
				if classof types == String or classof types == name then types = #((types as string))
				
				defFlags = #() --conjunto definitivo de flags a buscar
				
				for f in flags do --recopila los flags definitivos que tiene que buscar
				(
					add = true
					
					if excludeHidden and f == lb.nc.NC_hiddenFlag then add = false
					if excludeFrozen and f == lb.nc.NC_frozenFlag then add = false				
					if add then append defFlags f
				)
				
				for t in types do--reocorre todos los nodos de los tipos seleccionados
				(
					typeNodesAll = #()
					
					case t of --obtiene los nodos de cada tipo solicitado para el asset pasado
					(
						--(lb.nc.NC_classDraft):		typeNodesAll	= ast.draftNodesAll
						(lb.nc.NC_classProxy):		typeNodesAll	= ast.proxyNodesAll
						(lb.nc.NC_classMesh):		typeNodesAll	= ast.meshNodesAll
						(lb.nc.NC_classMorph):		typeNodesAll	= ast.morphNodesAll
						(lb.nc.NC_classPuppet):		typeNodesAll	= ast.puppetNodesAll
						(lb.nc.NC_classFacial):		typeNodesAll	= ast.facialNodesAll
						(lb.nc.NC_classFacialEdit):	typeNodesAll	= ast.facialEditNodesAll
						(lb.nc.NC_classAnim):		typeNodesAll	= ast.animNodesAll
						(lb.nc.NC_classAnimEdit):	typeNodesAll	= ast.AnimEditNodesAll
						(lb.nc.NC_classSkin):		typeNodesAll	= ast.skinNodesAll
						(lb.nc.NC_classHair):		typeNodesAll	= ast.hairNodesAll
						(lb.nc.NC_classCloth):		typeNodesAll	= ast.clothNodesAll
						(lb.nc.NC_classDynamic):	typeNodesAll	= ast.dynNodesAll
						(lb.nc.NC_classFx):			typeNodesAll	= ast.fxNodesAll
						(lb.nc.NC_classLight):		typeNodesAll	= ast.lightNodesAll
						(lb.nc.NC_classConnect):	typeNodesAll	= ast.connectNodesAll
					)--case of
					
					if flags.count != 0 or excludeHidden or excludeFrozen then --si hay que obtener las piezas por flag
					(
						for obj in typeNodesAll do --recorre los nodos de ese tipo descartando lo que no queremos
						(
							objFlags = lb.nc.getFlags obj
							add = true
							
							if excludeHidden and findItem objFlags lb.nc.NC_hiddenFlag != 0 then add = false
							if excludeFrozen and findItem objFlags lb.nc.NC_frozenFlag != 0 then add = false
							
							if add and flags.count != 0 then --si hay que fijarse en flags especificos
							(
								if flagsMode == #and then --tiene que tener todos los flags del array de flags
								(
									for f in flags where findItem objFlags f == 0 do add = false
								)
								else if flagsMode == #or then --tiene que tener al menos un flag del array de flags
								(
									add = false
									for f in flags where findItem objFlags f != 0 do add = true
								)
							)--if flags.count
							
							if add then
								append returnNodes obj
						)					
					)
					else --si no se deben mirar los flags
						returnNodes += typeNodesAll
					
				)--for t			
				
			)--if asset
			
			returnNodes
		),
		
		----------------------------------------------------------------------------------
		--	obtiene las piezas animables de cada asset. Las piezas animables son las 
		--	que tienen el flag c o el d. Se pueden capturar las piezas animables 
		--	de tipo facial, anim, AnimEdit o ambas. Esto se indica en el parámetro TYPE, que 
		--	puede valer "anim", "AnimEdit, ""facial" o #all
		--	para poner "anim" se puede poner tambien lb.nc.NC_classAnim
		--	para poner "facial" se puede poner tambien lb.nc.NC_classFacial
		----------------------------------------------------------------------------------
		fn getAssetAnimNodes ast type excludeExtras:false =
		(
			local animNodes = #()
			local AnimEditNodes = #()
			local facialNodes = #()
			local extraNodes = #()
			local nodesToOperate = #()
			
			animNodes = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_controlFlag) flagsMode:#or
			animEditNodes = this.getAssetNodesByType ast #(lb.nc.NC_classAnimEdit) flags:#(lb.nc.NC_controlFlag) flagsMode:#or
			facialNodes = this.getAssetNodesByType ast #(lb.nc.NC_classFacial) flags:#(lb.nc.NC_controlFlag) flagsMode:#or
			extraNodes = this.getAssetNodesByType ast #(lb.nc.NC_classAnim,lb.nc.NC_classFacial) flags:#(lb.nc.NC_extraFlag)

			if type == lb.nc.NC_classAnim then join nodesToOperate animNodes
			if type == lb.nc.NC_classAnimEdit then join nodesToOperate AnimEditNodes
			if type == lb.nc.NC_classFacial then join nodesToOperate facialNodes
			if type == #all then nodesToOperate = animNodes + facialNodes + AnimEditNodes
			
			if excludeExtras then
			(
				for obj in extraNodes do
				(
					_index = finditem nodesToOperate obj
					if _index != 0 then
						deleteItem nodesToOperate _index
				)
			)
			
			nodesToOperate
		),

		----------------------------------------------------------------------------------
		--devuelve los targets de los point constraints del asset
		----------------------------------------------------------------------------------		
		fn getAssetPointConstraintTargets ast =
		(
			_pcTargets = #()

			_animNodes = this.getAssetAnimNodes ast #all --obtiene los nodos animables, que son los que pueden tener point constraint
			
			--recorre los nodos de animacion buscando los que tengan PC y obteniendo los targets
			for obj in _animNodes do			
			(
				_hasPC = false
				for m in obj.modifiers where not _hasPC and lb.links.pointConstraint.hasPCAttribute m do _hasPC = true

				--si tiene point constraint obtiene sus targets
				if _hasPC then
				(
					_pcData = lb.links.pointConstraint.getPointData obj

					if _pcData.pointTargets.count != 0 then
					(
						for pl in _pcData.pointTargets where ((getNodeByName pl[2]) != undefined) do append _pcTargets (getNodeByName pl[2])
					)--if					
				)--if 
			)--for

			_pcTargets
		),

		----------------------------------------------------------------------------------
		--devuelve los targets de los point constraints del asset
		----------------------------------------------------------------------------------		
		fn getAssetPointConstraintNodes ast =
		(
			_pcnodes = #()

			_animNodes = this.getAssetAnimNodes ast #all --obtiene los nodos animables, que son los que pueden tener point constraint
			
			--recorre los nodos de animacion buscando los que tengan PC y obteniendo los targets
			for obj in _animNodes do			
			(
				_hasPC = false
				for m in obj.modifiers where not _hasPC and lb.links.pointConstraint.hasPCAttribute m do _hasPC = true

				if _hasPC then append _pcnodes obj
			)--for

			_pcnodes
		),
		
		----------------------------------------------------------------------------------
		--	devuelve el node base o root del asset actual. Si no lo encuentra 
		--	devuelve undefined
		--si se pide que ignore la base solo devuelve los root
		----------------------------------------------------------------------------------
		fn getAssetRootNode ast ignoreBase:false =
		(
			nodeRoot = undefined 
			base = undefined
					
			if not ignoreBase then
			(
				_baseCandidates = (execute ("$'" + ast.fullName + "_" + lb.nc.NC_classAnim + "_*_base*'")) as array
				_baseCandidates += (execute ("$'" + ast.fullName + "_" + lb.nc.NC_classAnimEdit + "_*_base*'")) as array
				
				if _baseCandidates.count != 0 then --si ha encontrado candidatos para la base
				(
					--si hay un objeto que se llame base a secas, hay que quedarse con ese, si no, hay que coger el primero de la lista
					for _baseC in _baseCandidates do
					(
						_baseName = (filterString _baseC.name "_")[5]
						if _baseName == "base" then base = _baseC
					)--for
					
					if base == undefined then base = _baseCandidates[1] --si no ha encontrado base a secas coge el primero
					
					--EXCEPCION POR UNA PIEZA MAL NOMBRADA EN RIG, DEBIDO A QUE EN MODELADO LLAMARON AL OBJETO DE MESH COMO BASE
					if base != undefined and base.name == "prp_koponnenArm-hammer_rig_x_baseSuport_x_c" then base = undefined
					if base != undefined and base.name == "prp_koponnenArm-saw_rig_x_baseSuport_x_c" then base = undefined
				)--if
			)--if
				
			--	si se encuentra pieza Base, se devuelve esa pieza. Tiene prioridad sobre pieza Root.
			--	Si solo se encuentra una pieza Root, se devuelve como rootNode.
			if base != undefined then 
				nodeRoot = base
			else
			(
				_rootCandidates = (execute ("$'" + ast.fullName + "_" + lb.nc.NC_classAnim + "_*_root*'")) as array
				_rootCandidates += (execute ("$'" + ast.fullName + "_" + lb.nc.NC_classAnimEdit + "_*_root*'")) as array
				
				if _rootCandidates.count != 0 then --si ha encontrado candidatos para el root
				(
					--si hay un objeto que se llame root a secas, hay que quedarse con ese, si no, hay que coger el primero de la lista
					for _rootC in _rootCandidates do
					(
						_rootName = (filterString _rootC.name "_")[5]
						if _rootName == "root" then nodeRoot = _rootC
					)--for
					
					if nodeRoot == undefined then nodeRoot = _rootCandidates[1] --si no ha encontrado root a secas coge el primero
				)--if
					
				--if root != undefined then nodeRoot = root
			)
			
			if nodeRoot == undefined then --si no tiene pieza root, mira a ver si es un asset de tipo mesh para coger la pieza root
			(
				--los PRP de tipo mesh tienen que tener las mallas jerarquizadas, y la pieza padre de la jerarquia tiene que ser el root
				if ast.meshNodesAll.count != 0 then --si tiene geometria
					if ast.animNodesAll.count == 0 and ast.AnimEditNodesAll.count == 0 and ast.facialNodesAll.count == 0 and ast.facialEditNodesAll.count == 0 then --si no tiene piezas de rig
					(
						auxHierarchies = lb.rig.getHierarchiesFromNodes ast.meshNodesAll
						if auxHierarchies.count == 1 then
							nodeRoot = auxHierarchies[1][1]
					)
			)			
			
			nodeRoot 
		),

		----------------------------------------------------------------------------------
		--	devuelve el node base o root del asset actual. Si no lo encuentra 
		--	devuelve undefined
		----------------------------------------------------------------------------------
		fn getSPRrootNodes ast =
		(
			nodeRoots = #()
			
			roots = (execute ("$'" + ast.fullName + "_" + lb.nc.NC_classAnim + "_*_root*'")) as array
			if roots.count != 0 then nodeRoots = roots
			
			nodeRoots 
		),
		
		----------------------------------------------------------------------------------
		-- devuelve la posición media de todas las piezas del asset A
		-- Si no encuentra nodos en el asset devuelve UNDEFINED
		----------------------------------------------------------------------------------
		fn getAssetPosition a nodeRoot:undefined =
		(
			pos = [0,0,0]		-- Posición del asset
			zMin = 10000000	-- Altura mínima de las piezas del asset
			
			if nodeRoot == undefined then --obtiene el nodo root del asset
				nodeRoot = this.getAssetRootNode a 
			
			-- Si existe un nodo root devolvemos su posición como posición del asset
			if nodeRoot != undefined then
				pos = nodeRoot.transform.pos
			else	
			(
				-- 	si no existe un nodo root calculamos la media de posiciones de todas las piezas
				--	y la situamos en el punto más bajo del personaje para que esté en los pies.
				
				-- recopilamos en la variable NODES todos los objetos del asset
				nodes = a.nodes
				
				-- calculamos la media de posición
				if nodes.count > 0 then
				(
					for o in nodes where not o.isDeleted do
					(
						if o.min.z < zMin then zMin = o.min.z
						pos = pos + o.transform.position
					)
					
					pos = pos / nodes.count
					pos = [pos.x, pos.y, zMin]
				)
				else
					pos = undefined
			)
			
			pos
		),
		
		----------------------------------------------------------------------------------
		--obtiene la rotacion actual de el asset pasado por parametro
		----------------------------------------------------------------------------------
		fn getAssetRotation a nodeRoot:undefined =
		(
			rot = quat 1 --rotación del asset
			
			if nodeRoot == undefined then --obtiene el nodo root del asset
				nodeRoot = this.getAssetRootNode a 
			
			if nodeRoot != undefined then --si teiene nodo root, la rotación es la de ese nodo
				rot = nodeRoot.transform.rotation
			
			rot
		),	
		
		----------------------------------------------------------------------------------
		--obtiene la escala actual de el asset pasado por parametro
		----------------------------------------------------------------------------------
		fn getAssetScale a nodeRoot:undefined =
		(
			sca = [1,1,1] --escala del asset
			
			if nodeRoot == undefined then --obtiene el nodo root del asset
				nodeRoot = this.getAssetRootNode a 
			
			if nodeRoot != undefined then --si teiene nodo root, la rotación es la de ese nodo
				sca = nodeRoot.transform.scale
			
			sca
		),	
		
		----------------------------------------------------------------------------------
		--	Devuelve un número de copia para el asset AST según los assets iguales
		--	a AST que ya hubiera en la escena.
		----------------------------------------------------------------------------------
		fn getNewAssetCopyNumber ast =
		(
			copyNumber = -1		--  Número del que partimos para asignar como número de copia
			
			localSceneAssets = #() --array de assets con los que trabajar
			
			if this.sceneAssets != undefined and this.sceneAssets.count != 0 then
				localSceneAssets = this.sceneAssets --	Assets de la escena
			else
				localSceneAssets = this.getSceneAssets()	--	Assets de la escena
			
			assetsToWork = ast
			if classof ast != Array then assetsToWork = #(ast)
			
			for ast in assetsToWork do
			(			
				local assetName = ast.type + "_" + ast.name 	-- Nombre del asset que evaluamos sin sufijos de número de copia
				local depAssetsNames = #(assetName) --Array para meter todos los nombres de los assets dependientes del actual
				
				for i = 1 to localSceneAssets.count do
				(
					n = localSceneAssets[i].type + "_" + localSceneAssets[i].name
					if (n == assetName) then
					(
						depGroup = this.getDependencyGroup localSceneAssets[i] localSceneAssets
						for a in depGroup do (appendIfUnique depAssetsNames (a.type +"_" + a.name))
					)				
				)
				
				for i = 1 to localSceneAssets.count do
				(
					n = localSceneAssets[i].type + "_" + localSceneAssets[i].name
					
					if findItem depAssetsNames n != 0 then --si el nombre del asset coincide
					(
						if localSceneAssets[i].copyNumber >= copyNumber then
							copyNumber = localSceneAssets[i].copyNumber + 1
					)
				)
			)		
			
			copyNumber
		),

		----------------------------------------------------------------------------------
		--	obtiene la ruta completa del fichero que representa el ASSET pasado
		--	por parámetro. TYPE indica si queremos la ruta del fichero de animación,
		--	de mesh, facial o de cache (#anim, #mesh, #facial, #cache)
		----------------------------------------------------------------------------------
		fn getAssetFileName ast type = 
		(
			assetFileType = ""
			
			case type of
			(
				#anim:	assetFileType = "anim"
				#mesh:	assetFileType = "mesh"
				#facial:	assetFileType = "facial"
				#cache:	assetFileType = "cache"
			)
			
			version = formattedprint ast.version format:"02d"
			
			filename = ast.folder + "version\\" + ast.type + "_" + ast.name + "_" + assetFileType + "_v" + version + ".max"
			
			filename
		),

		----------------------------------------------------------------------------------
		--devuelve un array de strigs con las rutas de los archivos de los que provienen los objetos de asset montado
		----------------------------------------------------------------------------------
		fn getAssetNodeInfoFiles ast =
		(
			_assetNodeInfoFiles = #()

			for _node in ast.nodes where lb.nodeInfo.hasNodeInfo _node do appendIfUnique _assetNodeInfoFiles _node.nodeInfo.fileHistory[1]

			_assetNodeInfoFiles
		),

		----------------------------------------------------------------------------------
		--devuelve el estado de visualizacion de un asset en modo de String
		--"P":puppet, "P+H":puppet+head, "H":head, "S":skin, "S+B":skin+box, "":indeterminado
		----------------------------------------------------------------------------------
		fn getAssetVisMode ast =
		(
			mode = "" --string con el modo en el que se encuentra el asset
			
			----------------------------------------------------------------------------------
			--recopilas ciertas piezas del asset que neceistará para comprobar si estan visibles o no
			_assetRigAnimNodes  = (this.getAssetAnimNodes ast lb.nc.NC_classAnim)
			_assetRigHiddenNodes = (this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_hiddenFlag))
			_assetRigFrozenNodes = (this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_frozenFlag))
			_assetRigFrozenNotHiddenNodes = (this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
				
			_assetFacialAnimNodes  = (this.getAssetAnimNodes ast lb.nc.NC_classFacial excludeExtras:true)
			_assetFacialHiddenNodes = (this.getAssetNodesByType ast #(lb.nc.NC_classFacial) flags:#(lb.nc.NC_hiddenFlag))
			_assetFacialFrozenNodes = (this.getAssetNodesByType ast #(lb.nc.NC_classFacial) flags:#(lb.nc.NC_frozenFlag))
			----------------------------------------------------------------------------------
				
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo PUPPET
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos
				
				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				
				--comprobaciones sobre nodos de mesh
				if _isThisVisMode and ast.meshNodesAll.count != 0 do _isThisVisMode = ast.meshNodesAll[1].ishidden --si tiene nodos de mesh y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de rig
	 			--if _isThisVisMode do _isThisVisMode = (ast.rigNodesAll.count != 0) or (ast.animNodesAll.count != 0) --si no tiene nodos de rig no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigAnimNodes.count != 0 --si no tiene nodos de rig animables no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not _assetRigAnimNodes[1].ishidden --si los objetos de rig animables no estan visibles no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigHiddenNodes.count != 0 --si no tiene nodos de rig con flag de ocultos no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigHiddenNodes[1].ishidden --los nodos de rig con flag de ocultos deben estar ocultos
				if _isThisVisMode do _isThisVisMode = _assetRigFrozenNodes.count != 0 --si no tiene nodos de rig con flag de congelados no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigFrozenNodes[1].ishidden --los nodos de rig con flag de congelados deben estar ocultos
				if _isThisVisMode do for obj in ast.animNodesAll where _isThisVisMode and obj.boxmode do _isThisVisMode = false --si un solo nodo de rig esta en modo box, no esta en el modo
					
				--comprobaciones sobre nodos de facial
				if _isThisVisMode and ast.facialNodesAll.count != 0 do _isThisVisMode = ast.facialNodesAll[1].ishidden --si tiene nodos de facial y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de dinamicas
				--if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode and ast.clothNodesAll.count != 0 do _isThisVisMode = ast.clothNodesAll[1].ishidden --si tiene nodos de cloth y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de fx
				if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "P" 
			)--intenta averiguar si esta en modo PUPPET
			----------------------------------------------------------------------------------
			
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo PUPPET + HEAD
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos

				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				
				--comprobaciones sobre nodos de mesh
				if _isThisVisMode do _isThisVisMode = ast.meshNodesAll.count != 0 --si no tiene nodos de mesh no puede estar en el nodo
				if _isThisVisMode do --si tiene nodos de mesh, los del sistema de head deben estar visibles y el resto no
					for obj in ast.meshNodesAll where _isThisVisMode do --en cuanto encuentra un nodo que no cumple la condicion deja de entrar
						if lb.customAttributes.hasAttribute obj #skinConnectionInfo and obj.skinConnectionInfo.headSystem then
							_isThisVisMode = not obj.ishidden --si es del sistema de head tiene que estar visible
						else
							_isThisVisMode = obj.ishidden --si no es del sistema de facial debe estar oculto
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de rig
				if _isThisVisMode do _isThisVisMode = (ast.animNodesAll.count != 0) --si no tiene nodos de rig no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigAnimNodes.count != 0 --si no tiene nodos de rig animables no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not _assetRigAnimNodes[1].ishidden --si los objetos de rig animables no estan visibles no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigHiddenNodes.count != 0 --si no tiene nodos de rig ocultos no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigHiddenNodes[1].ishidden --los nodos de rig con flag de ocultos deben estar ocultos
				if _isThisVisMode do _isThisVisMode = _assetRigFrozenNodes.count != 0 --si no tiene nodos de rig congelados no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigFrozenNodes[1].ishidden --los nodos de rig con flag de congelados deben estar ocultos
				if _isThisVisMode do --si los nodos de rig que pertenecen al sistema de head no estan visibles y en modo box no puede estar en el modo
					for obj in ast.animNodesAll where _isThisVisMode do --en cuanto encuentra un nodo que no cumple la condicion deja de entrar
						if lb.customAttributes.hasAttribute obj #skinConnectionInfo and obj.skinConnectionInfo.headSystem then
							_isThisVisMode = (not obj.ishidden) and obj.boxmode --si es del sistema de head tiene que estar visible y en modo box
				
				--comprobaciones sobre nodos de facial
				if _isThisVisMode do _isThisVisMode = ast.facialNodesAll.count != 0 --tiene que tener nodos de facial
				if _isThisVisMode do _isThisVisMode = _assetFacialAnimNodes.count != 0 --si no tiene nodos de facial animables no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not _assetFacialAnimNodes[1].ishidden --si los objetos de facial animables no estan visibles no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetFacialHiddenNodes.count != 0 --si no tiene nodos de facial con flag de ocultos no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetFacialHiddenNodes[1].ishidden --los nodos de facial con flag de ocultos deben estar ocultos
				if _isThisVisMode do _isThisVisMode = _assetFacialFrozenNodes.count != 0 --si no tiene nodos de facial con flag de congelados no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetFacialFrozenNodes[1].ishidden --los nodos de facial con flag de congelados deben estar ocultos
					
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode and ast.clothNodesAll.count != 0 do _isThisVisMode = ast.clothNodesAll[1].ishidden --si tiene nodos de cloth y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de fx
				if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "P+H" 
			)--intenta averiguar si esta en modo PUPPET + HEAD
			----------------------------------------------------------------------------------
			
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo HEAD
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos

				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				
				--comprobaciones sobre nodos de mesh
				if _isThisVisMode do _isThisVisMode = ast.meshNodesAll.count != 0 --si no tiene nodos de mesh no puede estar en el modo
				if _isThisVisMode do --si tiene nodos de mesh, los del sistema de head deben estar visibles y el resto no
					for obj in ast.meshNodesAll where _isThisVisMode do --en cuanto encuentra un nodo que no cumple la condicion deja de entrar
						if lb.customAttributes.hasAttribute obj #skinConnectionInfo and obj.skinConnectionInfo.headSystem then
							_isThisVisMode = not obj.ishidden --si es del sistema de head tiene que estar visible
						else
							_isThisVisMode = obj.ishidden --si no es del sistema de facial debe estar oculto
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de rig
	 			--if _isThisVisMode and ast.rigNodesAll.count != 0 do _isThisVisMode = ast.rigNodesAll[1].ishidden --si tiene nodos de rig y estan visibles no puede estar en el modo
				if _isThisVisMode and ast.animNodesAll.count != 0 do _isThisVisMode = ast.animNodesAll[1].ishidden --si tiene nodos de rig y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de facial
				if _isThisVisMode do _isThisVisMode = ast.facialNodesAll.count != 0 --tiene que tener nodos de facial
				if _isThisVisMode do _isThisVisMode = _assetFacialAnimNodes.count != 0 --si no tiene nodos de facial animables no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not _assetFacialAnimNodes[1].ishidden --si los objetos de facial animables no estan visibles no puede estar en el modo
				if _isThisVisMode and _assetFacialHiddenNodes.count != 0 do _isThisVisMode = _assetFacialHiddenNodes[1].ishidden --los nodos de facial con flag de ocultos deben estar ocultos
				if _isThisVisMode and _assetFacialFrozenNodes.count != 0 do _isThisVisMode = _assetFacialFrozenNodes[1].ishidden --los nodos de facial con flag de congelados deben estar ocultos
					
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode and ast.clothNodesAll.count != 0 do _isThisVisMode = ast.clothNodesAll[1].ishidden --si tiene nodos de cloth y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de fx
				if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "H"
			)--intenta averiguar si esta en modo HEAD
			----------------------------------------------------------------------------------
			
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo SKIN + BOX
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos
				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				
				--comprobaciones sobre nodos de mesh
				if _isThisVisMode do _isThisVisMode = ast.meshNodesAll.count != 0 --si no tiene nodos de mesh, no puede estar en el modo
				if _isThisVisMode do
				(
					for _mesh in ast.meshNodesAll do
					(
						if findString (filterString _mesh.name "_")[7] lb.nc.NC_hiddenFlag == undefined then
							_isThisVisMode = not _mesh.ishidden --si los nodos de mesh no estan visibles no puede estar en el modo
					)
				)
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
				--comprobaciones sobre nodos de rig
				if _isThisVisMode do _isThisVisMode = (ast.animNodesAll.count != 0) --si no tiene nodos de rig no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigAnimNodes.count != 0 --si no tiene nodos de rig animables no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not _assetRigAnimNodes[1].ishidden --si los objetos de rig animables no estan visibles no puede estar en el modo
				if _isThisVisMode and _assetRigHiddenNodes.count != 0 do _isThisVisMode = _assetRigHiddenNodes[1].ishidden --los nodos de rig con flag de ocultos deben estar ocultos
				--if _isThisVisMode and _assetRigFrozenNodes.count != 0 do _isThisVisMode = _assetRigFrozenNodes[1].ishidden --los nodos de rig con flag de congelados deben estar ocultos
				if _isThisVisMode and _assetRigFrozenNotHiddenNodes.count != 0 do _isThisVisMode = not _assetRigFrozenNotHiddenNodes[1].ishidden --los nodos de rig con flag frozen pero sin flag hidden deben estar visibles 
				--comprobaciones sobre nodos de facial
				if _isThisVisMode and ast.facialNodesAll.count != 0 do _isThisVisMode = ast.facialNodesAll[1].ishidden --si tiene nodos de facial y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode and ast.clothNodesAll.count != 0 do _isThisVisMode = ast.clothNodesAll[1].ishidden --si tiene nodos de cloth y estan visibles no puede estar en el modo
				if _isThisVisMode and ast.clothNodesAll.count != 0 do --si tiene nodos de cloth, sus modificadores cloth deben estar desactivados
				(
					_inactive = true --flag para saber si hay algun cloth del asset inactivo
					
					for obj in ast.clothNodesAll where _inactive do
						for m in obj.modifiers where _inactive and classof m == Cloth do
							_inactive = not m.enabled
					
					_isThisVisMode = _inactive --si hay algun cloth inactivo no puede estar en el modo
				)
				
				--comprobaciones sobre nodos de fx
				--if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "S+B" 
			)--intenta averiguar si esta en modo SKIN + BOX
			----------------------------------------------------------------------------------

			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo BOX
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos
				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				
				--comprobaciones sobre nodos de mesh
				if _isThisVisMode do _isThisVisMode = ast.meshNodesAll.count == 0 --si tiene nodos de mesh, no puede estar en el modo
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
				--comprobaciones sobre nodos de rig
				if _isThisVisMode do _isThisVisMode = (ast.animNodesAll.count != 0) --si no tiene nodos de rig no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigAnimNodes.count != 0 --si no tiene nodos de rig animables no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not _assetRigAnimNodes[1].ishidden --si los objetos de rig animables no estan visibles no puede estar en el modo
				if _isThisVisMode and _assetRigHiddenNodes.count != 0 do _isThisVisMode = _assetRigHiddenNodes[1].ishidden --los nodos de rig con flag de ocultos deben estar ocultos
				--if _isThisVisMode and _assetRigFrozenNodes.count != 0 do _isThisVisMode = _assetRigFrozenNodes[1].ishidden --los nodos de rig con flag de congelados deben estar ocultos
				if _isThisVisMode and _assetRigFrozenNotHiddenNodes.count != 0 do _isThisVisMode = not _assetRigFrozenNotHiddenNodes[1].ishidden --los nodos de rig con flag frozen pero sin flag hidden deben estar visibles 
				--comprobaciones sobre nodos de facial
				if _isThisVisMode and ast.facialNodesAll.count != 0 do _isThisVisMode = ast.facialNodesAll[1].ishidden --si tiene nodos de facial y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode and ast.clothNodesAll.count != 0 do _isThisVisMode = ast.clothNodesAll[1].ishidden --si tiene nodos de cloth y estan visibles no puede estar en el modo
				if _isThisVisMode and ast.clothNodesAll.count != 0 do --si tiene nodos de cloth, sus modificadores cloth deben estar desactivados
				(
					_inactive = true --flag para saber si hay algun cloth del asset inactivo
					
					for obj in ast.clothNodesAll where _inactive do
						for m in obj.modifiers where _inactive and classof m == Cloth do
							_inactive = not m.enabled
					
					_isThisVisMode = _inactive --si hay algun cloth inactivo no puede estar en el modo
				)
				
				--comprobaciones sobre nodos de fx
				if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "B" 
			)--intenta averiguar si esta en modo BOX
			----------------------------------------------------------------------------------
			
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo CLOTH
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos
				
				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				
				--comprobaciones sobre nodos de mesh
				if _isThisVisMode and ast.meshNodesAll.count != 0 do _isThisVisMode = ast.meshNodesAll[1].ishidden --si tiene nodos de mesh y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de rig
	 			--if _isThisVisMode and ast.rigNodesAll.count != 0 do _isThisVisMode = ast.rigNodesAll[1].ishidden --si tiene nodos de rig y estan visibles no puede estar en el modo
				if _isThisVisMode and ast.animNodesAll.count != 0 do _isThisVisMode = ast.animNodesAll[1].ishidden --si tiene nodos de rig y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de facial
				if _isThisVisMode and ast.facialNodesAll.count != 0 do _isThisVisMode = ast.facialNodesAll[1].ishidden --si tiene nodos de facial y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode do _isThisVisMode = ast.clothNodesAll.count != 0 --sin no tiene nodos de cloth no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not ast.clothNodesAll[1].ishidden --si los nodos de cloth no estan visibles no puede estar en el modo
				if _isThisVisMode do --si hay cloths del asset inactivos o hay objetos del cloth ocultos o congelados no puede estar en el modo
					for obj in ast.clothNodesAll where _isThisVisMode do --recorre los nodos de cloth
						for m in obj.modifiers where _isThisVisMode and classof m == Cloth do --recorre los modificadores de cloth
						(
							_isThisVisMode = m.enabled --si el cloth no esta activo no puede estar en el modo
							
							if _isThisVisMode do --si estaba activo, comprueba que todos los nodos relacionados con el estan visibles y descongelados
							(
								_clothRefNodes = refs.dependentNodes m
								
								for o in _clothRefNodes where _isThisVisMode and (o.ishidden or o.isfrozen) do --si el objeto esta congelado u oculto no puede estar en el modo
									_isThisVisMode = false
							)--if
						)--for
				
				--comprobaciones sobre nodos de fx
				if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "C"
			)--intenta averiguar si esta en modo CLOTH
			----------------------------------------------------------------------------------
			
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo SKIN + CLOTH
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos
				
				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				
				--comprobaciones sobre nodos de mesh
				if _isThisVisMode do _isThisVisMode = ast.meshNodesAll.count != 0 --si no tiene nodos de mesh, no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not ast.meshNodesAll[1].ishidden --si los nodos de mesh no estan visibles no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not ast.meshNodesAll[1].isfrozen --si los nodos de mesh estan congelados no puede estar en el modo
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de rig
				if _isThisVisMode and ast.animNodesAll.count != 0 do _isThisVisMode = ast.animNodesAll[1].ishidden --si no tiene nodos de rig no puede estar en el modo
				if _isThisVisMode and _assetRigAnimNodes.count != 0 do _isThisVisMode = _assetRigAnimNodes[1].ishidden --si los objetos de rig animables no estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de facial
				if _isThisVisMode and ast.facialNodesAll.count != 0 do _isThisVisMode = ast.facialNodesAll[1].ishidden --si tiene nodos de facial y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode do _isThisVisMode = ast.clothNodesAll.count != 0 --si no tiene objetos de cloth no puede estar en modo skin+cloth
				if _isThisVisMode do
				(
					_inactive = false --flag para saber si hay algun cloth del asset inactivo
					
					for obj in ast.clothNodesAll where not _inactive do
						for m in obj.modifiers where not _inactive and classof m == Cloth do
							_inactive = not m.enabled
					
					_isThisVisMode = not _inactive --si hay algun cloth inactivo no puede estar en el modo
				)
					
				--comprobaciones sobre nodos de fx
				if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "S+C" 
			)--intenta averiguar si esta en modo SKIN + CLOTH
			----------------------------------------------------------------------------------
			
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo SKIN
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos
				
				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				--comprobaciones sobre nodos de mesh y proxy
				if _isThisVisMode and ast.proxyNodesAll.count == 0 do _isThisVisMode = (ast.meshNodesAll.count != 0) /*or (ast.draftNodesAll.count != 0)*/ --si no tiene nodos de proxy y no tiene nodos de mesh no puede estar en el modo
				
				--if _isThisVisMode and ast.draftNodesAll.count != 0 do _isThisVisMode = ast.meshNodesAll.count == 0 --si no tiene nodos de mesh y no tiene nodos de proxy no puede estar en el modo
				--if _isThisVisMode and ast.meshNodesAll.count != 0 do _isThisVisMode = ast.draftNodesAll.count == 0 --si no tiene nodos de mesh y no tiene nodos de proxy no puede estar en el modo
				--if _isThisVisMode and ast.draftNodesAll.count != 0 do _isThisVisMode = not ast.draftNodesAll[1].ishidden --si no tiene nodos de mesh y no tiene nodos de proxy no puede estar en el modo
				
				if _isThisVisMode and ast.meshNodesAll.count == 0 do _isThisVisMode = (ast.proxyNodesAll.count != 0) /*or (ast.draftNodesAll.count != 0)*/ --si no tiene nodos de mesh y no tiene nodos de proxy no puede estar en el modo
				if _isThisVisMode and ast.meshNodesAll.count != 0 do _isThisVisMode = not ast.meshNodesAll[1].ishidden --si los nodos de mesh estan ocultos no puede estar en el modo
				if _isThisVisMode and ast.proxyNodesAll.count != 0 do _isThisVisMode = not ast.proxyNodesAll[1].ishidden --si los nodos de proxy estan ocultos no puede estar en el modo
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de rig
	 			--if _isThisVisMode and ast.rigNodesAll.count != 0 do _isThisVisMode = ast.rigNodesAll[1].ishidden --si tiene nodos de rig y estan visibles no puede estar en el modo
				if _isThisVisMode and ast.animNodesAll.count != 0 do _isThisVisMode = ast.animNodesAll[1].ishidden --si tiene nodos de rig y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de facial
				if _isThisVisMode and ast.facialNodesAll.count != 0 do _isThisVisMode = ast.facialNodesAll[1].ishidden --si tiene nodos de facial y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode and ast.clothNodesAll.count != 0 do _isThisVisMode = ast.clothNodesAll[1].ishidden --si tiene nodos de cloth y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de fx
				if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "S"
			)--intenta averiguar si esta en modo SKIN
			----------------------------------------------------------------------------------
			
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo SKIN + MORPH (igual que SKIN pero con los morphs visibles)
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos
				
				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				--comprobaciones sobre nodos de mesh y proxy
				if _isThisVisMode and ast.proxyNodesAll.count == 0 do _isThisVisMode = (ast.meshNodesAll.count != 0) /*or (ast.draftNodesAll.count != 0)*/ --si no tiene nodos de proxy y no tiene nodos de mesh no puede estar en el modo
				
				--if _isThisVisMode and ast.draftNodesAll.count != 0 do _isThisVisMode = ast.meshNodesAll.count == 0 --si no tiene nodos de mesh y no tiene nodos de proxy no puede estar en el modo
				--if _isThisVisMode and ast.meshNodesAll.count != 0 do _isThisVisMode = ast.draftNodesAll.count == 0 --si no tiene nodos de mesh y no tiene nodos de proxy no puede estar en el modo
				--if _isThisVisMode and ast.draftNodesAll.count != 0 do _isThisVisMode = not ast.draftNodesAll[1].ishidden --si no tiene nodos de mesh y no tiene nodos de proxy no puede estar en el modo
				
				if _isThisVisMode and ast.meshNodesAll.count == 0 do _isThisVisMode = (ast.proxyNodesAll.count != 0) /*or (ast.draftNodesAll.count != 0)*/ --si no tiene nodos de mesh y no tiene nodos de proxy no puede estar en el modo
				if _isThisVisMode and ast.meshNodesAll.count != 0 do _isThisVisMode = not ast.meshNodesAll[1].ishidden --si los nodos de mesh estan ocultos no puede estar en el modo
				if _isThisVisMode and ast.proxyNodesAll.count != 0 do _isThisVisMode = not ast.proxyNodesAll[1].ishidden --si los nodos de proxy estan ocultos no puede estar en el modo
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = not ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de rig
	 			--if _isThisVisMode and ast.rigNodesAll.count != 0 do _isThisVisMode = ast.rigNodesAll[1].ishidden --si tiene nodos de rig y estan visibles no puede estar en el modo
				if _isThisVisMode and ast.animNodesAll.count != 0 do _isThisVisMode = ast.animNodesAll[1].ishidden --si tiene nodos de rig y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de facial
				if _isThisVisMode and ast.facialNodesAll.count != 0 do _isThisVisMode = ast.facialNodesAll[1].ishidden --si tiene nodos de facial y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode and ast.clothNodesAll.count != 0 do _isThisVisMode = ast.clothNodesAll[1].ishidden --si tiene nodos de cloth y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de fx
				if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de pelo
				if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "S+M"
			)--intenta averiguar si esta en modo SKIN
			----------------------------------------------------------------------------------
			
			
			----------------------------------------------------------------------------------
			--si todavia no se ha encontrado el modo de visualizacion en el que está el asset
			--intenta averiguar si esta en modo CONNECTALL
			if mode == "" do
			(
				_isThisVisMode = true --flag para saber si esta en el modos de visualizacion que buscamos
				
				----------------------------------------------------------------------------------
				--comprueba las cosas que descartarían este modo
				
				--comprobaciones sobre nodos de mesh
				if _isThisVisMode do _isThisVisMode = ast.meshNodesAll.count != 0 --si no tiene nodos de mesh, no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not ast.meshNodesAll[1].ishidden --si los nodos de mesh no estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de morph
				if _isThisVisMode and ast.morphNodesAll.count != 0 do _isThisVisMode = ast.morphNodesAll[1].ishidden --si tiene nodos de morph y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de skin
				if _isThisVisMode and ast.skinNodesAll.count != 0 do _isThisVisMode = ast.skinNodesAll[1].ishidden --si tiene nodos de skin y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de rig
				if _isThisVisMode do _isThisVisMode = (ast.animNodesAll.count != 0) --si no tiene nodos de rig no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = _assetRigAnimNodes.count != 0 --si no tiene nodos de rig animables no puede estar en el modo
				if _isThisVisMode do _isThisVisMode = not _assetRigAnimNodes[1].ishidden --si los objetos de rig animables no estan visibles no puede estar en el modo
				if _isThisVisMode and _assetRigHiddenNodes.count != 0 do _isThisVisMode = _assetRigHiddenNodes[1].ishidden --los nodos de rig con flag de ocultos deben estar ocultos
				if _isThisVisMode and _assetRigFrozenNodes.count != 0 do _isThisVisMode = _assetRigFrozenNodes[1].ishidden --los nodos de rig con flag de congelados deben estar ocultos
				
				--comprobaciones sobre nodos de facial
				if _isThisVisMode and ast.facialNodesAll.count != 0 do _isThisVisMode = ast.facialNodesAll[1].ishidden --si tiene nodos de facial y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de dinamicas
				if _isThisVisMode and ast.dynNodesAll.count != 0 do _isThisVisMode = ast.dynNodesAll[1].ishidden --si tiene nodos de dinamicas y estan visibles no puede estar en el modo
				
				--comprobaciones sobre nodos de cloth
				if _isThisVisMode and ast.clothNodesAll.count != 0 do --si tiene nodos de cloth, sus modificadores cloth deben estar activados
				(
					_inactive = false --flag para saber si hay algun cloth del asset inactivo
					
					for obj in ast.clothNodesAll where not _inactive do
						for m in obj.modifiers where not _inactive and classof m == Cloth do
							_inactive = not m.enabled
					
					_isThisVisMode = not _inactive --si hay algun cloth inactivo no puede estar en el modo
				)
				
				--comprobaciones sobre nodos de fx
				--if _isThisVisMode and ast.fxNodesAll.count != 0 do _isThisVisMode = ast.fxNodesAll[1].ishidden --si tiene nodos de fx y estan visibles no puede estar en el modo
					
				--comprobaciones sobre nodos de pelo
				--if _isThisVisMode and ast.hairNodesAll.count != 0 do _isThisVisMode = ast.hairNodesAll[1].ishidden --si tiene nodos de pelo y estan visibles no puede estar en el modo
				
				----------------------------------------------------------------------------------	
				
				--si no lo consigue descartar, decide que está en modo puppet
				if _isThisVisMode do mode = "CA" 
			)--intenta averiguar si esta en modo CONNECTALL
			----------------------------------------------------------------------------------
			
			mode
		),

		----------------------------------------------------------------------------------
		--	Devuelve el rango en el que está animado el asset. Si el asset tiene 
		--	padres que puedan animarlo los tiene en cuenta para animarlos.
		--	
		--	AST: El asset al que le comprobamos el rango.
		--	TIMERANGE: rango de fotogramas en el que se busca la animación del asset.
		--	ASSETSCHECKED: No hay que especificarlo . Se una para la recursividad.
		----------------------------------------------------------------------------------
		fn getAssetAnimRange ast timeRange:(interval animationRange.start animationRange.end) assetsChecked:#() =
		(
			_nodes = this.getAssetAnimNodes ast #all
			_startTime = 999999f
			_endTime = -999999f
			
			--	Calculamos el rango de animación de cada pieza y nos quedamos con el frame mínimo y máximo
			for o in _nodes do
			(
				_range = lb.animation.getAnimRange o timeRange:timeRange
				
				--	si el rango tiene 0 frames significa que no hay animación.
				if _range.start != _range.end then
				(
					if _range.start < _startTime then _startTime = _range.start
					if _range.end > _endTime then _endTime = _range.end
				)
			)
			
			appendIfUnique assetsChecked ast --impide que se use el mismo asset de forma recursiva y entre en bucle infinito
			
			--	Si hay assets a los que está lincado el actual se considera su rango de animación también.
			if this.sceneAssets == undefined then this.sceneAssets = this.getSceneAssets()
			_parentAssets = (this.getAssetsFromNodes (this.getAssetParentLinkedObjects ast allAssets:this.sceneAssets))
			
			--ignora los ancestros que ya han sido contemplados para evitar bucles infinitos	
			for i=_parentAssets.count to 1 by -1 do
			(
				_stop = false
				for _chkAst in assetsChecked where not _stop and _chkAst.fullname == _parentAssets[i].fullname do
				(
					_stop = true
					deleteItem _parentAssets i
				)--for
			)--for
				
			-- Buscamos también piezas a las que pueda estar enganchado el asset
			_parentNode = undefined
			_rootNodeController = (this.getAssetRootNode ast).controller
			
			if  classof _rootNodeController == link_constraint then
			(
				_numTargets = _rootNodeController.getNumTargets()
				for i = 1 to _numTargets where _rootNodeController.getFrameNo i >= timeRange.start and _rootNodeController.getFrameNo i <= timeRange.end do
					_parentNode = _rootNodeController.getNode i
			)		
			
			for pa in _parentAssets where finditem assetsChecked pa == 0 do 
			(
				appendIfUnique assetsChecked pa
				_parentAssetsAnimRange = this.getAssetAnimRange pa timeRange:timeRange assetsChecked:assetsChecked
				
				--	Vigilamos que haya rango de animación para considerarlo animado
				if (_parentAssetsAnimRange.end - _parentAssetsAnimRange.start) > 0 then
				(
					if _parentAssetsAnimRange.start < _startTime then _startTime = _parentAssetsAnimRange.start
					if _parentAssetsAnimRange.end > _endTime then _endTime = _parentAssetsAnimRange.end
				)
			)--for

			--	Si startTime sigue con el valor inicial significa que el asset no tiene animación. 
			--	Devolvemos un intervalo de longitud 0.
			if _startTime == 999999f then 
			(
				_startTime = timeRange.start
				_endTime = _startTime
			)
			
			--	Si había una pieza padre calculamos su rango de animación por si es mayor.
			if _parentNode != undefined then
			(
				_parentAnimRange = lb.animation.getAnimRange _parentNode timeRange:timeRange
				if _parentAnimRange.start < _startTime then _startTime = _parentAnimRange.start
				if _parentAnimRange.end > _endTime then _endTime = _parentAnimRange.end
			)
			
			interval _startTime _endTime
		),
		
		
		--Selection Sets--------------------------------------------------------------------
		
		----------------------------------------------------------------------------------
		--obtiene los objetos de un selection set
		--necesita el nombre del set de seleccion
		----------------------------------------------------------------------------------
		fn getSelSetObjects selectionSetName = 
		(
			oldSelSetObjs = #()
			
			if selectionSets[selectionSetName] != undefined then
				oldSelSetObjs = for obj in selectionSets[selectionSetName] collect obj
				
			oldSelSetObjs
		),

		----------------------------------------------------------------------------------------------
		--	Partiendo de un asset retorna sus materiales en un array
		----------------------------------------------------------------------------------------------
		fn getAssetMaterials ast = 
		(
			--Me creo un array para ir metiendo los materiales ahí.
			_assetMaterials = #()
			--Me recorro los nodos de mesh y los apilo en dicho array.
			_nodesWithMaterial = ast.meshNodesAll + ast.animNodesAll
			
			for i=1 to _nodesWithMaterial.count where _nodesWithMaterial[i].material != undefined do
				appendIfUnique _assetMaterials _nodesWithMaterial[i].material
			
			_assetMaterials
		),

		----------------------------------------------------------------------------------
		--devuelve el porcentaje de objetos ocultos de entre todos los de un array
		--devuelve el pordentaje de 0 a 100 en tipo float
		--si el array esta vacio devuelve 100
		----------------------------------------------------------------------------------
		fn getHiddenPercent nodes useHiddenFlag:false =
		(
			cont = 0 --contador de objetos ocultos
			nodesN = 0
			
			--recorre los nodos del array contando los ocultos
			for n in nodes do
			(
				if useHiddenFlag then
				(
					if lb.nc.hasFlag n lb.nc.NC_hiddenFlag then
					(
						if n.ishidden then cont +=1
						nodesN +=1
					)
				)
				else
					if not lb.nc.hasFlag n lb.nc.NC_hiddenFlag then
					(
						if n.ishidden then cont +=1
						nodesN +=1
					)
			)

			if cont != 0 then
				((cont*100)/nodesN) as float
			else if nodes.count != 0 then
				0
			else
				100.0
		),
		
		----------------------------------------------------------------------------------
		--devuelve el porcentaje de objetos congelados de entre todos los de un array
		--devuelve el pordentaje de 0 a 100 en tipo float
		--si el array esta vacio devuelve 100
		----------------------------------------------------------------------------------
		fn getFrozenPercent nodes useFrozenFlag:false =
		(
			cont = 0 --contador de objetos ocultos
			nodesN = 0
			
			--recorre los nodos del array contando los ocultos
			for n in nodes do
			(
				if useFrozenFlag then
				(
					if lb.nc.hasFlag n lb.nc.NC_frozenFlag then 
					(
						if n.isfrozen then cont +=1
						nodesN +=1
					)
				)
				else
					if not lb.nc.hasFlag n lb.nc.NC_frozenFlag then
					(
						if n.isfrozen then cont +=1
						nodesN +=1
					)
			)
			
			if cont != 0 then
				((cont*100)/nodesN) as float
			else if nodes.count != 0 then
				0
			else
				0
		),

		----------------------------------------------------------------------------------
		--	Indica si los nodos de tipo TYPE del ASSET pasado por parámetro 
		--	están ocultos o congelados. Devuelve una cadena de texto que puede valer 
		--	"F", "H", "HF" o "". F indica Frozen.	H indica Hidden
		----------------------------------------------------------------------------------
		fn getAssetNodesState ast type =
		(
			local state = ""
			local nodes = this.getAssetNodesByType ast type
			
			-- 	Si encontramos una sola pieza visible o descongelada, consideramos
			--	que todos los objetos de ese tipo lo están independientemente de su estado
			objVisibleFound = false
			objNotFrozenFound = false
			for i = 1 to nodes.count where (not objVisibleFound or not objNotFrozenFound) do
			(
				if not nodes[i].isHidden then objVisibleFound = true
				if not nodes[i].isFrozen then objNotFrozenFound = true
			)
			
			if not objVisibleFound then append state "H"
			if not objNotFrozenFound then append state "F"
			
			state
		),

		----------------------------------------------------------------------------------
		--	Indica si los nodos pasados en OBJS están ocultos o congelados. 
		--	Devuelve una cadena de texto que puede valer:
		--	"F", "H", "HF" o "". F indica Frozen.	H indica Hidden
		----------------------------------------------------------------------------------
		fn getNodesState nodes =
		(
			local state = ""
			
			-- 	Si encontramos una sola pieza visible o descongelada, consideramos
			--	que todos los objetos de ese tipo lo están independientemente de su estado
			objVisibleFound = false
			objNotFrozenFound = false
			for i = 1 to nodes.count where (not objVisibleFound or not objNotFrozenFound) do
			(
				if not nodes[i].isHidden then
					objVisibleFound = true
				if not nodes[i].isFrozen then 
					objNotFrozenFound = true
			)
			
			if not objVisibleFound then append state "h"
			if not objNotFrozenFound then append state "f"
			
			state
		),

		----------------------------------------------------------------------------------
		-- 	devuelve la ruta del Asset o UNDEFINED si no está definida
		----------------------------------------------------------------------------------
		fn getAssetFolder ast =
		(
			_folder = (if ast.folder != "" then ast.folder else undefined)
			
			_folder
		),
		

		fn getAssetIconFilesFromPath assetPath type:#default =
		(
			_iconFiles = #()
			_folder = getFilenamePath assetPath

			--Si nos han pasado la ruta completa del asset (.max) tendremos que coger la
			if (findString _folder "\\version") != undefined then
			(
				_folder = substring _folder 1 (findString _folder "\\version")
			)
			_typeStr = ""

			case type of
			(
				#default: _typeStr = ""
				#alpha: _typeStr = "a"
			)
			_astName = (filterString (getFilenameFile assetPath) "_")[1] + "_" + (filterString (getFilenameFile assetPath) "_")[2]
			_astName = substituteString _astName (":" + lb.nc.NC_layoutFileName) "" --quita del nombre la posible version layout, Ej: si se llama 'tadeo:layout' se queda con 'tadeo'
			

			if _folder != undefined then
			(
				_iconFiles = getFiles (_folder + "image\\sample\\" + _astName + "_sample.*")
			)
			else
			(
				-- si no hay definida ninguna ruta en la escena intentamos buscar los iconos en las carpetas de
				-- este fichero, por si no estuviéramos manejando el propio fichero del asset.				
				_iconFiles = getFiles (maxfilepath + "image\\sample\\" + _astName + "_sample.*")
			)
					
			_iconFiles
		),

		fn getAssetIconFromPath assetPath size:[25,25] =
		(
			_icon = undefined
			_iconFiles = this.getAssetIconFilesFromPath assetPath
			if _iconFiles.count > 0 then _icon = dotnetObject "System.Drawing.bitmap" ((dotnetclass "system.drawing.image").fromFile _iconFiles[1]) size.x size.y
			
			_icon
		),

		----------------------------------------------------------------------------------
		-- 	captura la ruta del icono del Asset con nombre N y devuelve el icono
		--	TYPE es un parametro opcional que indica si se busca el icono por defecto,
		--	el Alpha, etc. Puede valer #default o #alpha
		----------------------------------------------------------------------------------
		fn getAssetIconFiles ast type:#default =
		(
			_iconFiles = #()
			_folder = ast.folder
			
			_typeStr = ""
			
			case type of
			(
				#default: 	_typeStr = ""
				#alpha: 	_typeStr = "a"
			)
			
			_astName = (filterString ast.fullname "#")[1]
			_astName = substituteString _astName (":" + lb.nc.NC_layoutFileName) "" --quita del nombre la posible version layout, Ej: si se llama 'tadeo:layout' se queda con 'tadeo'

			if _folder != undefined then
			(
				_iconFiles = getFiles (_folder + "image\\sample\\" + _astName + "_sample.*")
			)
			else
			(
				-- si no hay definida ninguna ruta en la escena intentamos buscar los iconos en las carpetas de
				-- este fichero, por si no estuviéramos manejando el propio fichero del asset.				
				_iconFiles = getFiles (maxfilepath + "image\\sample\\" + _astName + "_sample.*")
			)
					
			_iconFiles
		),
		
		----------------------------------------------------------------------------------
		-- 	Devuelve el icono del asset pasado por parámetro. Si hay más de uno devuelve el primero.
		--	Si lo encuentra devuelve un bitmap de tamaño SIZE
		----------------------------------------------------------------------------------
		fn getAssetIcon ast size:[25,25] =
		(
			_icon = undefined
			_iconFiles = this.getAssetIconFiles ast
			
			if _iconFiles.count > 0 then _icon = dotnetObject "System.Drawing.bitmap" ((dotnetclass "system.drawing.image").fromFile _iconFiles[1]) size.x size.y
			
			_icon
		),

		----------------------------------------------------------------------------------
		--	devuelve un array de arrays, donde cada elemento del arary son objetos 
		--	con el mismo nombre (sin tener en cuenta prefijo y flags)
		----------------------------------------------------------------------------------
		fn getDuplicatedNameNodes nodes =
		(	
			names = #()
			namesShort = #()
			
			duplicated = #()
			
			for o in nodes do
			(
				index = findItem namesShort (lb.nc.getNameWithNoPrefix o.name noCaches:true noFlags:true)
				
				if index != 0 then
					append duplicated #(nodes[index],o)
				
				append names o.name
				append namesShort (lb.nc.getNameWithNoPrefix o.name noCaches:true noFlags:true)
			)
			
			duplicated
		),

		------------------------------------------------
		--SETS
		------------------------------------------------

		----------------------------------------------------------------------------------
		-- funcion que calcula las dependencias entre assets y almacena la informacion dentro de los assets
		-- necesita un array de assets ALLASSETS con el que realizar los calculos
		----------------------------------------------------------------------------------
		fn setAssetDependencies allAssets =
		(
			_sprIndependentAssets = #()
					
			--recorre todos los assets averiguando quienes son dependientes de quien
			for ast in allAssets do
			(
				mainAsset = this.getMainAsset ast allAssets --obtiene el asset principal del actual
				
				if mainAsset != undefined then --si hay asset principal es porque el actual es dependiente
				(
					ast.isDependent = true
					ast.mainAsset = mainAsset.fullName
				)
				else if ast.type == lb.nc.NC_sprPrefix then --si es principal y de tipo spr, lo almacena
				(
					append _sprIndependentAssets ast
				)--if else
			)--for
			
			-------------------------------------------------------------
			--si hay spr principales que no tengan dependientes, hacemos unoo dependientes del primero de ellos,
			--siempre que su origen sea el mismo archivo.
			
			--elimina los que tienen dependientes
			for i = _sprIndependentAssets.count to 1 by -1 where (this.getDependentAssets _sprIndependentAssets[i] allAssets).count > 0 do
				deleteItem _sprIndependentAssets i
			
			_sprIndependentAssetsByFolder = #() --array para almacenar los spr por archivo de procedencia
			_sprFolders = #()
			
			--agrupa los spr por archivo de procedencia
			for ast in _sprIndependentAssets do
			(
				_index = findItem _sprFolders ast.folder
				
				if _index != 0 then
				(
					append _sprIndependentAssetsByFolder[_index] ast
				)
				else
				(
					append _sprIndependentAssetsByFolder #(ast)
					append _sprFolders ast.folder
				)--if else
			)--for
			
			--una vez agrupados, hace que el primero de la lista sea el principal y el resto sus dependientes
			for astGrp in _sprIndependentAssetsByFolder do
				for i=2 to astGrp.count do
				(
					astGrp[i].isDependent = true
					astGrp[i].mainAsset = astGrp[1].fullName
				)--for for
			-------------------------------------------------------------
		),

		----------------------------------------------------------------------------------
		-- Asigna el número de copia COPYNUMBER al asset AST
		----------------------------------------------------------------------------------
		fn setAssetCopyNumber ast copyNumber =
		(
			local numStr = ""											--	Número que se le asignará a la copia en formato string
			local assetName = ast.type + "_" + ast.name	--	Nombre del asset sin sufijos de copia
			local assetNodes = ast.nodes						--	Piezas del asset
			
			-- convertimos el número asignado a la copia en texto con dos dígitos
			if copyNumber < 10 then 
				numStr = "00" + copyNumber as string
			else if copyNumber < 100 then 
				numStr = "0" + copyNumber as string
			else
				numStr = copyNumber as string
			
			newPrefix = assetName + "#" + numStr	-- Nuevo prefijo para piezas y layers
			
			-- renombrado de las piezas
			for i = 1 to assetNodes.count do
			(
				nodeName = assetNodes[i].name
				n = filterstring nodeName "_"
				if findString n[7] "01" != undefined then n[7] = substituteString n[7] "01" ""
				if n.count == lb.nc.NC_objectNamesLength then
					assetNodes[i].name = newPrefix + "_" + n[3] + "_" + n[4] + "_" + n[5] + "_" + n[6] + "_" + n[7]
			)
			
			--	renombrado del layer
			ast.layer.setName newPrefix
			
			--	nos aseguramos de que las piezas del asset quedan en la capa correspondiente. Hay
			--	casos como la carga de assets desde fichero en que puede que estén en otra capa temporalmente.
			for o in ast.nodes do ast.layer.addNode o	
			
			--	Actualizamos el asset
			ast.copyNumber = copyNumber
			ast.fullName = newPrefix
			ast.layer = l
		),

		----------------------------------------------------------------------------------
		--actualiza la visualizacion de un objeto a oculto o visible
		--necesita el objeto
		--necesita el estado
		--opcionalemente actua tambien sobre los objetos con flag oculto
		----------------------------------------------------------------------------------
		fn setHiddenState objs hidden includeHiddenFlag:false =
		(
			nodes = objs
			if classof objs != array then nodes = #(objs)
			
			if hidden then
				nodes.ishidden = true
			else
			(
				if includeHiddenFlag then
					nodes.ishidden = false
				else
					for o in nodes do
						o.isHidden = (lb.nc.hasFlag o lb.nc.NC_hiddenFlag)
			)
		),

		----------------------------------------------------------------------------------
		--actualiza el estado de bloqueo de un objeto a congelado o descongelado
		--nenecista el estado
		--necesita el objeto
		--opcionalmente actual tambien sobre los objetos con flag de congelado
		----------------------------------------------------------------------------------
		fn setFrozenState objs frozen includeFrozenFlag:false =
		(
			nodes = objs
			if classof objs != array then nodes = #(objs)
			
			if frozen then
				nodes.isfrozen = true
			else
			(
				if includeFrozenFlag then
					nodes.isfrozen = false
				else
					for o in nodes do
						o.isFrozen = (lb.nc.hasFlag o lb.nc.NC_frozenFlag)
			)
		),
		----------------------------------------------------------------------------------
		--activa/desactiva la visualizacion en modo caja de los nodos pasados
		--necesita NODES
		--necesita STATE: TRUE o FALSE para inidicar si activarloo desactivarlo
		--necesita IGNORESHAPES: TRUE o FALSE
		----------------------------------------------------------------------------------
		fn setBoxMode nodes state:true ignoreShapes:true onlyPuppetNodes:true =
		(
			nodes = deepCopy nodes
			nodes.boxmode = false --primero lo desactiva
			
			if state then --si hay que activarlo
			(
				if ignoreShapes then --si hay que hacerlo a todos los nodos menos a los shapes
				(
					--recorre los nodos eliminando los shapes del array
					for i=nodes.count to 1 by -1 where (superclassof nodes[i].baseobject) == shape do
						if lb.nc.ncOK nodes[i].name then
						(
							--si es un shape que no tiene flag C sino D, no debe hacer la excepcion. Y no eliminarlo del array.
							if lb.nc.hasFlag nodes[i] lb.nc.NC_controlFlag do deleteItem nodes i
						)
						else --si no cumple el naming convention y es un shape no debe ponerlo en modo box
							deleteItem nodes i
				)--if
				
				--si los nodos no llevan puppet no los pone en modo box
				--si los nodos no llevan puppet pero si falg F y C entonces tambien hay que ponerlos en modo box
				if onlyPuppetNodes then
				(
					for i=nodes.count to 1 by -1 do
					(
						_puppetFound = false
						
						if matchPattern nodes[i].name pattern:("*_*_*_*_*_*" + lb.nc.NC_controlFlag + "*") then
							_puppetFound = true
						
						if not _puppetFound then
							for m in nodes[i].modifiers do
								if matchPattern m.name pattern:"*Puppet*" then
									_puppetFound = true
							
						if not _puppetFound then deleteItem nodes i
					)
				)--if
				
				nodes.boxmode = state --activa el boxmode
			)
			else --si hay que desactivarlo lo hce con todos
				nodes.boxmode = state --desactiva el boxmode
		),

		----------------------------------------------------------------------------------
		--conecta o desconecta el rig de skin
		--connection indica si tiene que conectar o desconectar
		--includeHead indica si se tiene que conectar o desconectar tambien la cabeza
		--disableControllers indica si al desconectar se deben poner a 0 los pesos de los controladores de las piezas de Skin y a veces de Facial
		----------------------------------------------------------------------------------
		fn setSkinConnection ast connection includeHead:true affectControllers:true ignoreKeepConnected:false disableFFDs:false disableHair:false disableCloth:true =
		(
			/*print ("connection: " + (connection as string))
			print ("includeHead: " + (includeHead as string))
			print ("affectControllers: " + (affectControllers as string))
			print ("ignoreKeepConnected: " + (ignoreKeepConnected as string))
			print ("disableFFDs: " + (disableFFDs as string))
			print ("disableHair: " + (disableHair as string))
			print ("disableCloth: " + (disableCloth as string))
			print "---------------------------" --*/
			
			-------------------------------------------------------
			--desactiva el autokey 
			_bckpAnimState = animButtonState
			animButtonState = false
			-------------------------------------------------------
			
			-------------------------------------------------------
			--Modificadores que no se tienen que descativar en ningun caso
			_modNamesToIgnore = #("ProxyLow", "ProxyDelete")
			-------------------------------------------------------
				
			-------------------------------------------------------	
			--busca los objetos del asset y los distribuye por tipos
			
			_rigObjs = ast.animNodesAll
			_skinObjs = ast.skinNodesAll --for _b in asset.skinNodesAll where lb.skinConnectionInfo.hasSkinConnectionInfo _b collect _b
			_facialObjs = ast.facialNodesAll
			_disableObjs = ast.meshNodesAll
			
			_meshAndClothObjects = ast.clothNodesAll + ast.meshNodesAll
			_meshObjs = ast.clothNodesAll + ast.meshNodesAll + ast.hairNodesAll
				
			_disableObjs = ast.skinNodesAll + ast.meshNodesAll + ast.clothNodesAll + ast.hairNodesAll --resto de objetos del asset que hay que desactivar
			if includeHead then _disableObjs += _facialObjs --si se pide incluir la cabeza en el proceso
				
			_oNamesNoPrefix = #() --array para guardar los nombres de los objetos de OBJS sin prefijo ni flags
			for o in _rigObjs do append _oNamesNoPrefix (lb.nc.getNameWithNoPrefix o.name noCaches:true noFlags:true) --recorre rigObjs y extrae el nombre sin prefijos ni flags
			-------------------------------------------------------
			
			-------------------------------------------------------
			--busca una malla de referencia a la que dejar con un constraint todo el sistema de facial cuando esta en un modo de visualizacion que requiere que se quede quieto en el 0,0,0
			
			_meshReference = undefined
			if _meshReference == undefined and _meshObjs.count != 0 then
			(
				_forbiddenParts = #("eye","teeth","tongue","hair","head")
				for _obj in _meshObjs do
				(
					_useThis = true
					for _fbp in _forbiddenParts where findString _obj.name _fbp != undefined do _useThis = false
					
					if _useThis then _meshReference = _obj
				)--for
			)--if
			-------------------------------------------------------
			
			-------------------------------------------------------
			--CONEXION / DESCONEXION
			
			--recorre los objetos de skin conectando/desconectando y estableciendo los pesos de los controladores
			--si tiene informacion de conexion o desconexion realiza las operaciones
			for _obj in _skinObjs where lb.skinConnectionInfo.hasSkinConnectionInfo _obj do
			(
				--en caso de que haya que conectar o desconectar, el proceso difiere un poco
				case connection of
				(
					--DESCONEXION
					--en caso de que haya que desconectar hay que tener en cuenta otros parametros que pueden obligar a que los objetos se queden conectados
					false:
					(
						-------------------------------------------------------
						--EXCEPCIONES
						
						_ignore = false --flag para saber si ignorar algun objeto a la hora de desconectar
						
						--si no hay que incluir la cabeza y pertenece al sistema de cabeza, lo ignora
						if not includeHead and _obj.skinConnectionInfo.headSystem then _ignore = true
						
						--si el objeto requiere que se quede conectado y no se pide expresamente que se fuerce la desconexion, lo ignora para el proceso
						if (_obj.skinConnectionInfo.keepConnected and not ignoreKeepConnected) then _ignore = true
						-------------------------------------------------------
						
						--DESCONEXION
						if not _ignore then lb.skinConnectionInfo.setConnection _obj false
					)--false
					
					
					--CONEXION
					true:
					(
						--CONEXION
	 					--_obj.skinConnectionInfo.connect()
						lb.skinConnectionInfo.connect _obj true
					)--true
				)--case

				-------------------------------------------------------			
			)--for	
			-------------------------------------------------------
			
			-------------------------------------------------------
			--activacion / desactivacion de los controladores y de modificadores
			
			-------------------------------------------------------
			--EXCEPCIONES
			
			--flag para saber si hay que poner los pesos de los controladores a 0
			_disableControllers = true
			
			--si el proceso esta en modo desconexion y se ha pedido forzar que no se deshabiliten los controladores, se dejan conectados
			if not affectControllers and not connection then _disableControllers = false
			-------------------------------------------------------
			
			--ACTIVACION / DESACTIVACION
			if _disableControllers then
			(
				for _obj in _disableObjs do
				(
					-------------------------------------------------------
					--MODIFICADORES ESPECIALES	
					
					--si se fuerza deshabilitar FFDs
					if disableFFDs then for m in _obj.modifiers where classof m == FFD_Binding do m.enabled = connection
					
					--si se fuerza deshabilitar las malla de pelo
					if disableHair and (findString _obj.name "hair") != undefined then
						for m in _obj.modifiers where classof m == Skin do 
						(	m.enabled = connection
							m.enabledInViews = connection
						)
					-------------------------------------------------------
						
					-------------------------------------------------------
					--EXCEPCIONES
					
					_ignore = false --flag para saber si ignorar la activacion / desactivacion en funcion de algunos parametros por cada objeto
					_isFacialParent = false --para saber si es el objeto de facial parent, ya que hay operaciones que hacer o no hacer si es ese objeto
						
					--si tiene skinconnectionInfo hay alguna excepcion mas
					if lb.skinConnectionInfo.hasSkinConnectionInfo _obj then
					(
						--si es una pieza del sistema de cabeza y se ha pedido que no se incluya la cabeza en las operaciones, se ignora
						if _obj.skinConnectionInfo.headSystem and not includeHead then _ignore = true
						
						--si la pieza tiene marcado que se mantenga conectada la ignora en las operaciones
						if _obj.skinConnectionInfo.keepConnected then _ignore = true
						
						--si es el objeto de facial parent, no de debe ignorar y anula las excepciones anteriores si hubiese entrado en alguno de esos casos
						if findString _obj.name "_facialParent_" != undefined then
						(
							_ignore = false
							_isFacialParent = true
						)--if
					)--if
					
					--TO DO: ESTE OBJETO CREO QUE YA NO SE LLAMA ASI EN EL NUEVO SISTEMA DE RIG, CON LO CUAL HABRA QUE MIRAR SI ES NECESARIO ADAPTARLO
					--si es el punto de lookAt del sistema de rig de ojos, ignora las operaciones
					if findString _obj.name "facial_x_eyesLookAtPoint_x" != undefined then _ignore = true
					-------------------------------------------------------
					
					-------------------------------------------------------
					--ACTIVACION / DESACTIVACION
					if not _ignore then --si no se ignora la pieza
					(
						-------------------------------------------------------
						--activacion y desactivacion de MODIFICADORES
						
						--si es una desconexion los modificadores se desactivan de arriba a abajo segun se mira la pila
						if not connection then
						(
							/*for m in _obj.modifiers where lb.nc.hasFlag m lb.nc.NC_keepConnectedModifierFlag do
							(
								print "disconnect"
								print _obj.name
								print m.name
								print "----------------"
							)*/
							
							--recorre los modificadores del objeto y desactiva los que no lleven el falg de mantener activos y los que no esten en el array de modificadores intocables
							for m in _obj.modifiers where not lb.nc.hasFlag m lb.nc.NC_keepConnectedModifierFlag do
							(
								_flagMod = true
								if findItem _modNamesToIgnore m.name != 0 then _flagMod = false
								if _flagMod then m.enabled = connection
							)--for
						)
						else --si es una conexion los modificadores se desactivan de abajo aarriba segun se mira la pila
						(
							/*for m in _obj.modifiers where lb.nc.hasFlag m lb.nc.NC_keepConnectedModifierFlag do
							(
								print "connect"
								print _obj.name
								print m.name
								print "----------------"
							)*/
							
							-- Creamos 
							_disableInViewClassOf = #(turbosmooth)
							
							--recorre los modificadores del objeto y activa los que no lleven el falg de mantener activos y los que no esten en el array de modificadores intocables
							for i=_obj.modifiers.count to 1 by -1 where not lb.nc.hasFlag _obj.modifiers[i] lb.nc.NC_keepConnectedModifierFlag do
							(
								m = _obj.modifiers[i]
								_flagMod = true
								if findItem _modNamesToIgnore m.name != 0 then _flagMod = false
								if _flagMod then 
								(
									m.enabled = connection
									if findItem _disableInViewClassOf (classOf m) == 0 do m.enabledInViews = connection
								)
							)--for
						)--if else
						-------------------------------------------------------
						
						-------------------------------------------------------
						--activacion / desactivacion de CONTROLADORES
						
						lb.rig.setControllersWeight _obj connection					
						-------------------------------------------------------
						
						-------------------------------------------------------
						--si es el FACIAL PARENT hay que realizar operaciones especiales
						
						--crea constraints de rotacion y posicion con una pieza cualquiera de mesh que no sea de la cabeza, para que en modo desconexion se quede quieto en el 0,0,0 y no siga al hueso de la cabeza
						if _isFacialParent and _meshReference!= undefined then
						(
							--si es conexion quita los constraint a la malla de referencia
							if connection then
							(
								_stop = false
								for i=1 to _obj.rotation.controller.count where not _stop do
									if _obj.rotation.controller[i].name == "keepRot" or _obj.rotation.controller[i].name == "refRot" then
									(
										_obj.rotation.controller.delete i
										_stop = true
									)
									
								_stop = false
								for i=1 to _obj.position.controller.count where not _stop do
									if _obj.position.controller[i].name == "keepPos" or _obj.position.controller[i].name == "refPos" then
									(
										_obj.position.controller.delete i
										_stop = true
									)
							)
							else --si es desconexion pone los constraint a la malla de referencia para que el facial parent se quede quieto en el 0,0,0
							(
								--si tiene los constraints de referencia ya creados, les sube el peso
								if _obj.position.controller[#weights][#Weight__keepPos] != undefined and _obj.rotation.controller[#weights][#Weight__keepRot] != undefined then
								(							
									_obj.position.controller[#weights][#Weight__keepPos].value = 100
									_obj.rotation.controller[#weights][#Weight__keepRot].value = 100
								)
								else --si es la primera vez y no los tiene creados
								(
									_keepPos = Position_Constraint()
									_keepRot = Orientation_Constraint()
									
									_obj.position.controller.available.controller = _keepPos
									_obj.rotation.controller.available.controller = _keepRot
									
									_obj.position.controller.setName (_obj.position.controller.count) "keepPos"
									_obj.rotation.controller.setName (_obj.rotation.controller.count) "keepRot"
									
									_obj.position.controller["keepPos"].appendTarget _meshReference 100
									_obj.rotation.controller["keepRot"].appendTarget _meshReference 100
								)--if else
							)--if else						
						)--if
						-------------------------------------------------------
					)--if				
					-------------------------------------------------------
				)--for
			)--if
			-------------------------------------------------------
			
			-------------------------------------------------------
			--piezas de CLOTH
			
			--si se pide expresamente, desactiva los modificadores cloth de las piezas que lo lleven
			if disableCloth then
			(
				for _obj in _meshAndClothObjects do
					for m in _obj.modifiers where classof m == Cloth do m.enabled = false
			)--if		
			-------------------------------------------------------
			
			--si se pide expresamente, desactiva los modificadores hair de las piezas que lo lleven
			if disableHair then
			(
				--TO DO: se deja sin hacer de momento hasta ver como funciona hair farm, de todas formas este flag hacía referencia solo a mallas de pelo tipo casco.
			)--if		
			-------------------------------------------------------
			
			--VERSION DE SANTA
			/*-------------------------------------------------------
			--realiza la conexion o la desconexion
			if _skinObjs.count > 0 then
			(
				--recorremos todos los objetos de skin buscando si tienen headSystem y los guardamos para dejarlos activados en el modo correspondiente.
				_headSystemNodes = for _b in _skinObjs where _b.skinConnectionInfo.headSystem collect _b 							
				
				--realiza la conexion y establece los pesos de los controladores
				lb.skinConnectionInfo.setConnection _skinObjs connection
				lb.rig.setControllersWeight (_skinObjs + _facialObjs) connection
				
				-- Respecto si le decimos que no ignore el headSystem los dejamos activos.
				if not includeHead then
				(
					lb.skinConnectionInfo.setConnection _headSystemNodes true
					lb.rig.setControllersWeight (_headSystemNodes + _facialObjs) true
				)--if
			)--if
			-------------------------------------------------------
			
			-------------------------------------------------------
			--activa/desactica modificadores
			for _o in _meshAndClothObjects do
			(
				if not connection then --si es una desconexion los modificadores se desactivan de arriba a abajo segun se mira la pila
				(
					for m in _o.modifiers where not lb.nc.hasFlag m lb.nc.NC_keepConnectedModifierFlag do
					(
						flagMod = true
						
						if findItem _modNamesToIgnore m.name != 0 then flagMod = false
						
						if flagMod then
							m.enabled = connection
					)
				)
				else --si es una conexion, se activan de abajo a arriba segun la pila
				(
					for i= _o.modifiers.count to 1 by -1 where not lb.nc.hasFlag _o.modifiers[i] lb.nc.NC_keepConnectedModifierFlag do
					(
						m = _o.modifiers[i]
						flagMod = true
						
						if findItem _modNamesToIgnore m.name != 0 then flagMod = false
						
						if flagMod then
							m.enabled = connection
					)
				)--if else
			)--for
			-------------------------------------------------------
			--*/
			
			animButtonState = _bckpAnimState
		),
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en puppet del asset
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		----------------------------------------------------------------------------------
		fn setAssetSkinConnectionMode ast =
		(
			_connected = false
		
			for _o in ast.skinNodesAll where (lb.skinConnectionInfo.hasSkinconnectionInfo _o) and ((classOf _o == boneGeometry)) do
				_connected = lb.skinConnectionInfo.isConnected _o

			
			if _connected != undefined then
				this.setSkinConnection ast (not _connected) affectControllers:false ignoreKeepConnected:true
		),

		----------------------------------------------------------------------------------
		--modo de visualizacion en puppet del asset
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetPuppetMode ast disableSecPuppets:false =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "P" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--desactiva el modo box de las piezas de rig
				this.setBoxMode ast.animNodesAll state:false
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--oculta/muestra los puppets secundarios
				--si no hay que ocultarlos, solo mostraremos los puppets secundarios que hagan referencia a assets que estan en la escena
				if disableSecPuppets then this.hideSecPuppets ast
				else this.showSecPuppets ast
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--deconecta el rig de skin
				this.setSkinConnection ast false
				--------------------------------------------------------------------------------------------------------
			)--if asset != undefined
		),	
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en puppet + head del asset
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetPuppetHeadMode ast includeHead:false disableFFDs:false disableHair:false disableSecPuppets:false ignoreKeepConnected:false =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "PH" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--desactiva el modo box de las piezas de rig
				this.setBoxMode ast.animNodesAll state:false
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--oculta/muestra los puppets secundarios
				--si no hay que ocultarlos, solo mostraremos los puppets secundarios que hagan referencia a assets que estan en la escena
				if disableSecPuppets then this.hideSecPuppets ast
				else this.showSecPuppets ast
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--deconecta el rig de skin
				this.setSkinConnection ast true
				this.setSkinConnection ast false includeHead:includeHead disableFFDs:disableFFDs disableHair:disableHair ignoreKeepConnected:ignoreKeepConnected
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--muestra la parte del rig facial del personaje
				--hay que hacer esto despues de la conexion/desconexion del sistema de rig porque la desconexion deshabilita modificadores.
				this.showHeadSystem ast hideRigNodes:false
				--------------------------------------------------------------------------------------------------------
				
				this.showExtraControls ast #facial
			)--if asset != undefined
		),

		----------------------------------------------------------------------------------
		--modo de visualizacion en head del asset
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetHeadMode ast includeHead:false disableFFDs:false disableHair:false ignoreKeepConnected:false =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "H" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--deconecta el rig de skin
				this.setSkinConnection ast true
				this.setSkinConnection ast false includeHead:includeHead ignoreKeepConnected:ignoreKeepConnected disableFFDs:disableFFDs disableHair:disableHair
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--muestra la parte del rig facial del personaje
				--hay que hacer esto despues de la conexion/desconexion del sistema de rig porque la desconexion deshabilita modificadores.
				this.showHeadSystem ast --hideRigNodes:false
				--------------------------------------------------------------------------------------------------------
				
				this.showExtraControls ast #facial
			)--if asset != undefined		
		),
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en skin
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetSkinMode ast =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "S" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--conecta el rig de skin
				this.setSkinConnection ast true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--desactiva el modificador headSystem de las piezas de mesh
				for obj in ast.meshNodesAll where (lb.customAttributes.hasAttribute obj #skinConnectionInfo) and (obj.skinConnectionInfo.headSystem) do
				(
					--habilita el modificador headSystem si es que el mesh lo tiene para ocultar poligonos que sobren
					_headSystemMod = obj.modifiers[#headSystem]
					if _headSystemMod != undefined then _headSystemMod.enabled = false
				)--for
				--------------------------------------------------------------------------------------------------------

				--------------------------------------------------------------------------------------------------------
				--oculta drivers de pelo y shadows. muestra el draft
				for _node in ast.meshNodesAll do
				(
					_nodeNamePart5 = lb.nc.getNamePart _node.name 5

					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_draftPattern then _node.ishidden = false
					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_drvPattern then _node.ishidden = true
					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_shadowPattern then _node.ishidden = true
				)--for
				--------------------------------------------------------------------------------------------------------
			)--if ast != undefined		
		),
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en skin + box
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetSkinBoxMode ast disableSecPuppets:false =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "SB" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--activa el modo box de las piezas de rig
				this.setBoxMode ast.animNodesAll state:true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--oculta/muestra los puppets secundarios
				--si no hay que ocultarlos, solo mostraremos los puppets secundarios que hagan referencia a assets que estan en la escena
				if disableSecPuppets then this.hideSecPuppets ast
				else this.showSecPuppets ast
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--conecta el rig de skin
				this.setSkinConnection ast true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--desactiva el modificador headSystem de las piezas de mesh
				for obj in ast.meshNodesAll where (lb.customAttributes.hasAttribute obj #skinConnectionInfo) and (obj.skinConnectionInfo.headSystem) do
				(
					--habilita el modificador headSystem si es que el mesh lo tiene para ocultar poligonos que sobren
					_headSystemMod = obj.modifiers[#headSystem]
					if _headSystemMod != undefined then _headSystemMod.enabled = false
				)--for
				--------------------------------------------------------------------------------------------------------

				--------------------------------------------------------------------------------------------------------
				--oculta drivers de pelo y shadows. muestra el draft
				for _node in ast.meshNodesAll do
				(
					_nodeNamePart5 = lb.nc.getNamePart _node.name 5
					
					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_draftPattern then _node.ishidden = false
					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_drvPattern then _node.ishidden = true
					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_shadowPattern then _node.ishidden = true
				)--for
				--------------------------------------------------------------------------------------------------------
				
				this.showExtraControls ast #anim
			)--if ast != undefined
		),

		----------------------------------------------------------------------------------
		--modo de visualizacion en skin + box
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetBoxMode ast disableSecPuppets:false =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "B" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--activa el modo box de las piezas de rig
				this.setBoxMode ast.animNodesAll state:true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--oculta/muestra los puppets secundarios
				--si no hay que ocultarlos, solo mostraremos los puppets secundarios que hagan referencia a assets que estan en la escena
				if disableSecPuppets then this.hideSecPuppets ast
				else this.showSecPuppets ast
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--conecta el rig de skin
				this.setSkinConnection ast true
				--------------------------------------------------------------------------------------------------------
										
				this.showExtraControls ast #anim
			)--if ast != undefined
		),
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en cloth del ast
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetClothMode ast =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "C" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
					
				--------------------------------------------------------------------------------------------------------
				--conecta el rig de skin
				this.setSkinConnection ast true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--activa los objetos del asset que llevan cloth y todos los objetos de colision relacionados con ellos los deja visibles y descongelados
				
				--obtiene todos los objetos que llevan cloth de ese asset y los deja visibles y descongelados
				_clothMods = #() --cloths del asset, que hay que activar
				_allCloths  = getClassInstances Cloth --obtiene todos los cloth de la escena
				_thisAssetClothDepObjs = #() --array para meter los objetos dependientes de los cloth del asset actual
					
				for clth in _allCloths do --recorre los cloths obtenidos de la escena
				(
					_allClothDeps = refs.dependentNodes clth --obtiene todos los objetos dependientes de ese clothfx
					
					_stop = false --flag de parada
					for obj in _allClothDeps where not _stop do --recorre los objetos dependientes del cloth buscando alguno del asset actual
						if findItem ast.nodes obj != 0 then
						(
							_stop = true --activa el flag de parada para que no recorra mas objetos de ese array, porque ya sabe que el cloth pertenece a ese asset.
							_thisAssetClothDepObjs += _allClothDeps --almacena esos objetos como los de cloth de este asset
							append _clothMods clth --añade el modificador de cloth actual al array de modificadores de cloth del asset
						)--if
				)--for
				
				--deja visibles y descongelados los objetos con cloth de ese asset y activa los cloths del asset
				_clothMods.enabled = true
				_thisAssetClothDepObjs.ishidden = false
				_thisAssetClothDepObjs.isfrozen = false
				--------------------------------------------------------------------------------------------------------
			)--if asset != undefined
		),	
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en skin + cloth
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetSkinClothMode ast =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "SC" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--conecta el rig de skin
				this.setSkinConnection ast true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--desactiva el modificador headSystem de las piezas de mesh
				for obj in ast.meshNodesAll where (lb.customAttributes.hasAttribute obj #skinConnectionInfo) and (obj.skinConnectionInfo.headSystem) do
				(
					--habilita el modificador headSystem si es que el mesh lo tiene para ocultar poligonos que sobren
					_headSystemMod = obj.modifiers[#headSystem]
					if _headSystemMod != undefined then _headSystemMod.enabled = false
				)--for
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--activa los modificadores cloth que lleven las piezas de mesh de ese ast
				for obj in (ast.meshNodesAll + ast.clothNodesAll) do
					for m in obj.modifiers where classof m == Cloth do
						m.enabled = true
				--------------------------------------------------------------------------------------------------------
			)--if ast != undefined	
			
			/* if ast != undefined then
			(
				---------------------------------------------------------------------------------------------------------
				--obtiene todos los objetos que llevan cloth de ese ast y los deja visibles y descongelados
				_clothMod = undefined --cloth que hay que activar
				_allCloths  = getClassInstances Cloth --obtiene todos los cloth de la escena
					
				_stop = false --flag de parada
				for clth in _allCloths where not _stop do --recorre los cloths obtenidos de la escena
				(
					_allClothDeps = refs.dependentNodes clth --obtiene todos los objetos dependientes de ese clothfx
					
					for obj in _allClothDeps where not _stop do --recorre los objetos dependientes del cloth buscando alguno del asset actual
						if findItem ast.nodes obj != 0 then
						(
							_stop = true
							_clothMod = clth
						)--if
				)--for
				---------------------------------------------------------------------------------------------------------
				
				---------------------------------------------------------------------------------------------------------
				--si no hya objetos de cloth en el asset lo deja como esta, no hace nada
				
				if _clothMod != undefined then
				(
					objsToHide = #() --array de objetos del asset que debe ocultar
					objsToVis = #() --array de objetos del asset que debe dejar visibles
					visTypes = #()
					
					case ast.type of
					(
						"chr": --si es un personaje
						(
							objsToHide = ast.rigNodesAll + ast.skinNodesAll + ast.facialNodesAll + ast.dynNodesAll + ast.clothNodesAll
							visTypes = #(lb.nc.NC_classMesh)
							objsToVis = ast.meshNodesAll
						)
						
						"prp": --si es un personaje
						(
							objsToHide = ast.rigNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll
							visTypes = #(lb.nc.NC_classMesh)
							objsToVis = ast.meshNodesAll
						)
						
						"spr": --si es un personaje
						(
							objsToHide = ast.rigNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll
							visTypes = #(lb.nc.NC_classMesh)
							objsToVis = ast.meshNodesAll
						)
					)
					
					objsToHide.ishidden = true
					
					objsToVis.ishidden = false
					objsToVis.isfrozen = false
					
					meshObjs = ast.meshNodesAll
					--meshObjs.isfrozen = true
					
					auxObjs = this.getAssetNodesByType ast visTypes flags:#(lb.nc.NC_hiddenFlag)
					auxObjs.ishidden = true
					auxObjs.isfrozen = true
					auxObjs = this.getAssetNodesByType ast visTypes flags:#(lb.nc.NC_frozenFlag)
					auxObjs.isfrozen = true
					
					headSystemModifier = undefined
					for m in meshObjs do
						if lb.customAttributes.hasAttribute m #skinConnectionInfo then
							if m.skinConnectionInfo.headSystem then
								for x in m.modifiers where x.name == "headSystem" do
									headSystemModifier = x
					
					this.setSkinConnection ast true
					
					if headSystemModifier != undefined then
						headSystemModifier.enabled = false
					
					---------------------------------------------------------------------------------------------------------
					--deja visibles y descongelados los objetos con cloth y lo activa
					_clothMod.enabled = true
					
	 				--_thisAssetTurbosmooths = #() --array para almacenar los turbosmooths de este ast
	 				--for obj in ast.meshNodesAll do --recorre los mesh del ast
	 					--for m in obj.modifiers where classof m == TurboSmooth do --recorre los TurboSmooth
	 						--appendIfUnique _thisAssetTurbosmooths m
	 				
	 				--_thisAssetTurbosmooths.enabled = true --activa los TurboSmooth
	 				--_thisAssetTurbosmooths.enabledInViews = true --activa los TurboSmooth
					---------------------------------------------------------------------------------------------------------
				)
			) */
		),
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en hair del ast
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetHairMode ast =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "F" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
					
				--------------------------------------------------------------------------------------------------------
				--conecta el rig de skin
				this.setSkinConnection ast true
				--------------------------------------------------------------------------------------------------------
			)--if ast != undefined
		),	
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en skin + hair
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetSkinHairMode ast =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				
				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "SF" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--conecta el rig de skin
				this.setSkinConnection ast true
				--------------------------------------------------------------------------------------------------------
			)--if asset != undefined	
		),
		
		----------------------------------------------------------------------------------
		--modo de visualizacion en skin + hair + video
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetSkinHairVideoMode ast hairGeneratePercent:60 =
		(
			if ast != undefined then
			(
				this.setAssetSkinMode ast

				--ahora recorre los objetos de hair y mesh ocultando los que no queremos que se vean, haciendo visibles los que si y poniendo la visualizacion de los pelos en alta
				
				for _node in ast.meshNodesAll do
				(
					_nodeNamePart5 = lb.nc.getNamePart _node.name 5

					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_draftPattern then _node.ishidden = true
					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_drvPattern then _node.ishidden = true
					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_shadowPattern then _node.ishidden = true
				)--for

				for _node in ast.hairNodesAll do
				(
					_nodeNamePart5 = lb.nc.getNamePart _node.name 5

					if MatchPattern _nodeNamePart5 pattern:lb.nc.NC_HAIR_scalpPattern then
					(
						_node.ishidden = false
						--_hairPolyStripsMod = undefined

						for m in _node.modifiers do
						(
							if classof m == Hair_Display then
							(
								m.displayMode = 0
								m.viewportSteps = 1
								m.hideRootObjectInViewports = true
							)

							if classof m == Hair_Generate then
							(
								m.showAllHairs = false
								m.viewportPercentage = hairGeneratePercent

								_mat = m.material
								if _mat != undefined and classof _mat == Multimaterial then
								(
									_subMat = _mat.materialList[1]

									if _subMat != undefined and classof _subMat != Multimaterial then
									(
										_hairColor = _subMat.Diffuse --transmittanceColor
											
										if classof _subMat.diffuseMap == Hair_Color_Variation then
										(
											_hairColor = _subMat.diffuseMap.color

											if classof _subMat.diffuseMap.map == Gradient_Ramp then
											(
												_hairColor = _subMat.diffuseMap.map.Gradient_Ramp.Flag__2.color
											)--if
										)--if

										_subMat.Diffuse = _hairColor
										_subMat.ambient = _hairColor
									)							
								)--if
							)

							if classof m == HairMesh_Edit then
							(
								m.OverwriteViewSettings = on

								_hairColor = undefined
								_mat = _node.material
								if _mat != undefined and classof _mat == Multimaterial then
								(
									_subMat = _mat.materialList[1]
									if _subMat != undefined and classof _subMat == Multimaterial then
									(
										_subSubMat = _subMat.materialList[1]
										_hairColor = _subSubMat.Diffuse --transmittanceColor
										
										if classof _subSubMat.diffuseMap == Hair_Color_Variation then
										(
											_hairColor = _subSubMat.diffuseMap.color

											if classof _subSubMat.diffuseMap.map == Gradient_Ramp then
											(
												_hairColor = _subSubMat.diffuseMap.map.Gradient_Ramp.Flag__2.color
											)--if
										)--if

										_subSubMat.Diffuse = _hairColor
										_subSubMat.ambient = _hairColor
									)--if
								)--if

								if _hairColor != undefined then
								(
									_node.wireColor = _hairColor
									m.hairMeshColor = _hairColor
								)
							)--if

							/*if classof m == HairTo_PolyStrips then
							(
								_hairPolyStripsMod = m
							)*/
						)--for

						/*if _hairPolyStripsMod == undefined then
						(
							_hairPolyStripsMod = HairTo_PolyStrips()
							addmodifier _node _hairPolyStripsMod
						)--if

						_subParts = filterstring _nodeNamePart5 "-"

						if _hairPolyStripsMod != undefined then
						(
							_hairPolyStripsMod.thicknessMultiplier = 10
							if _subParts[3] == lb.nc.NC_HAIR_hair then _hairPolyStripsMod.thicknessMultiplier = 35
							if (_subParts[3] == lb.nc.NC_HAIR_eyebrow) or (_subParts[3] == lb.nc.NC_HAIR_eyebrows) then _hairPolyStripsMod.thicknessMultiplier = 10
							if (_subParts[3] == lb.nc.NC_HAIR_arm) or (_subParts[3] == lb.nc.NC_HAIR_arms) then _hairPolyStripsMod.thicknessMultiplier = 5
							if (_subParts[3] == lb.nc.NC_HAIR_beard) or (_subParts[3] == lb.nc.NC_HAIR_moustache) then _hairPolyStripsMod.thicknessMultiplier = 5
						)--if*/
	
						--if (_subParts[3] != lb.nc.NC_HAIR_hair) and (_subParts[3] != lb.nc.NC_HAIR_eyebrow) and (_subParts[3] != lb.nc.NC_HAIR_eyebrows) then _node.ishidden = true
					)--if
				)--for
			)--if asset != undefined	
		),

		----------------------------------------------------------------------------------
		--modo de visualizacion en skin + box
		-----------------------------------------------
		--antes de llamar a la funcion se precisa hacer
		--disableSceneRedraw()
		--suspendEditing()
		--despues de llamar a la funcion se precisa hacer
		--resumeEditing()
		--enableSceneRedraw()
		--completeRedraw()
		----------------------------------------------------------------------------------
		fn setAssetConnectAllMode ast disableSecPuppets:false enableCloth:true =
		(
			if ast != undefined then
			(
				objsToHide = #() --array de objetos del asset que debe ocultar
				objsToVis = #() --array de objetos del asset que debe dejar visibles
				objsToFreeze = #() --array de objetos del asset que debe congelar
				objsToUnfreeze = #() --array de objetos del asset que debe descongelar
				_hairFarmClasses = #(HairStyle_Uncomb, HairTo_SplinesSpacewarpModifier, HairTo_PolySpacewarpModifier, HairTo_InstancesSpacewarpModifier, HairStyle_PushOutSpacewarpModifier, HairStyle_Forces, Hair_Display, HairTo_Splines, HairTo_Poly, HairTo_Instances, HairStyle_Wisps, HairStyle_Spiral, HairStyle_Scale, HairStyle_PushOut, HairStyle_Length, HairStyle_Kink, HairStyle_Gravity, HairStyle_Frizz, HairStyle_Displace, HairStyle_Curves, HairStyle_Cluster, HairMesh_to_Poly, HairMesh_Smooth, HairMesh_Sim, HairMesh_Mirror, HairMesh_Link, HairMesh_Extrude, HairMesh_Edit, HairMesh_Brush, Hair_Generate, Hair_Direction_on_Poly)

				--------------------------------------------------------------------------------------------------------
				--rellena los arrays de objetos que ocultar, desocultar, congelar o descongelar
				this.fillAssetVisModeArrays ast "CA" &objsToHide &objsToVis &objsToFreeze &objsToUnfreeze
				
				--oculta los objetos que deben ir ocultos y hace visibles los que deben verse
				objsToVis.ishidden = false
				objsToHide.ishidden = true
				
				--congela los objetos que deben ir bloqueados y descongela los que deben poder manipularse
				objsToUnfreeze.isfrozen = false
				objsToFreeze.isfrozen = true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--activa el modo box de las piezas de rig
	 			--this.setBoxMode ast.rigNodesAll state:true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--oculta/muestra los puppets secundarios
				--si no hay que ocultarlos, solo mostraremos los puppets secundarios que hagan referencia a assets que estan en la escena
	 			--if disableSecPuppets then this.hideSecPuppets asset
	 			--else this.showSecPuppets asset
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--conecta el rig de skin
				this.setSkinConnection ast true
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--desactiva el modificador headSystem de las piezas de mesh
				for obj in ast.meshNodesAll where (lb.customAttributes.hasAttribute obj #skinConnectionInfo) and (obj.skinConnectionInfo.headSystem) do
				(
					--habilita el modificador headSystem si es que el mesh lo tiene para ocultar poligonos que sobren
					_headSystemMod = obj.modifiers[#headSystem]
					if _headSystemMod != undefined then _headSystemMod.enabled = false
				)--for
				--------------------------------------------------------------------------------------------------------
				
				--------------------------------------------------------------------------------------------------------
				--activa los modificadores cloth que lleven las piezas de mesh de ese asset
				for obj in (ast.meshNodesAll + ast.clothNodesAll) do
					for m in obj.modifiers do
					(
						if enableCloth and classof m == Cloth do	m.enabled = true
					)
				--------------------------------------------------------------------------------------------------------
					
				--------------------------------------------------------------------------------------------------------
				--activa los modificadores cloth que lleven las piezas de mesh de ese asset
				for obj in (ast.hairNodesAll) do
					for m in obj.modifiers where (findItem _hairFarmClasses (classOf m) != 0) do
					(
						m.enabled = false
						m.enabledInViews = false
					)
				--------------------------------------------------------------------------------------------------------
			)--if ast != undefined
			
	 		/*if ast != undefined then
			(
				objsToHide = #() --array de objetos del ast que debe ocultar
				objsToVis = #() --array de objetos del ast que debe dejar visibles
				visTypes = #()
				
				case ast.type of
				(
					"chr": --si es un personaje
					(
						objsToHide = ast.skinNodesAll + ast.facialNodesAll + ast.dynNodesAll + ast.clothNodesAll --this.getAssetNodesByType ast #(lb.nc.NC_classSkin, lb.nc.NC_classFacial)
						visTypes = #(lb.nc.NC_classMesh, lb.nc.NC_classRig)
						objsToVis = ast.meshNodesAll + ast.proxyNodesAll + ast.rigNodesAll --this.getAssetNodesByType ast visTypes
					)
					
					"prp": --si es un personaje
					(
						objsToHide = ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll --this.getAssetNodesByType ast #(lb.nc.NC_classSkin)
						visTypes = #(lb.nc.NC_classMesh, lb.nc.NC_classRig)
						objsToVis = ast.meshNodesAll + ast.proxyNodesAll + ast.rigNodesAll --this.getAssetNodesByType ast visTypes
					)
					
					"spr": --si es un personaje
					(
						objsToHide = ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll --this.getAssetNodesByType ast #(lb.nc.NC_classSkin)
						visTypes = #(lb.nc.NC_classMesh, lb.nc.NC_classRig)
						objsToVis = ast.meshNodesAll + ast.proxyNodesAll + ast.rigNodesAll --this.getAssetNodesByType ast visTypes
					)
					
					"set": --si es un set
					(
						objsToHide = #()
						objsToVis = ast.meshNodesAll + ast.proxyNodesAll
					)
				)
				
				objsToHide.ishidden = true
				
				objsToVis.ishidden = false
				objsToVis.isfrozen = false
				
				meshObjs = ast.meshNodesAll --this.getAssetNodesByType ast #(lb.nc.NC_classMesh)
				meshObjs.isfrozen = true
				
				auxObjs = this.getAssetNodesByType ast visTypes flags:#(lb.nc.NC_hiddenFlag)
				auxObjs.ishidden = true
				auxObjs.isfrozen = true
				auxObjs = this.getAssetNodesByType ast visTypes flags:#(lb.nc.NC_frozenFlag)
				auxObjs.isfrozen = true
				
				headSystemModifier = undefined
				for m in meshObjs do
					if lb.customAttributes.hasAttribute m #skinConnectionInfo then
						if m.skinConnectionInfo.headSystem then
						(
							m.ishidden = false
							m.isfrozen = true
							
							for x in m.modifiers where x.name == "headSystem" do
								headSystemModifier = x
						)
				
				rigObjs = #()
				rigObjs = this.getAssetNodesByType ast lb.nc.NC_classRig flags:#(lb.nc.NC_duplicatedFlag)--ast.rigNodesAll --execute ("$'" + ast.fullName + "_" + lb.nc.NC_classRig + "_*_*_*_*" + lb.nc.NC_duplicatedFlag + "*'")
				this.setBoxMode rigObjs
				
				--oculta/muestra los puppets secundarios
				if disableSecPuppets then this.hideSecPuppets ast
				else this.showSecPuppets ast
				
				this.setSkinConnection ast true
				
				if headSystemModifier != undefined then
					headSystemModifier.enabled = false
				
				---------------------------------------------------------------------------------------------------------
				--obtiene todos los objetos que llevan cloth de ese ast y los deja visibles y descongelados
				_clothMod = undefined --cloth que hay que activar
				_allCloths  = getClassInstances Cloth --obtiene todos los cloth de la escena
					
				_stop = false --flag de parada
				for clth in _allCloths where not _stop do --recorre los cloths obtenidos de la escena
				(
					_allClothDeps = refs.dependentNodes clth --obtiene todos los objetos dependientes de ese clothfx
					
					for obj in _allClothDeps where not _stop do --recorre los objetos dependientes del cloth buscando alguno del ast actual y si lo encuenra lo activa y para
						if findItem ast.nodes obj != 0 then
						(
							_stop = true
							clth.enabled = true
						)--if
				)--for
				---------------------------------------------------------------------------------------------------------
			) */
		),

		------------------------------------------------
		--OTHER
		------------------------------------------------

		----------------------------------------------------------------------------------
		--devuelve true si el rig de skin esta conectado y false en caso contrario
		----------------------------------------------------------------------------------
		fn isSkinConnected ast =
		(
			connected = false

			skinObjs = this.getAssetNodesByType ast #(lb.nc.NC_classSkin) --objetos de skin del ast
			
			for obj in skinObjs where not connected do --recorre los nodos de skin hasta determinar si está conectado o no
				connected = lb.skinConnectionInfo.isConnected obj		
			
			connected
		),
			
		----------------------------------------------------------------------------------
		--oculta el ASSET pasado por parametro
		----------------------------------------------------------------------------------
		fn hideAsset ast =
		(
			this.setSkinConnection ast false ignoreKeepConnected:true
			objs = this.getAssetNodes ast
			objs.ishidden = true
		),
		
		----------------------------------------------------------------------------------
		--oculta todos los asset excepto el pasado por parametro
		----------------------------------------------------------------------------------
		fn isolateAsset ast allAssets =
		(
			for a in allAssets do
				if a.fullName != ast.fullName then
					this.hideAsset a			
		),

		----------------------------------------------------------------------------------------------------
		-- Le pasamos un asset en el parámetro ast y lo renombra con el valor pasado en newName. 
		-- El nuevo nombre ha de ser la segunda parte que queramos sustituir.
		-- Podemos renombrar sus materiales también pasándole el parámetro renameMaterials:true.
		----------------------------------------------------------------------------------------------------
		fn renameAsset ast newName renameMaterials:false renameObjectSets:true renameDynConnect:true = 
		(
			-- Renombramos el dynConnectInfo
			if renameDynConnect then
				for o in ast.nodes where lb.dynConnect.hasDynConnectInfo o do -- Recorremos los nodos de los objetos.
				(
					_selfNode = o.dynConnectInfo.getSelfNode()
					_selfNodePartName  = lb.nc.getNamePart _selfNode.name 2
					
					-- Recorremos los targetNodesNames y sustituimos la segunda parte del nombre.
					for i = 1 to o.dynConnectInfo.targetNodesNames.count do
						if lb.nc.ncOK o.dynConnectInfo.targetNodesNames[i] then
						(
							_filterName = filterString o.dynConnectInfo.targetNodesNames[i] "_"	
							
							_findAnyTag = _filterName[2] == lb.nc.NC_anyTag
							
							-- Comprobamos que la segunda parte del nodo almacenado sea igual que del selfNode porque asumiremos que no se 
							-- ha hecho un target a nada externo del asset, y asi no renombrarlo y que deje de funcionar la conexión
-- 							if _selfNodePartName == _filterName[2] then
-- 							(
							if not _findAnyTag then
							(
								_tempName = _filterName[1] + "_" + newName + "_" + _filterName[3] + "_" + _filterName[4] + "_" + _filterName[5] + "_" + _filterName[6] + "_" + _filterName[7]
								
								o.dynConnectInfo.targetNodesNames[i] = _tempName
							)
-- 							)
						)	
				) -- for o
			
			--Recorremos los nodos del asset 
			for o in ast.nodes where (lb.nc.ncOK o.name) do--Los vamos renombrando
				o.name = (substituteString o.name (filterString o.name "_")[2] newName)
				
			--Renombramos la capa.
			if ast.nodes.count > 0 do
			(
				_newLayerName = (ast.type + "_" + newName)
				_newLayer = layerManager.getLayerFromName _newLayerName
				
				-- Si la capa para el nuevo asset no existe la creamos y 
				-- si ya existía movemos ahí los objetos y borramos la original
				if _newLayer == undefined then
					ast.nodes[1].layer.setName _newLayerName
				else
				(
					ast.nodes[1].layer.nodes &_oldLayerNodes
					for _node in _oldLayerNodes do 
						_newLayer.addNode _node
					
					(layerManager.getLayer 0).current = true
					layerManager.deleteLayerByName ast.layer.name
				)
			)
			
			--Si el usuario ha decidido renombrar los materiales.
			if renameMaterials then
			(
				--Recogemos los materiales en un Array.
				_assetMaterials = this.getAssetMaterials ast
				--Los recorremos y los vamos nombrando.
				for i=1 to _assetMaterials.count where (lb.nc.ncOk _assetMaterials[i].name type:#material) do
				(
	 				--print _assetMaterials[i].name
					
					_assetMaterials[i].name = (substituteString _assetMaterials[i].name (filterString _assetMaterials[i].name "_")[2] newName)
	 				
				)
			)
			
			-- Renombramos objectSets
			if renameObjectSets then
				for o in ast.nodes where lb.objectSets.hasObjectSets o do -- Recorremos los objectSets de los objetos.
					for i = 1 to o.objectSets.names.count do -- Recorremos los objectSets names y sustituimos la segunda parte del nombre.
					(
						_filterName = filterString o.objectSets.names[i] "_"	
						
						-- Filtramos por si el objectSet tiene 3, 4 o 5 partes.
						case _filterName.count of
						(
						
						 3: _tempName = _filterName[1] + "_" + newName + "_" + _filterName[3]
							
						 4: _tempName = _filterName[1] + "_" + newName + "_" + _filterName[3] + "_" + _filterName[4]
							
						 5: _tempName = _filterName[1] + "_" + newName + "_" + _filterName[3] + "_" + _filterName[4] + "_" + _filterName[5]	
							
						)
						
						o.objectSets.names[i] = _tempName
						
					) -- for i
					
		),

		----------------------------------------------------------------------------------
		--oculta todos los asset excepto los pasados por parametro
		----------------------------------------------------------------------------------
		fn isolateAssets asts allAssets =
		(
			for a in allAssets do
			(
				found = false
				
				for ast in asts do
					if ast.fullName == a.fullName then
						found = true
						
				if not found then
					this.hideAsset a			
			)
		),

		----------------------------------------------------------------------------------
		--	indica si existe en el listado de assets pasados en ASSETS un asset
		--	cuyo nombre sea igual al pasado en ASSETNAME. Devuelve el índice dentro
		--	del listado ASSETS. Si no lo encuentra devuelve 0
		----------------------------------------------------------------------------------
		fn findAssetByName asts assetName =	
		(
			names = #()
			for a in asts do append names (toLower a.fullName)
			pos = finditem names (toLower assetName)
		),

		----------------------------------------------------------------------------------
		--devuelve true si hay alguna pieza de Rig con Puppet en el asset pasado por parametro
		----------------------------------------------------------------------------------
		fn hasPuppet ast =
		(
			puppet = false
	 		--if ast != undefined then
	 		--(
				rigNodes = ast.animNodesAll 
				
				if rigNodes.count != 0 then
				(
					cont = 1
					while not puppet and cont <= rigNodes.count do
					(
						for m in rigNodes[cont].modifiers where findString m.name "Puppet" != undefined do
							puppet = true
						
						cont += 1
					)--while	
				)--if
	 		--)--if
			
			puppet
		),

		----------------------------------------------------------------------------------
		--resetea la visualizacion del ast
		----------------------------------------------------------------------------------
		fn resetAsset ast =
		(
			if ast != undefined then
				case ast.type of
				(
					"chr": this.setAssetPuppetMode ast
					
					"prp":
					(
						if this.hasPuppet ast then
							this.setAssetPuppetMode ast
						else
							this.setAssetSkinBoxMode ast
					)
					
					"lit":
					(
						if this.hasPuppet ast then
							this.setAssetPuppetMode ast
						else
							this.setAssetSkinBoxMode ast
					)
					
					"fx":
					(
						if this.hasPuppet ast then
							this.setAssetPuppetMode ast
						else
							this.setAssetSkinBoxMode ast
					)
					
					"spr":
					(
						if this.hasPuppet ast then
							this.setAssetPuppetMode ast
						else
							this.setAssetSkinBoxMode ast
					)
					
					"set":
					(
						this.setAssetSkinMode ast
					)
					
					
				)--case
		),

		----------------------------------------------------------------------------------------------
		--	Lee el contendido del fichero de información de asset FILENAME y devuelve
		--	un array de structs de tipo asset
		----------------------------------------------------------------------------------------------
		fn readSceneAssetInfo filename = 
		(
			local assetFiles = #()
			
			formatVersion = execute (getIniSetting filename "Main" "formatVersion")
			numAssets = execute (getIniSetting filename "Main" "numAssets")
			
			for i = 1 to numAssets do
			(
				assetNumberStr = "asset_" + (i as string)
				assetType 		= getIniSetting filename assetNumberStr "type"
				assetName 		= getIniSetting filename assetNumberStr "name"
				assetFullName = getIniSetting filename assetNumberStr "fullName"
				copyNumber 	= (getIniSetting filename assetNumberStr "copyNumber") as integer
				assetFolder 	= getIniSetting filename assetNumberStr "folder"
				assetVersion 	= (getIniSetting filename assetNumberStr "version") as integer
				
				-- creamos un asset con todos los datos leídos y obtenemos la ruta de su fichero
				a = (asset type:assetType name:assetName fullName:assetFullName copyNumber:copyNumber folder:assetFolder version:assetVersion)
				
				--	para los sets devolvemos el fichero mesh. Para el resto de assets devolvemos el fichero de cache.
				assetFilename = if a.type == lb.nc.NC_setPrefix then this.getAssetFileName a #mesh else this.getAssetFileName a #cache
				
				if doesFileExist assetFilename then append assetFiles assetFilename
			)
			
			camFiles = #()
			camNames = #()
			
			numCamFiles = (getIniSetting filename "Main" "numCameraFiles") as integer
			for i = 1 to numCamFiles do
			(
				camFileStr = "camFile_" + (i as string)
				camFile = getIniSetting filename camFileStr "filename"
				append camFiles camFile
				numCamsForFile = (getIniSetting filename camFileStr "numCams") as integer
				camNames[i] = #()
				for j = 1 to numCamsForFile do
				(
					camStr = camFileStr + "_cam_" + (j as string)
					camName = getIniSetting filename camStr  "name"
					append camNames[i] camName
				)
			)
			
			sceneInfo = sceneAssetInfo()
			
			sceneInfo.assetFiles = assetFiles
			sceneInfo.camFiles = camFiles
			sceneInfo.camNames = camNames
			
			sceneInfo
		),

		----------------------------------------------------------------------------------------------
		--	Guarda en el fichero FILENAME la información de los ASSETS pasados por 
		--	parámetro, incluyendo datos como su número de versión y su carpeta de almacenaje.
		----------------------------------------------------------------------------------------------
		fn saveSceneAssetInfo filename asts = 
		(
			fileCreated = false
			
			f = createFile filename
			if f != undefined then
			(
				setIniSetting filename "Main" "formatVersion" "1"
				setIniSetting filename "Main" "numAssets" (asts.count as string)
				
				--	recopilamos las cámaras cargadas por xRef
				cams = for c in cameras where (try (c.filename; true) catch false) collect c
				camFiles = #()
				for c in cams do appendIfUnique camFiles c.filename
				
				setIniSetting filename "Main" "numCameras" (cams.count as string)
				setIniSetting filename "Main" "numCameraFiles" (camFiles.count as string)
				
				for i = 1 to asts.count do
				(
					assetNumberStr = "asset_" + (i as string)
					
					folder = asts[i].folder
					version = asts[i].version as string
					
					setIniSetting filename assetNumberStr "type" asts[i].type
					setIniSetting filename assetNumberStr "name" asts[i].name
					setIniSetting filename assetNumberStr "fullName" asts[i].fullName
					setIniSetting filename assetNumberStr "copyNumber" (asts[i].copyNumber as string)
					setIniSetting filename assetNumberStr "folder" folder
					setIniSetting filename assetNumberStr "version" version
				)
				
				for i = 1 to camFiles.count do
				(
					camFileStr = "camFile_" + (i as string)
					setIniSetting filename camFileStr "filename" camFiles[i]
					
					camsForFile = for c in cams where c.filename == camFiles[i] collect c
					setIniSetting filename camFileStr "numCams" (camsForFile.count as string)
					
					for j = 1 to camsForFile.count do
					(
						camStr = camFileStr + "_cam_" + (j as string)
						setIniSetting filename camStr  "name" camsForFile[j].name
					)
				)
				
				fileCreated = true
			)
			
			fileCreated
		),

		----------------------------------------------------------------------------------
		--selecciona el ASSET pasado por parametro
		----------------------------------------------------------------------------------
		fn selectAssetRigObjs ast =
		(
			select ast.animNodesAll 
		),

		----------------------------------------------------------------------------------------------
		-- Busca el primer puppet que encuentre en los modificadores de un objeto pasado
		-- Devuleve 0 si no encuentra puppet y sino devuelve en indice del modificador puppet que encuentre primero
		----------------------------------------------------------------------------------------------
		fn findPuppet obj =
		(
			index = 0
			
			stop = false
			for i=1 to obj.modifiers.count where not stop do
				if findString obj.modifiers[i].name "Puppet" != undefined then
				(
					index = i
					stop = true
				)
			
			index
		),

		----------------------------------------------------------------------------------
		--añade a un selection set los objetos de un array si no estan ya en el
		--necesita el array de objetos
		--necesita el nombre del selection set
		----------------------------------------------------------------------------------
		fn addObjectsToSelectionSet objs selectionSetName =
		(
			oldSelSetObjs = this.getSelSetObjects selectionSetName
			
			for ob in objs do
				appendIfUnique oldSelSetObjs ob
			
			selectionSets[selectionSetName] = oldSelSetObjs
		),

		----------------------------------------------------------------------------------
		--oculta los puppets secundarios del asset pasado por parametro
		----------------------------------------------------------------------------------
		fn hideSecPuppets ast =
		(
			rigAnimNodes = this.getAssetAnimNodes ast lb.nc.NC_classAnim
			
			for obj in rigAnimNodes do
			(
				mainPuppet = obj.modifiers[#Puppet]
				
				for m in obj.modifiers where findString m.name "Puppet-" != undefined do
				(
					if mainPuppet == undefined then
						obj.ishidden = true
					
					m.enabled = false
				)
			)
		),	
		
		----------------------------------------------------------------------------------
		--muestra los puppets secundarios del asset pasado por parametro
		--si un puppet secundario hace referencia a un asset que no esta en la escena, no se muestra
		----------------------------------------------------------------------------------
		fn showSecPuppets ast =
		(
			rigAnimNodes = ast.animNodesAll 
			sceneAssetsNames = #() --array para almacenar los nombres de los assets
			
			if this.sceneAssets == undefined then --si no esta rellena la variable, la rellena
				this.sceneAssets = this.getSceneAssets()
			
			sceneAssetsNames = for a in this.sceneAssets collect a.fullname --llena un array con los nombres de los assets de la escena
			
			for obj in rigAnimNodes do
			(
				mainPuppet = obj.modifiers[#Puppet]
				
				for m in obj.modifiers where findString m.name "Puppet-" != undefined do
				(
					if mainPuppet == undefined then
						obj.ishidden = false
					
					relatedAsset = substituteString m.name "Puppet-" ""
					cpyNumber = ast.copyNumber
					
					if lb.nc.ncOK relatedAsset type:#layer then
					(
						if cpyNumber > 0 then --si tiene nombre de asset
						(
							if cpyNumber < 10 then
								relatedAsset += "#00" + cpyNumber as string
							else if cpyNumber < 10 then
								relatedAsset += "#0" + cpyNumber as string
							else
								relatedAsset += "#" + cpyNumber as string
						)--if
					
						m.enabled = (findItem sceneAssetsNames relatedAsset != 0)
					)
					else
					(
						m.enabled = true
					)
					
				)--for
			)--for
		),

		----------------------------------------------------------------------------------
		--activa los turbosmooths del asset
		----------------------------------------------------------------------------------
		fn enableAssetTurbosmooths ast =
		(
			for obj in ast.meshNodesAll do
				for m in obj.modifiers where (classof m == turbosmooth or classof m == meshSmooth) and not lb.nc.hasFlag m lb.nc.NC_keepConnectedModifierFlag do
				(
					m.enabled = true
					m.enabledInViews = true
				)
		),--fn enableAssetTurbosmooths

		------------------------------------------------------------------------------------------------------------------------
		--Devuelvel TRUE si el asset está visible y FALSE si no sale en cámara o está oculto por algo
		------------------------------------------------------------------------------------------------------------------------
		fn isAssetVisible ast camera:undefined start:undefined end:undefined useGlobalBoundingBox:false useBBfaces:true useBBcorners:false considerTransparency:true collisionBox:undefined =
		(
			_isVis = false
			
			--recopila los objetos de rig visibles del objeto
			_astRigNodes = this.getAssetAnimNodes ast #all
			_nodesToWork = for obj in _astRigNodes where (classof obj == Editable_Poly) or (classof obj == PolyMeshObject) or (classof obj == Editable_mesh) collect obj
			
			if _nodesToWork.count == 0 then _nodesToWork = ast.meshNodesAll
			
			if start != undefined then
			(
				if end == undefined or end < start then end = start
			)
			else
			(
				start = sliderTime
				end = sliderTime
			)
			
			_time = start
			
			while _time <= end and not _isVis do
			at time _time
			(
				if not useGlobalBoundingBox then --si hay que comprobar la visibilidad de cada objeto por separado
				(
					for o in _nodesToWork where not _isVis do
						_isVis = lb.cameraFunctions.isNodeVisible o camera:camera useBBfaces:useBBfaces useBBcorners:useBBcorners considerTransparency:considerTransparency
				)
				else --se comprueba la visibilidad en conjunto a partir del bounding box completo de todas las piezas del asset
				(
					
					_assetRootNode = undefined
					for rn in theAsset.animNodesAll where _assetRootNode == undefined and (matchPattern rn.name pattern:"*_*_anim_*_root_*_d") do
						_assetRootNode = rn
					
					--si no hay root busca la base
					if _assetRootNode == undefined then
						_assetRootNode = this.getAssetRootNode ast
					
					--si aun asi no ha encontrado root, coge el nodo de mesh que sea padre de todo
					if _assetRootNode == undefined then
					(
						for mn in ast.meshNodesAll where _assetRootNode == undefined and mn.parent == undefined do
							_assetRootNode = mn
					)
					
					_refMatrix = if _assetRootNode != undefined then _assetRootNode.transform else matrix3 1
					_theBoundingBox = lb.geometry.getNodesBoundingBox _nodesToWork _refMatrix
					collisionBox = lb.geometry.createBoxFromBoundingBox _theBoundingBox boxToUse:collisionBox refMatrix:_refMatrix
						
					/*CompleteRedraw()
					sleep 0.3--*/
					
					_isVis = lb.cameraFunctions.isNodeVisible collisionBox camera:camera useBBfaces:useBBfaces useBBcorners:useBBcorners considerTransparency:considerTransparency
				)
				
				_time += 1
			)
				
			_isVis
		),
				
		----------------------------------------------------------------------------------
		--desactiva los turbosmooth del asset
		----------------------------------------------------------------------------------
		fn disableAssetTurbosmooths ast =
		(
			for obj in ast.meshNodesAll do
				for m in obj.modifiers where (classof m == turbosmooth or classof m == meshSmooth) and not lb.nc.hasFlag m lb.nc.NC_keepConnectedModifierFlag do
				(
					m.enabled = true
					m.enabledInViews = false
				)
		),--fn disableAssetTurbosmooths

		----------------------------------------------------------------------------------
		--rellena los parametros por referencia con los arrays de objetos que ocultar, visualizar, congelar y descongelar
		--segun el tipo de modo de visualizacion
		--necesita saber el modo de visualizacion: VISMODE
		--VISMODE puede ser:
		--P:	Puppet
		--PH:	Puppet + Head
		--H:	Head
		--S:	Skin
		--SB:	Skin + Box
		--C:	Cloth
		--SC:	Skin + Cloth
		--CA:	Connect All
		----------------------------------------------------------------------------------
		fn fillAssetVisModeArrays ast visMode &objsToHide_ &objsToVis_ &objsToFreeze_ &objsToUnfreeze_ =
		(
			--rellena las variables por referencia con arrays vacios---------------------------
			_objsToHide = #() --array de objetos del asset que debe ocultar
			_objsToVis = #() --array de objetos del asset que debe dejar visibles
			_objsToFreeze = #() --array de objetos del asset que debe congelar
			_objsToUnfreeze = #() --array de objetos del asset que debe descongelar
			----------------------------------------------------------------------------------------
			
			----------------------------------------------------------------------------------------
			--segun el modo de visualizacion hay que rellenar los arrays con unos objetos u otros
			case visMode of
			(
				----------------------------------------------------------------------------------------
				"P": --modo puppet
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					case ast.type of
					(
						"chr": --si es un personaje -----------------------------------------------------------
						(
							_objsToHide = ast.morphNodesAll + ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.facialNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.hairNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast lb.nc.NC_classAnim) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
						)----------------------------------------------------------------------------------------
						
						"prp": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast lb.nc.NC_classAnim) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
						)----------------------------------------------------------------------------------------
						
						"lit": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast lb.nc.NC_classAnim) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
						)----------------------------------------------------------------------------------------
						
						"spr": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast lb.nc.NC_classAnim) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
						)----------------------------------------------------------------------------------------
						
						"set": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast lb.nc.NC_classAnim) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
						)----------------------------------------------------------------------------------------
					)--case ast.type
					-----------------------------------------------------------------------------------------------------
					
					-----------------------------------------------------------------------------------------------------
					--independientemente del tipo de asset, hay objetos que añadir a los arrays
					
					--si el asset no tiene puppets, tiene que mostrar los objetos de mesh
					if not ast.hasPuppets do _objsToVis += ast.meshNodesAll
					
					--obtiene los objetos de rig con flags de h y f
					_hiddenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_hiddenFlag)
					_frozenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_frozenFlag)
					_extraFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_extraFlag)
					
					_objsToHide += _hiddenFlagObjs + _extraFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag h y e
					_objsToFreeze += _hiddenFlagObjs + _frozenFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag f
					
					--los objetos de rig extras que lleven puppet se deben mostrar, por lo tanto se eliminan del array de ocultos si estuvieran
					for obj in _extraFlagObjs do
						for m in obj.modifiers where findString m.name "Puppet" != undefined do
						(
							_index = findItem _objsToHide obj
							if _index != 0 then deleteItem _objsToHide _index
						)--for
						
					--los objetos de rig que tengan skinConnectionInfo con la opcion keepConnected activada no se deben ocultar ni congelar
					for o in ast.animNodesAll do
						if lb.skinConnectionInfo.hasSkinconnectionInfo o and o.skinConnectionInfo.keepConnected then 
						(
							append _objsToVis o
							append _objsToUnfreeze o
						)
					-----------------------------------------------------------------------------------------------------
				)--modo puppet
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"PH": --modo puppet + head
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					case ast.type of
					(
						"chr": --si es un personaje -----------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.hairNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + (this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast #all
						)----------------------------------------------------------------------------------------
						
						"prp": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all)
							_objsToVis += (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = (this.getAssetAnimNodes ast lb.nc.NC_classAnim)
						)----------------------------------------------------------------------------------------
						
						"lit": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all)
							_objsToVis += (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = (this.getAssetAnimNodes ast lb.nc.NC_classAnim)
						)----------------------------------------------------------------------------------------
						
						"spr": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all)
							_objsToVis += (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = (this.getAssetAnimNodes ast lb.nc.NC_classAnim)
						)----------------------------------------------------------------------------------------
						
						"set": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.meshNodesAll + ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all)
							_objsToVis += (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = (this.getAssetAnimNodes ast lb.nc.NC_classAnim)
						)----------------------------------------------------------------------------------------
					)--case ast.type
					-----------------------------------------------------------------------------------------------------
					
					-----------------------------------------------------------------------------------------------------
					--independientemente del tipo de asset, hay objetos que añadir a los arrays
					
					--si el asset no tiene puppets, tiene que mostrar los objetos de mesh
					if not ast.hasPuppets do _objsToVis += ast.meshNodesAll
					
					--obtiene los objetos de rig con flags de h y f
					_hiddenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim, lb.nc.NC_classFacial) flags:#(lb.nc.NC_hiddenFlag)
					_frozenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim, lb.nc.NC_classFacial) flags:#(lb.nc.NC_frozenFlag)
					_extraFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_extraFlag)
					
					_objsToHide += _hiddenFlagObjs + _extraFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag h y e
					_objsToFreeze += _hiddenFlagObjs + _frozenFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag f
					
					--los objetos de rig extras que lleven puppet se deben mostrar, por lo tanto se eliminan del array de ocultos si estuvieran
					for obj in _extraFlagObjs do
						for m in obj.modifiers where findString m.name "Puppet" != undefined do
						(
							_index = findItem _objsToHide obj
							if _index != 0 then deleteItem _objsToHide _index
						)--for
						
					--los objetos de rig que tengan skinConnectionInfo con la opcion keepConnected activada no se deben ocultar ni congelar
					for o in ast.animNodesAll do
						if lb.skinConnectionInfo.hasSkinconnectionInfo o and o.skinConnectionInfo.keepConnected then 
						(
							append _objsToVis o
							append _objsToUnfreeze o
						)
					-----------------------------------------------------------------------------------------------------
				)--modo puppet + head
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"H": --modo head
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					case ast.type of
					(
						"chr": --si es un personaje -----------------------------------------------------------
						(
							_objsToHide = ast.animNodesAll + ast.meshNodesAll + ast.proxyNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.hairNodesAll + ast.connectNodesAll
							_objsToVis = this.getAssetAnimNodes ast lb.nc.NC_classFacial
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classFacial						
						)----------------------------------------------------------------------------------------
						
						"prp": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.nodes
							_objsToVis = #()
							_objsToUnfreeze = #()
						)----------------------------------------------------------------------------------------
						
						"lit": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.nodes
							_objsToVis = #()
							_objsToUnfreeze = #()
						)----------------------------------------------------------------------------------------
						
						"spr": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.nodes
							_objsToVis = #()
							_objsToUnfreeze = #()
						)----------------------------------------------------------------------------------------
						
						"set": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.nodes
							_objsToVis = #()
							_objsToUnfreeze = #()
						)----------------------------------------------------------------------------------------
					)--case ast.type
					
					--obtiene los objetos de rig con flags de h y f
					_hiddenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classFacial) flags:#(lb.nc.NC_hiddenFlag)
					_frozenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classFacial) flags:#(lb.nc.NC_frozenFlag)
					
					_objsToHide += _hiddenFlagObjs  --añade al array de objetos a ocultar, los objetos de rig ocn flag h
					_objsToFreeze += _hiddenFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag f
					-----------------------------------------------------------------------------------------------------
				)--modo head
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"S": --modo skin
				(
					--Segun el tipo de ast-------------------------------------------------------------------------
					if ast.type == "fx" then
					(
						_objsToHide = ast.animNodesAll + ast.facialNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.hairNodesAll  + ast.connectNodesAll --(this.getAssetNodesByType asset lb.nc.NC_classHair flags:#(lb.nc.NC_hiddenFlag))
						_objsToVis = ast.meshNodesAll + ast.proxyNodesAll + (this.getAssetNodesByType ast lb.nc.NC_classHair flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
						_objsToUnfreeze = ast.meshNodesAll
						_objsToFreeze = (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag))
					)
					else
					(
						--en este caso para todos los demás tipos de asset es lo mismo
						_objsToHide = ast.animNodesAll + ast.facialNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.hairNodesAll  + ast.connectNodesAll --(this.getAssetNodesByType ast lb.nc.NC_classHair flags:#(lb.nc.NC_hiddenFlag))
						_objsToVis = ast.meshNodesAll + ast.proxyNodesAll + (this.getAssetNodesByType ast lb.nc.NC_classHair flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
						_objsToUnfreeze = #()
						_objsToFreeze = ast.nodes
					)
					
					_objsToHide += (this.getAssetNodesByType ast #(lb.nc.NC_classMesh) flags:#(lb.nc.NC_hiddenFlag))
					
					_meshFrozenObjs	= (this.getAssetNodesByType ast #(lb.nc.NC_classMesh) flags:#(lb.nc.NC_frozenFlag))
					_meshNotFrozenObjs = for _obj in ast.meshNodesAll where (findItem _meshFrozenObjs _obj == 0) collect _obj
						
					for _obj in _meshNotFrozenObjs do
					(
						_index = findItem _objsToFreeze _obj
						if _index != 0 then deleteItem _objsToFreeze _index
					)--for
					
					_objsToUnfreeze += _meshNotFrozenObjs
					----------------------------------------------------------------------------------------------------	
				)--modo skin
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"SB": --modo skin + box
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					case ast.type of
					(
						"chr": --si es un personaje -----------------------------------------------------------
						(
							_objsToHide = ast.facialNodesAll + ast.proxyNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.hairNodesAll  + ast.connectNodesAll --(this.getAssetNodesByType ast lb.nc.NC_classHair flags:#(lb.nc.NC_hiddenFlag))
							_objsToVis = (this.getAssetAnimNodes ast #all) + ast.meshNodesAll + (this.getAssetNodesByType ast #(lb.nc.NC_classAnim, lb.nc.NC_classHair) flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"prp": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll  + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + ast.meshNodesAll + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"lit": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll  + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + ast.meshNodesAll + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"spr": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll  + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + ast.meshNodesAll + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"set": --si es un set ------------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + ast.meshNodesAll + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"fx": --si es de fx ------------------------------------------------------------------
						(
							_objsToHide = this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_hiddenFlag)
							_objsToVis = (this.getAssetAnimNodes ast #all) + ast.meshNodesAll
							_objsToUnfreeze = ast.meshNodesAll 
							_objsToFreeze = #()
						)----------------------------------------------------------------------------------------
					)--case asset.type
					-----------------------------------------------------------------------------------------------------
					
					_objsToHide += (this.getAssetNodesByType ast #(lb.nc.NC_classMesh) flags:#(lb.nc.NC_hiddenFlag))

					-----------------------------------------------------------------------------------------------------
					--independientemente del tipo de asset, hay objetos que añadir a los arrays
					
					--si el asset no tiene puppets, tiene que mostrar los objetos de mesh
					if not ast.hasPuppets do _objsToVis += ast.meshNodesAll
					
					--obtiene los objetos de rig con flags de h y f
					_hiddenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_hiddenFlag)
					_frozenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_frozenFlag)
					_extraFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim, lb.nc.NC_classFacial) flags:#(lb.nc.NC_extraFlag)
					
					_objsToHide += _hiddenFlagObjs + _extraFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag h
					_objsToFreeze += _hiddenFlagObjs + _frozenFlagObjs + _extraFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag f
					
					--los objetos de rig extras que lleven puppet se deben mostrar, por lo tanto se eliminan del array de ocultos si estuvieran
					for obj in _extraFlagObjs do
						for m in obj.modifiers where findString m.name "Puppet" != undefined do
						(
							_index = findItem _objsToHide obj
							if _index != 0 then deleteItem _objsToHide _index
						)--for
						
					--los objetos de rig que tengan skinConnectionInfo con la opcion keepConnected activada no se deben ocultar ni congelar
					for o in ast.animNodesAll do
						if lb.skinConnectionInfo.hasSkinconnectionInfo o and o.skinConnectionInfo.keepConnected then 
						(
							append _objsToVis o
							append _objsToUnfreeze o
						)
					----------------------------------------------------------------------------------------
				)--modo skin + box
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"B": --modo box
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					case ast.type of
					(
						"chr": --si es un personaje -----------------------------------------------------------
						(
							_objsToHide = ast.facialNodesAll + ast.proxyNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.hairNodesAll  + ast.connectNodesAll --(this.getAssetNodesByType asset lb.nc.NC_classHair flags:#(lb.nc.NC_hiddenFlag))
							_objsToVis = (this.getAssetAnimNodes ast #all) + (this.getAssetNodesByType ast #(lb.nc.NC_classAnim, lb.nc.NC_classHair) flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = #()
						)----------------------------------------------------------------------------------------
						
						"prp": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll  + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = #()
						)----------------------------------------------------------------------------------------
						
						"lit": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll  + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = #()
						)----------------------------------------------------------------------------------------
						
						"spr": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll  + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = #()
						)----------------------------------------------------------------------------------------
						
						"set": --si es un set ------------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.connectNodesAll
							_objsToVis = (this.getAssetAnimNodes ast #all) + (this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = this.getAssetAnimNodes ast lb.nc.NC_classAnim
							_objsToFreeze = #()
						)----------------------------------------------------------------------------------------
						
						"fx": --si es de fx ------------------------------------------------------------------
						(
							_objsToHide = this.getAssetNodesByType ast lb.nc.NC_classAnim flags:#(lb.nc.NC_hiddenFlag)
							_objsToVis = (this.getAssetAnimNodes ast #all)
							_objsToUnfreeze = #()
							_objsToFreeze = #()
						)----------------------------------------------------------------------------------------
					)--case ast.type
					-----------------------------------------------------------------------------------------------------
					
					-----------------------------------------------------------------------------------------------------
									
					--obtiene los objetos de rig con flags de h y f
					_hiddenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_hiddenFlag)
					_frozenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim) flags:#(lb.nc.NC_frozenFlag)
					_extraFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classAnim, lb.nc.NC_classFacial) flags:#(lb.nc.NC_extraFlag)
					
					_objsToHide += _hiddenFlagObjs + _extraFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag h
					_objsToFreeze += _hiddenFlagObjs + _frozenFlagObjs + _extraFlagObjs --añade al array de objetos a ocultar, los objetos de rig ocn flag f
					
					--los objetos de rig extras que lleven puppet se deben mostrar, por lo tanto se eliminan del array de ocultos si estuvieran
					for obj in _extraFlagObjs do
						for m in obj.modifiers where findString m.name "Puppet" != undefined do
						(
							_index = findItem _objsToHide obj
							if _index != 0 then deleteItem _objsToHide _index
						)--for
						
					--los objetos de rig que tengan skinConnectionInfo con la opcion keepConnected activada no se deben ocultar ni congelar
					for o in ast.animNodesAll do
						if lb.skinConnectionInfo.hasSkinconnectionInfo o and o.skinConnectionInfo.keepConnected then 
						(
							append _objsToVis o
							append _objsToUnfreeze o
						)
					----------------------------------------------------------------------------------------
				)--modo skin + box
				----------------------------------------------------------------------------------------

				----------------------------------------------------------------------------------------
				"C": --modo cloth
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					--en este caso para todos los tipos de asset es lo mismo
					_objsToHide = ast.animNodesAll + ast.proxyNodesAll + ast.facialNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.meshNodesAll + ast.hairNodesAll + ast.connectNodesAll
					_objsToVis = ast.clothNodesAll
					_objsToUnfreeze = ast.clothNodesAll
					-----------------------------------------------------------------------------------------------------
				)--modo cloth
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"SC": --modo skin + cloth
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					--en este caso para todos los tipos de asset es lo mismo
					_objsToHide = ast.animNodesAll + ast.proxyNodesAll + ast.facialNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.hairNodesAll + ast.connectNodesAll
					_objsToVis = ast.meshNodesAll
					_objsToUnfreeze = ast.meshNodesAll
					-----------------------------------------------------------------------------------------------------
				)--modo skin + cloth
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"F": --modo hair
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					--en este caso para todos los tipos de asset es lo mismo
					_objsToHide = ast.animNodesAll + ast.proxyNodesAll + ast.facialNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.meshNodesAll + ast.clothNodesAll + ast.connectNodesAll
					_objsToVis = ast.hairNodesAll
					_objsToUnfreeze = ast.hairNodesAll
					-----------------------------------------------------------------------------------------------------
				)--modo cloth
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"SF": --modo skin + hair
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					--en este caso para todos los tipos de asset es lo mismo
					_objsToHide = ast.animNodesAll + ast.proxyNodesAll + ast.facialNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll  + ast.connectNodesAll
					_objsToVis = ast.meshNodesAll + ast.hairNodesAll
					_objsToUnfreeze = ast.meshNodesAll + ast.hairNodesAll
					-----------------------------------------------------------------------------------------------------
				)--modo skin + cloth
				----------------------------------------------------------------------------------------
				
				----------------------------------------------------------------------------------------
				"CA": --modo conenct all
				(
					--Segun el tipo de asset--------------------------------------------------------------------------
					case ast.type of
					(
						"chr": --si es un personaje -----------------------------------------------------------
						(
							_objsToHide = ast.facialNodesAll + ast.proxyNodesAll + ast.morphNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.animNodesAll + ast.skinNodesAll + ast.connectNodesAll
							_objsToVis = ast.meshNodesAll + ast.hairNodesAll --(this.getAssetNodesByType asset lb.nc.NC_classHair flags:#(lb.nc.NC_frozenFlag) excludeHidden:true)
							_objsToUnfreeze = #()
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"prp": --si es un prop -----------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.animNodesAll + ast.skinNodesAll + ast.connectNodesAll
							_objsToVis = ast.meshNodesAll
							_objsToUnfreeze = #()
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"lit": --si es una luz -----------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.animNodesAll + ast.skinNodesAll + ast.connectNodesAll
							_objsToVis = ast.meshNodesAll
							_objsToUnfreeze = #()
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"spr": --si es un setProp -------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.animNodesAll + ast.skinNodesAll + ast.connectNodesAll
							_objsToVis = ast.meshNodesAll
							_objsToUnfreeze = #()
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
						
						"set": --si es un set ------------------------------------------------------------------
						(
							_objsToHide = ast.proxyNodesAll + ast.skinNodesAll + ast.dynNodesAll + ast.clothNodesAll + ast.animNodesAll + ast.skinNodesAll + ast.connectNodesAll
							_objsToVis = ast.meshNodesAll
							_objsToUnfreeze = #()
							_objsToFreeze = ast.meshNodesAll
						)----------------------------------------------------------------------------------------
					)--case asset.type
					-----------------------------------------------------------------------------------------------------
					
					-----------------------------------------------------------------------------------------------------
					--independientemente del tipo de asset, hay objetos que añadir a los arrays
					
					--si el asset no tiene puppets, tiene que mostrar los objetos de mesh
	 				--if not asset.hasPuppets do _objsToVis += asset.meshNodesAll
					
					--obtiene los objetos de rig con flags de h y f
	 				--_hiddenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classRig) flags:#(lb.nc.NC_hiddenFlag)
	 				--_frozenFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classRig) flags:#(lb.nc.NC_frozenFlag)
	 				--_extraFlagObjs = this.getAssetNodesByType ast #(lb.nc.NC_classRig) flags:#(lb.nc.NC_extraFlag)
					
	 				--_objsToHide += _hiddenFlagObjs --añade al array de objetos a ocultar, los objetos de rig con flag h
	 				--_objsToFreeze += _hiddenFlagObjs + _frozenFlagObjs --añade al array de objetos a ocultar, los objetos de rig con flag f
					
					--los objetos de rig extras que lleven puppet se deben mostrar, por lo tanto se eliminan del array de ocultos si estuvieran
	 				--for obj in _extraFlagObjs do
	 				--	for m in obj.modifiers where findString m.name "Puppet" != undefined do
	 				--	(
	 				--		_index = findItem _objsToHide obj
	 				--		if _index != 0 then deleteItem _objsToHide _index
	 				--	)--for
						
					--los objetos de rig que tengan skinConnectionInfo con la opcion keepConnected activada no se deben ocultar ni congelar
	 				--for o in ast.rigNodesAll do
	 				--	if hasSkinconnectionInfo o then
	 				--		if o.skinConnectionInfo.keepConnected then
	 				--		(
	 				--			append _objsToVis o
	 				--			append _objsToUnfreeze o
	 				--		)
					-----------------------------------------------------------------------------------------------------
				)--modo connect all
				----------------------------------------------------------------------------------------
			)--case visMode
			----------------------------------------------------------------------------------------
			
			--rellena las variables por referencia con los arrays llenos-----------------------
			objsToHide_ = _objsToHide
			objsToVis_ = _objsToVis
			objsToFreeze_ = _objsToFreeze
			objsToUnfreeze_ = _objsToUnfreeze
			----------------------------------------------------------------------------------------
		),
		
		----------------------------------------------------------------------------------
		--muestra los controles extras de rig y facial
		--type puede ser #all, #anim, #facial
		----------------------------------------------------------------------------------
		fn showExtraControls ast type _hide:false =
		(
			_classArray = #()
			if type == #all then _classArray = #(lb.nc.NC_classAnim, lb.nc.NC_classFacial, lb.nc.NC_classConnect)
			else if type == #anim then _classArray = #(lb.nc.NC_classAnim)
			else if type == #facial then _classArray = #(lb.nc.NC_classFacial)
			else if type == #connect then _classArray = #(lb.nc.NC_classConnect)
			
			_animExtraObjs = (this.getAssetNodesByType ast _classArray flags:#(lb.nc.NC_controlFlag,lb.nc.NC_extraFlag))
			--Si es una pieza de connect no requiere flag de control
			if type == #connect then
			(
				_animExtraObjs = (this.getAssetNodesByType ast _classArray flags:#(lb.nc.NC_extraFlag))
			)
			_animExtraObjs.isHidden = _hide
			_animExtraObjs.isFrozen = _hide
		),

		---------------------------------------------------------------------------------------
		-- Elimina el asset A borrando todos sus objetos y eliminando su capa
		-- necesita el resto de assets para buscar posibles dependientes
		-- UPDATELIST indica si hay que actualizar el listado de assets
		---------------------------------------------------------------------------------------
		fn deleteAsset a includeDependents:false updateList:true =
		(
			-- activamos el layer 0 para permitir el borrado de los layers de cualquier asset
			(layerManager.getLayer 0).current = true
			
			--primero eliminamos los assets dependientes del actual si procede
			if includeDependents then
			(
				dependents = this.getDependentAssets a (this.getSceneAssets())
				
				for dep in dependents do
					this.deleteAsset dep includeDependents:includeDependents updateList:false
			)
			
			--Si tiene atmosfericos los quitamos tambien
			if a.fxAtmospherics.count !=0 then
			(
				for i=1 to a.fxAtmospherics.count do
				(
					for j=numAtmospherics to 1 by -1 do
					(
						if a.fxAtmospherics[i] == (getAtmospheric j) then
							deleteAtmospheric j
					)
				)
				
				--Si solo hemos dejado un atmosférico de renderer de fusionworks lo eliminamos tambien
				if numAtmospherics == 1 and classof (getAtmospheric 1) == FusionWorks_Renderer then
					deleteAtmospheric 1
			)
			
			
			--eliminamos el asset actual
			if not a.isXrefScene then
			(
				delete (this.getAssetNodes a)
			)
			else
			(
				xRef = this.getAssetXRefScene a
				if xRef != undefined then 
					delete xRef
			)
			
			-- Borramos el layer del asset
			LayerManager.deleteLayerByName a.layer.name
			
		),

		----------------------------------------------------------------------------------
		--salva la animacion de los objetos pasados
		--abre el cuadro de salvar animacion de max
		----------------------------------------------------------------------------------
		fn saveAnimation file nodes nodesToRename saveSegment:false segInterval:animationRange projectId:"tdj" =
		(
			success = false
			
			--si tiene una array de nodos no vacio
			if classof file == String and classof nodes == Array and classof nodesToRename == Array then
			(
				nodes = for n in nodes where lb.nc.hasFlag n "c" collect n

				if nodes.count != 0 then
				(
					-------------------------------------------------------------------------------------------------
					--PONT CONSTRAINT
					-------------------------------------------------------------------------------------------------

					--antes de nada se recopilan los objetos que tengan point constraint, para obtener los points targets y salvar la animacion que tengan tambien.
					_pcNodes = #() --array para los objetos
					_pcTargetsData = #() --array para los points creados por los lincajes
					_pcLinksData = #() --array para los nodos a los que se hace lincaje

					--recorre los nodos que tengan targets reales (no world ni virtual world) y almacena el nodo y los targets
					for obj in nodes do			
					(
						_hasPC = false
						for m in obj.modifiers where not _hasPC and lb.links.pointConstraint.hasPCAttribute m do _hasPC = true
						
						if _hasPC then
						(
							_pcData = lb.links.pointConstraint.getPointData obj
							
							if _pcData.pointTargets.count != 0 then
							(
								--recopila los targets que sean reales (no world ni virtual world) y los añade a nodes
								for _target in _pcData.pointTargets do
								(
									_targetNode = getNodeByName _target[2]
									if _targetNode != undefined then append nodes _targetNode
								)--for

								--almacena el objeto y sus targets
								append _pcNodes obj
								append _pcTargetsData _pcData.pointTargets
								append _pcLinksData _pcData.pointLinks								
							)--if
						)--if
					)--for

					--ahora añade al array de nodos de los que guardar animacion los targets de point constraint
					--/*for _pcTarget in _pcTargetsData do (for _target in _pcTarget do append nodes (getNodeByName _target[2]))*/

					--print _pcNodes
					--print "------------"
					--print _pcTargetsData
					--print "----------------------------"

					-------------------------------------------------------------------------------------------------
					-------------------------------------------------------------------------------------------------

					-------------------------------------------------------------------------------------------------
					--salva los nombres actuales y elimina el prefijo y los flags para evitar tener que mapear las animaciones
					bckpNames = #()
					for i = 1 to nodesToRename.count do
					(
						bckpNames[i] = nodesToRename[i].name
						nodesToRename[i].name = lb.nc.getNameWithNoPrefix nodesToRename[i].name noCaches:true noFlags:true 
					)--for
					-------------------------------------------------------------------------------------------------
					
					-------------------------------------------------------------------------------------------------
					--crea una clave de animacion en los tracks que no la tengan al inicio y final del rango de guardado
					_start = segInterval.start --inicio de rango de animacion
					_end = segInterval.end --final de rango de animacion
					
					_startIntervalSubanimsWithoutKey = #() --array para almacenar los subanims que no tienen clave en el inicio de rango de guardado
					_endIntervalSubanimsWithoutKey = #() --array para almacenar los subanims que no tienen clave en el final de rango de guardado
					
					if saveSegment then --solo si la animacion se salva por segment
						for n in nodes do --recorre los nodos
							if lb.customAttributes.hasAttribute n #animInfo then --si tiene anitracks el nodo
							(
								--guardar clave de animacion en los animtracks que no la tengan
								
								--obtiene los animtracks
								_tracks = lb.animInfo.getAnimTracks n
								
								if _tracks != undefined and _tracks != #error then
								(
									--recorre los tracks creando clave en el que no tenga
									for t in _tracks where t.type != #separator do --t[1] != #separator do
									(
										--if classof t[1].controller == Float_Limit then t[1] = t[1].controller[1]
										if classof t.track.controller == Float_Limit then t.track = t.track.controller[1]
										
										--_hasStartKey = (getKeyIndex t[1].controller _start) != 0 --flag para saber si el track tiene clave en el inicio de rango
										--_hasEndKey = (getKeyIndex t[1].controller _end) != 0 --flag para saber si el track tiene clave en el final de rango
										
										_hasStartKey = (getKeyIndex t.track.controller _start) != 0 --flag para saber si el track tiene clave en el inicio de rango
										_hasEndKey = (getKeyIndex t.track.controller _end) != 0 --flag para saber si el track tiene clave en el final de rango
										
										--si no tiene clave en el inicio del rango de salvado
										--si es una pista Link_Times no debe tratarla
										--if not _hasStartKey and (findString t[2] "Link_Times") == undefined then
										if not _hasStartKey and (findString t.name "Link_Times") == undefined then
										(
											--append _startIntervalSubanimsWithoutKey t[1] --almacena el subanim
											--addNewKey t[1].controller _start --crea una clave
											append _startIntervalSubanimsWithoutKey t.track --almacena el subanim
											addNewKey t.track.controller _start --crea una clave
										)--if
										
										--si no tiene clave en el final del rango de salvado
										--si es una pista Link_Times no debe tratarla
										--if not _hasEndKey and (findString t[2] "Link_Times") == undefined then
										if not _hasEndKey and (findString t.name "Link_Times") == undefined then
										(
											--append _endIntervalSubanimsWithoutKey t[1] --almacenar el subanim
											--addNewKey t[1].controller _end --crea una clave
											append _endIntervalSubanimsWithoutKey t.track --almacenar el subanim
											addNewKey t.track.controller _end --crea una clave
										)--if
									)--for
								)	
							)
							else if lb.controller.isTransformFrozen n #all then --si no tiene animTracks y está freezeado
							(
								--guardar clave de animacion en las pistas de transformaion
								
								_transformSubanims = #() --array para almacenar los subanims de transformacion de un nodo freezeado de forma simple
								append _transformSubanims n.position.controller[#Zero_Pos_XYZ][1]
								append _transformSubanims n.position.controller[#Zero_Pos_XYZ][2]
								append _transformSubanims n.position.controller[#Zero_Pos_XYZ][3]
								append _transformSubanims n.rotation.controller[#Zero_Euler_XYZ][1]
								append _transformSubanims n.rotation.controller[#Zero_Euler_XYZ][2]
								append _transformSubanims n.rotation.controller[#Zero_Euler_XYZ][3]
								append _transformSubanims n.scale.controller[#Zero_Scale_XYZ][1]
								append _transformSubanims n.scale.controller[#Zero_Scale_XYZ][2]
								append _transformSubanims n.scale.controller[#Zero_Scale_XYZ][3]
								
								for _subanim in _transformSubanims do --recorre los subanims
								(
									--flags para saber si el track tiene clave en el inicio de rango y en el final de rango
									_hasStartKey = (getKeyIndex _subanim.controller _start) != 0
									_hasEndKey = (getKeyIndex _subanim.controller _end) != 0
									
									--si no tiene clave en el inicio del rango de salvado
									if not _hasStartKey then
									(
										append _startIntervalSubanimsWithoutKey _subanim --almacena el subanim
										addNewKey _subanim.controller _start --crea una clave
									)--if
									
									--si no tiene clave en el final del rango de salvado
									if not _hasEndKey then
									(
										append _endIntervalSubanimsWithoutKey _subanim --almacenar el subanim
										addNewKey _subanim.controller _end --crea una clave
									)--if
								)--for
							)
							else --si no tiene ni animtracks ni esta freezeado
							(
								--guardar clave de animacion en las pistas de transformaion
								
								_transformSubanims = #() --array para almacenar los subanims de transformacion de un nodo freezeado de forma simple
								append _transformSubanims n.position.controller[1]
								append _transformSubanims n.position.controller[2]
								append _transformSubanims n.position.controller[3]
								append _transformSubanims n.rotation.controller[1]
								append _transformSubanims n.rotation.controller[2]
								append _transformSubanims n.rotation.controller[3]
								append _transformSubanims n[#Transform][3] --escala
								
								for _subanim in _transformSubanims do --recorre los subanims
								(
									--flags para saber si el track tiene clave en el inicio de rango y en el final de rango
									_hasStartKey = (getKeyIndex _subanim.controller _start) != 0
									_hasEndKey = (getKeyIndex _subanim.controller _end) != 0
									
									--si no tiene clave en el inicio del rango de salvado
									if not _hasStartKey then
									(
										append _startIntervalSubanimsWithoutKey _subanim --almacena el subanim
										addNewKey _subanim.controller _start --crea una clave
									)--if
									
									--si no tiene clave en el final del rango de salvado
									if not _hasEndKey then
									(
										append _endIntervalSubanimsWithoutKey _subanim --almacenar el subanim
										addNewKey _subanim.controller _end --crea una clave
									)--if
								)--for
							) 
					-------------------------------------------------------------------------------------------------
					
					-------------------------------------------------------------------------------------------------
					--abre el cuadro de dialogo de guardado de animacion, esta en un try para que si falla puedan restablecerse los nombres
	 				--try

					LoadSaveAnimation.saveAnimation file &nodes #() #() animatedTracks:true includeConstraints:true keyableTracks:false saveSegment:saveSegment segInterval:segInterval
	 				--catch()
					-------------------------------------------------------------------------------------------------
					
					-------------------------------------------------------------------------------------------------
					--elimina las claves creadas de forma temporal antes de salvar
					
					--recorre los subanims con key creada al inicio del rango y la elimina
					for t in _startIntervalSubanimsWithoutKey do
					(
						_keyIndex = getKeyIndex t.controller _start --obtiene el indice de la clave
						
						if _keyIndex != 0 then --si consigue obtener la clave
							deleteKey t.controller _keyIndex --elimina la clave
					)--for
					
					--recorre los subanims con key creada al final del rango y la elimina
					for t in _endIntervalSubanimsWithoutKey do
					(
						_keyIndex = getKeyIndex t.controller _end  --obtiene el indice de la clave
						
						if _keyIndex != 0 then
							deleteKey t.controller _keyIndex --elimina la clave
					)--for
					-------------------------------------------------------------------------------------------------
					
					-------------------------------------------------------------------------------------------------
					--restaura los nombres antiguos
					for i=1 to nodesToRename.count do
						nodesToRename[i].name = bckpNames[i]
					-------------------------------------------------------------------------------------------------
					
					-------------------------------------------------------------------------------------------------
					--POINT CONSTRAINTS
					-------------------------------------------------------------------------------------------------

					---------------------------
					--version 1.0 de guardado de point constraint

					--hay que almacenar los points de point constraint

					--le quita la ultima etiqueta al archivo xaf de la animación
					_fStream = dotnetObject "System.IO.FileStream" file (dotnetClass "System.IO.FileMode").open
					_fStream.setLength ((_fStream.Length - 17) as integer)
					_fStream.Close()

					--abre el archivo para añadir la información
					f = openFile file mode:"a"

					if f != undefined then --si consigue abrir el fichero
					(
						--rangeStart = (segInterval.start as integer)/ticksPerFrame
						--rangeEnd = (segInterval.end as integer)/ticksPerFrame

						--añade el nodo inicial
						format ("    <PointConstraint version=\"2.00\" rangeStart=\"" + (segInterval.start as string) + "\" rangeEnd=\"" + (segInterval.end as string) + "\" >\n") to:f

						--almacena cada objeto que tiene targets de point constraint y sus targets
						for i=1 to _pcNodes.count do
						(
							format ("        <Object name=\"" + _pcNodes[i].name + "\" targetsCount=\"" + (_pcTargetsData[i].count as string) + "\" >\n") to:f

							--almacena los targets y sus datos
							for j=1 to _pcTargetsData[i].count do
							(
								_frame = _pcTargetsData[i][j][1] as string
								_frame = substring _frame 1 (_frame.count - 1)

								_targetPoint = getNodeByName _pcTargetsData[i][j][2]
								
								if _targetPoint != undefined then --si es un nodo real de target
								(
									_targetName = substituteString _pcTargetsData[i][j][2] ">" "&gt;"

									format ("            <Target name=\"" + _targetName + "\" targetNode=\"" + _pcLinksData[i][j][2] + "\" realNode=\"true\" order=\"" + (_pcTargetsData[i][j][3] as string) + "\" frame=\"" + _frame + "\" >\n") to:f

									at time (animationRange.start)
									(
										_initTransform = _targetPoint.transform as string --almacena la transformacion del point en el inicio del rango
										_parent = if _targetPoint.parent != undefined then _targetPoint.parent.name else "undefined" --almacena el padre del point
										
										_frozenPosVal = _targetPoint.position.controller["Frozen_position"].controller.value as string
										_zeroPosVal = _targetPoint.position.controller["Zero_Pos_XYZ"].controller.value as string

										_frozenRotVal = _targetPoint.rotation.controller["Frozen_rotation"].controller.value as string
										_zeroRotVal = _targetPoint.rotation.controller["Zero_Euler_XYZ"].controller.value as string

										format ("                <PointData initTransform=\"" + _initTransform + "\" parent=\"" + _parent  + "\" frozenRot=\"" + _frozenRotVal + "\" zeroRot=\"" + _zeroRotVal + "\" frozenPos=\"" + _frozenPosVal + "\" zeroPos=\"" + _zeroPosVal + "\" />\n") to:f
									)--at time

									format ("            </Target>\n") to:f
								)
								else --si es un world o virtual world
								(									
									format ("            <Target name=\"" + _pcTargetsData[i][j][2] + "\" targetNode=\"undefined\" realNode=\"false\" order=\"" + (_pcTargetsData[i][j][3] as string) + "\" frame=\"" + _frame + "\" />\n") to:f
								)
							)--for

							format ("        </Object>\n") to:f
						)

						--añade el nodo de cierre
						format "    </PointConstraint>\n" to:f
					)--if

					--restaura la etiqueta final para que no de errores de carga
					format "</MaxAnimation>" to:f
								
					close f
					---------------------------

					-------------------------------------------------------------------------------------------------
					-------------------------------------------------------------------------------------------------

	 				---------------------------------------------------------------------------------------------------
	 				--LINK CONSTRAINTS
	 				---------------------------------------------------------------------------------------------------

	 				--Se ha eliminado el código porque ya no se va a usar. (Si hace falta recuperarlo, se puede hacer del historico de svn)

	 				---------------------------------------------------------------------------------------------------
	 				---------------------------------------------------------------------------------------------------	 				
	 				
					success = true
				)
			)	
			success
		),
		
		----------------------------------------------------------------------------------
		--carga una animacion en los objetos pasados
		--abre el cuadro de dialogo de carga de animacion de max
		----------------------------------------------------------------------------------
		fn loadAnimation file nodes nodesToRename relative:false insert:false insTime:0 =
		(
			success = false
			
			--si tiene una array de nodos no vacio
			if classof file == String and classof nodes == Array and classof nodesToRename == Array then
				if nodes.count != 0 then
				(
					/*--------------------------------------------------------------------------------------
					--LINK CONSTRAINT: carga de link constraints
					--------------------------------------------------------------------------------------

					if f != undefined then --si consigue abrir el fichero
					(
						versionToLoad = 0
						searchNodes = false
						searchTargets = false
						objName = ""
						numTargets = 0
						obj = undefined --objeto al que pegar los links
						linkC = undefined --controlador link constraint del objeto
						lastTarget = undefined --último target aplicado
						
						chrPrefix = undefined
						--buscamos el prefijo de asset entre los nodos "NODES"
						for o in nodes where lb.nc.ncOK o.name and chrPrefix == undefined do
						(
							nameParts = filterString o.name "_"
							chrPrefix = nameParts[1] + "_" + nameParts[2]
						)
						
						---------------------------------------------------------------------------------------------------------------------------
						---------------------------------------------------------------------------------------------------------------------------					
						--recorre el fichero de abajo a arriba buscando la parte de los links----
						
						fn _readLineBackWards dotnetFileStream =
						(
							_theLine = ""
							local _fStream = dotnetFileStream
							
							_index = 1
							_byteRead = 0
							_stop = false
							
							_fStream.Seek (-1) ((dotNetClass "System.IO.SeekOrigin").Current)
							while (_index < _fStream.length) and not _stop do
							(
								_byteRead = _fStream.ReadByte()
								
								if _byteRead != 10 then _theLine = (bit.intAsChar _byteRead) + _theLine --_stringBuilder.Append (bit.intAsChar _byteRead)
								
								if (_byteRead == 10 and _theLine.count > 0) then _stop = true
											
								_fStream.Seek (-2) ((dotNetClass "System.IO.SeekOrigin").Current)
								_index += 1
							)
							
							_theLine
						)
						
						_lineLimit = 10000
						_stop = false
						_count = 0
						while (not _stop) and (_count < _lineLimit) do
						(
							_line = _readLineBackWards f
							if findString _line "<LinkConstraint" != undefined or findString _line "</Controller>" != undefined then _stop = true
							_count += 1
						)--while						
						
						---------------------------------------------------------------------------------------------------------------------------
						---------------------------------------------------------------------------------------------------------------------------
					
						-------------------------------------------------------------------------------
						
						--recorre el fichero cargando los links
						_strmReader = dotNetObject "System.IO.StreamReader" f
						while (_strmReader.Peek()) > -1 do --while not eof f do
						(
							l = _strmReader.ReadLine() --readLine f
							
							if findString l "<LinkConstraint" != undefined then
							(
								searchNodes = true --indica que aqui empiezan los links
								versionToLoad = (filterString l "< />")[2]
							)
							
							case versionToLoad of --en funcion de la version a cargar, pues lo hace de una forma u otra
							(
								"version=\"2.00\"":
								(
									if searchNodes then --si lo siguiente que debe aparecer en el fichero son nodos
									(
										if findString l "<Node " != undefined or findString l "<Object " != undefined then --busca el nodo
										(
											searchTargets = true --activa el flag de busqueda de targets
											
											lineParts = filterString l "< />" --elimina las partes innecesarias de la linea
											
											objName = ""
											numTargets = 0
											
											objName = (filterString lineParts[2] "=\"")[2] --nombre del nodo
											numTargets = (filterString lineParts[3] "=\"")[2] as integer --numero de targets
											
											lb.nc.ncOKobj = lb.nc.ncOK objName --pregunta si el nombre guardado de nodo cumple el NC
											
											obj = undefined --inicializa el objeto a undefined
											
											if not lb.nc.ncOKobj and (filterString objName "_").count == 4 then --si no cumple el naming convention y es un nombre de objeto sin prefijos ni flags
											(
												candidates = lb.misc.searchInArrayByString nodes objName
													
												if candidates.count == 1 then
													obj = candidates[1]
											)
											else --si cumple el NC busca el objeto en la escena o es un objeto que no pertenece a un asset
												obj = execute ("$'" + objName + "'")
											
											linkC = undefined
											if isValidNode obj then 
												linkC = obj.transform.controller --almacena el controlador en una variable
											
											lastTarget = undefined --vacia la variable donde tenemos el último target
											
											--si el controlador es un link constraint, buscamos el ultimo target
											if (classof linkC == Link_Constraint) then
											(
												numT = linkC.getNumTargets() --obtiene el numero de targets	
												
												if numT != 0 then
													lastTarget = linkC.getNode numT
											)
										)
										
										--comprobaciones antes de ponerse a buscar targets
										if searchTargets and (classof linkC == Link_Constraint) and (findString l "<Target " != undefined) then
										(								
											lineParts = filterString l "< />" --filtra la informacion de la linea
											
											frame = ((filterString lineParts[2] "=\"")[2] as integer)/ticksPerFrame --frame para el lincaje
											
											if insert and insTime != 0 then --si se usa la opcion insert, se deben colocar los lincajes con un offset
												frame += insTime
												
											targetName = (filterString lineParts[3] "=\"")[2] --nombre del target
												
											lb.nc.ncOKtarget = lb.nc.ncOK targetName --averigua si el nombre de target cumple el lb.nc.ncOK
											
											target = undefined --dejamos el target undefined
											
											if not lb.nc.ncOKtarget and (filterString targetName "_").count == 4 then
											(
												if chrPrefix != undefined then
													target = (execute ("$'" + chrPrefix + "_" + targetName + "*'")) as array
											)									
											else if targetName != "World" then --si cumple el lb.nc.ncOK o es un objeto que no pertenece a un asset
												target = (execute ("$'" + targetName + "*'")) as array
											
											--aplica el target al link constraint. No lo aplica si el ultimo target ya era el mismo
											if targetName != "World" then
											(
												if isValidNode target[1] and target[1] != lastTarget then
												(
													linkC.addTarget target[1] frame
													lastTarget = target[1]
												)--if
											)
											else
											(
												if lastTarget != "World" then
												(
													linkC.addWorld frameNo:frame
													lastTarget = "World"
												)--if
											)--if
										)
										
										if findString l "</Node>" != undefined then searchTargets = false
									)
								)--2.0
								
								"version=\"1.00\"":
								(
									if searchNodes then --si lo siguiente que debe aparecer en el fichero son nodos
									(
										if findString l "<Node " != undefined then --busca el nodo
										(
											searchTargets = true --activa el flag de busqueda de targets
											
											lineParts = filterString l "< />" --elimina las partes innecesarias de la linea
											
											objName = ""
											numTargets = 0
											
											objName = (filterString lineParts[2] "=\"")[2] --nombre del nodo
											numTargets = (filterString lineParts[3] "=\"")[2] as integer --numero de targets
											
											lb.nc.ncOKobj = lb.nc.ncOK objName --pregunta si el nombre guardado de nodo cumple el NC
											
											obj = undefined --inicializa el objeto a undefined
											
											if not lb.nc.ncOKobj and (filterString objName "_").count == 4 then --si no cumple el naming convention y es un nombre de objeto sin prefijos ni flags
											(
												candidates = lb.misc.searchInArrayByString nodes objName
													
												if candidates.count == 1 then
													obj = candidates[1]
											)
											else --si cumple el NC busca el objeto en la escena o es un objeto que no pertenece a un asset
												obj = execute ("$'" + objName + "'")
											
											linkC = undefined
											if isValidNode obj then 
												linkC = obj.transform.controller --almacena el controlador en una variable
										)
										
										--comprobaciones antes de ponerse a buscar targets
										if searchTargets and (classof linkC == Link_Constraint) and (findString l "<Target " != undefined) then
										(								
											lineParts = filterString l "< />" --filtra la informacion de la linea
											
											frame = ((filterString lineParts[2] "=\"")[2] as integer)/ticksPerFrame --frame para el lincaje
											
											if insert and insTime != 0 then --si se usa la opcion insert, se deben colocar los lincajes con un offset
												frame += insTime
												
											targetName = (filterString lineParts[3] "=\"")[2] --nombre del target
											
											lb.nc.ncOKtarget = lb.nc.ncOK targetName --averigua si el nombre de target cumple el lb.nc.ncOK
											
											target = undefined --dejamos el target undefined
											
											if not lb.nc.ncOKtarget and (filterString targetName "_").count == 4 then
											(
												if chrPrefix != undefined then
													target = (execute ("$'" + chrPrefix + "_" + targetName + "*'")) as array
											)									
											else if targetName != "World" then --si cumple el lb.nc.ncOK o es un objeto que no pertenece a un asset
												target = (execute ("$'" + targetName + "*'")) as array
											
											if targetName != "World" then
											(
												if isValidNode target[1] then
													linkC.addTarget target[1] frame
											)
											else
												linkC.addWorld frameNo:frame
										)
										
										if findString l "</Node>" != undefined then searchTargets = false
									)
								)--1.0
							)--case
							
							if l == "</LinkConstraint>" then searchNodes = false --indica que aqui acaban los links
						)--while not eof
						
						f.Close() --close f
						
						--Volvemos a poner el archivo con el status que tenia anteriormente en solo lectura
						setFileAttribute file #readOnly _readOnlyFileStatus 
					)--if

					--------------------------------------------------------------------------------------
					--LINK CONSTRAINT END
					--------------------------------------------------------------------------------------*/
					

					--------------------------------------------------------------------------------------
					--CARGA DE ANIMACION
					--------------------------------------------------------------------------------------
					
					--elimina cualquier animación que tuvieran las piezas antes de cargarles la nueva
					_deleteKeysInterval = (interval 0 (animationRange.end - animationRange.start))
					
					--if insert then _deleteKeysInterval = (interval 0 (animationRange.end - animationRange.start + insTime))
					if insert then _deleteKeysInterval = (interval insTime 129600)
					
					for _node in nodes do lb.animation.deleteAnimation _node _deleteKeysInterval

					--salva los nombres actuales y elimina el prefijo y los flags para evitar tener que mapear las animaciones
					bckpNames = #()
					for i=1 to nodesToRename.count do
					(
						bckpNames[i] = nodesToRename[i].name
						nodesToRename[i].name = lb.nc.getNameWithNoPrefix nodesToRename[i].name noCaches:true noFlags:true 
					)--for
					
					--abre el cuadro de dialogo de carga de animacion, esta en un try para que si falla puedan restablecerse los nombres
					try
					(
						if insert then LoadSaveAnimation.loadAnimation file &nodes relative:relative insert:insert insertTime:(insTime as time) useMapFile:false
						else LoadSaveAnimation.loadAnimation file &nodes relative:relative useMapFile:false
						
						success = true
					)
					catch()--*/
										
					--restaura los nombres antiguos
					for i=1 to nodesToRename.count do nodesToRename[i].name = bckpNames[i]

					--------------------------------------------------------------------------------------
					--CARGA DE ANIMACION END
					--------------------------------------------------------------------------------------

					--------------------------------------------------------------------------------------
					--POINT CONSTRAINT: carga de point constraints (por lectura de lineas hacia atras y luego con archivo temporal xml, muy rapido)
					--------------------------------------------------------------------------------------
					
					---------------------------------
					--crea un cursor de lectura de fichero de .net para ponerlo al final del archivo
					f = undefined					
					if doesFileExist file then 
					(	
						--guarda el readonly del archivo a abrir y lo desbloquea
						_readOnlyFileStatus = getFileAttribute file #readOnly
						setFileAttribute file #readOnly false 
						f = dotnetObject "System.IO.FileStream" file (dotnetClass "System.IO.FileMode").open 
						f.Seek 0 ((dotNetClass "System.IO.SeekOrigin").End)
					)--if
					---------------------------------

					---------------------------------
					if f != undefined then --si consigue abrir el fichero carga los links
					(
						---------------------------------
						--funcion para leer lineas hacia atras
						
						fn _readLineBackWards dotnetFileStream =
						(
							_theLine = ""
							local _fStream = dotnetFileStream
							
							_index = 1
							_byteRead = 0
							_stop = false
							
							_fStream.Seek (-1) ((dotNetClass "System.IO.SeekOrigin").Current)
							while (_index < _fStream.length) and not _stop do
							(
								_byteRead = _fStream.ReadByte()
								
								if _byteRead != 10 then _theLine = (bit.intAsChar _byteRead) + _theLine --_stringBuilder.Append (bit.intAsChar _byteRead)
								
								if (_byteRead == 10 and _theLine.count > 0) then _stop = true
											
								_fStream.Seek (-2) ((dotNetClass "System.IO.SeekOrigin").Current)
								_index += 1
							)
							
							_theLine
						)--fn
						---------------------------------

						---------------------------------
						--lee lineas hacia atras hasta encontrar el comienzo del point constraint
						_hasPCstored = false --flag para saber si hay info de PC en el xaf
						_lineLimit = 10000
						_stop = false
						_count = 0
						while (not _stop) and (_count < _lineLimit) do
						(
							_line = _readLineBackWards f
							if findString _line "<PointConstraint" != undefined or findString _line "</Controller>" != undefined then
							(
								_stop = true
								if findString _line "<PointConstraint" != undefined then _hasPCstored = true
							)--if

							_count += 1
						)--while
						---------------------------------

						---------------------------------
						--recorre el fichero cargando los point constraints

						_fullPCstring = "" --string para almacenar las lineas de PC del xaf
						
						if _hasPCstored then
						(
							_searchNodes = true
							_strmReader = dotNetObject "System.IO.StreamReader" f
							while _searchNodes and (_strmReader.Peek()) > -1 do --while not eof f do
							(
								_line = _strmReader.ReadLine() --readLine f
								_fullPCstring += _line + "\n"
								
								if findString _line "</PointConstraint>" != undefined then _searchNodes = false --indica que aqui acaban los point constraints
							)--while not eof
						)--if
						---------------------------------

						---------------------------------
						--libera el archivo
						f.Close() --close f
						---------------------------------

						---------------------------------
						--si hay informacion de point constraint la carga como xml y la leemos a partir de ahi
						
						if _fullPCstring != "" then
						(
							_tmpFile = lb.config.getTempPath() + "tmpLoadAnimationPCinfo.xml"
							if doesFileExist _tmpFile then deleteFile _tmpFile
							
							_f = openFile _tmpFile mode:"w"
							format _fullPCstring to:_f
							close _f

							_xmlDoc = lb.xml.load _tmpFile
							--print (_xmlDoc.toString())

							--TO DO: leer la info del xml de PC cargado y:
							--crear las claves desde el point constraint
							--cargar la informacion en los points

							if _xmlDoc != undefined then --si hay datos de point constraint
							(
								_targetPoints = #() --array para almacenar los points target a los que cargar la animacion

								_root = _xmlDoc.getRoot()
								_pcNode = _root.getNode "PointConstraint"

								--obtiene el inicio de rango de animacion en el que se guardaron los PC (para poder recrear las condiciones en los points al cargar)
								_rangeStart = (_pcNode.getProperty "rangeStart") as time
								
								--obtiene y recorre los objetos que tenian PC con targets
								_pcObjectsNodes = _root.getNodes "PointConstraint/Object"
								for _pcObjectNode in _pcObjectsNodes do
								(

									_pcObjectName = _pcObjectNode.getProperty "name"
									_pcObject = getNodeByName _pcObjectName

									--solo si el objeto esta en la escena
									if _pcObject != undefined then
									(
										--averigua si tiene PC
										_hasPC = false
										for m in _pcObject.modifiers where not _hasPC and lb.links.pointConstraint.hasPCAttribute m do _hasPC = true

										--solo si tiene PC
										if _hasPC then
										(
											--obtiene el PC data del objeto
											_pcData = lb.links.pointConstraint.getPointData _pcObject

											if _pcData.pcController == undefined or _pcData.ocController == undefined then
											(
												lb.links.pointConstraint.addPCconstrollers _pcObject
												_pcData = lb.links.pointConstraint.getPointData _pcObject
											)

											--si tiene targets los elimina primero
											if _pcData.pointLinks.count != 0 then
											(
												for i=_pcData.pointLinks.count to 1 by -1 do lb.links.pointConstraint.deleteTarget _pcObject i
												--lb.animation.deleteAnimation _pcObject --elimina la animacion del objeto
											)

											--obtiene los targets y los recrea
											_targetNodes = _pcObjectNode.getnodes "Target"
											for _targetNode in _targetNodes do
											(
												_isRealTarget = (_targetNode.getProperty "realNode") == "true"
												_frame = (_targetNode.getProperty "frame") as time

												if not _isRealTarget then --si no es un target real es al mundo a su virtual world
												(
													lb.links.pointConstraint.addTarget _pcObject undefined frameNo:_frame
												)
												else --si es un target real lo engancha
												(
													--primero crea el lincaje para que se cree el point en la escena
													_pointLink = undefined
													_node = getNodeByName (_targetNode.getProperty "targetNode")
													_targetPointName = substituteString (_targetNode.getProperty "name") "&gt;" ">"
													if _node != undefined then
													(
														_objectsBefore = objects as array
														lb.links.pointConstraint.addTarget _pcObject _node frameNo:_frame
														for o in objects where finditem _objectsBefore o == 0 do _pointLink = o													
													)	
													
													--despues añade el point a la lista de nodos a los que cargar animacion, lo renombra y le restaura las propiedades de los controladores frozen y zero
													--_pointNode = getNodeByName (_targetNode.getProperty "name")
													if _pointLink != undefined then
													(
														_pointLink.name = _targetPointName
														append _targetPoints _pointLink

														_pointData = _targetNode.getNode "PointData"
														if _pointData != undefined then
														(
															_frame = if insert then insTime else 0 --frame en el que modificar los valores

															_initTransform = execute (_pointData.getProperty "initTransform")
															_frozenRotVal = execute (_pointData.getProperty "frozenRot")
															_zeroRotVal = execute (_pointData.getProperty "zeroRot")
															_frozenPosVal = execute (_pointData.getProperty "frozenPos")
															_zeroPosVal = execute (_pointData.getProperty "zeroPos")

															at time _frame
															(
																_pointLink.rotation.controller[1].controller.value = _frozenRotVal
																_pointLink.rotation.controller[2].controller.value = _zeroRotVal
																_pointLink.position.controller[1].controller.value = _frozenPosVal
																_pointLink.position.controller[2].controller.value = _zeroPosVal

																_pointLink.transform = _initTransform
															)--at time

															-------------------------------------
															--carga la animacion al point

															_pointLink.name = substituteString _pointLink.name ">" "&gt;"

															try
															(
																_tmpPointArray = #(_pointLink)
																if insert then LoadSaveAnimation.loadAnimation file &_tmpPointArray relative:relative insert:insert insertTime:(insTime as time) useMapFile:false
																else LoadSaveAnimation.loadAnimation file &_tmpPointArray relative:relative useMapFile:false
															)
															catch
															(
																success = false
															)

															_pointLink.name = substituteString _pointLink.name "&gt;" ">"
															-------------------------------------

															at time _frame
															(
																--_pointLink.rotation.controller[1].controller.value = _frozenRotVal
																--_pointLink.rotation.controller[2].controller.value = _zeroRotVal
																--_pointLink.position.controller[1].controller.value = _frozenPosVal
																--_pointLink.position.controller[2].controller.value = _zeroPosVal

																_pointLink.transform = _initTransform
															)--at time
														)--if
													)--if
												)--if
											)--for

											--print "--------------------------"
										)--if
									)--if
								)--for
								
								/*-------------------------------------
								--renombra los points cambiando los caracteres ">" por "&gt;"
								for _pl in _targetPoints do _pl.name = substituteString _pl.name ">" "&gt;"
								-------------------------------------

								--carga la animacion de los point constraintt
								try
								(
									if insert then LoadSaveAnimation.loadAnimation file &_targetPoints relative:relative insert:insert insertTime:(insTime as time) useMapFile:false
									else LoadSaveAnimation.loadAnimation file &_targetPoints relative:relative useMapFile:false
									
									success = true
								)
								catch()

								-------------------------------------
								--restaura los nombres de los points cambiando los caracteres "&gt;" por ">"
								for _pl in _targetPoints do _pl.name = substituteString _pl.name "&gt;" ">"
								-------------------------------------*/

								--------------------------------------------------------------------------------------
								--RECARGA DE ANIMACION --se carga de nuevo la animacion del rig para ajustar desfases
								--------------------------------------------------------------------------------------

								--elimina cualquier animación que tuvieran las piezas antes de cargarles la nueva
								_deleteKeysInterval = (interval 0 (animationRange.end - animationRange.start))

								--if insert then _deleteKeysInterval = (interval 0 (animationRange.end - animationRange.start + insTime))
								if insert then _deleteKeysInterval = (interval insTime 129600)
								
								for _node in nodes do lb.animation.deleteAnimation _node _deleteKeysInterval

								--salva los nombres actuales y elimina el prefijo y los flags para evitar tener que mapear las animaciones
								bckpNames = #()
								for i=1 to nodesToRename.count do
								(
									bckpNames[i] = nodesToRename[i].name
									nodesToRename[i].name = lb.nc.getNameWithNoPrefix nodesToRename[i].name noCaches:true noFlags:true 
								)--for
								
								--abre el cuadro de dialogo de carga de animacion, esta en un try para que si falla puedan restablecerse los nombres
								try
								(
									if insert then LoadSaveAnimation.loadAnimation file &nodes relative:relative insert:insert insertTime:(insTime as time) useMapFile:false
									else LoadSaveAnimation.loadAnimation file &nodes relative:relative useMapFile:false						
								)
								catch( success = true )--*/
													
								--restaura los nombres antiguos
								for i=1 to nodesToRename.count do nodesToRename[i].name = bckpNames[i]

								--------------------------------------------------------------------------------------
								--RECARGA DE ANIMACION END
								--------------------------------------------------------------------------------------
							)--if
						)--if
						---------------------------------						
					)--if
					---------------------------------
					
					--------------------------------------------------------------------------------------
					--POINT CONSTRAINT END
					--------------------------------------------------------------------------------------					
				)--if nodes
				
			success
		),
		
		------------------------------------------------------------------------------
		--	Carga el fichero FILE en el modo MODE, que puede ser:
		--	#open: abre el fichero
		--	#merge: merge del fichero en la escena actual
		--	#xrefScene:	carga el fichero por Xref Scene en la escena actual
		--	#xrefObjects: carga el fichero por Xref Objects en la escena actual. 
		--	#xrefMeshObjects: carga el fichero por Xref Objects en la escena actual.
		--	Solo se quedan por Xref los objetos de tipo mesh, el resto de mergean del todo
		--	Se pueden configurar opciones de carga en XREFOPTIONS, que puede valer
		--	{#asProxy|#xrefModifiers|#dropModifiers|#mergeModifiers|#mergeManipulators|#selectNodes|#mergeMaterials|#mergeTransformsAnimNodes|#mergeTransforms}
		------------------------------------------------------------------------------
		fn loadAsset filename mode objectNames:#() xRefOptions:#() xRefNodes:#() breakXrefsOnmerge:true =
		(
			_assetNodes = #() --	array con los nodos del asset o assets cargados

			_nodesBeforeLoad = objects as array --objetos antes del load
			_layersBeforeLoad = lb.layer.getLayersNames() --capas antes del load

			_mergeTransformsAnimNodes = false
			_mergeTransforms = false		
			
			-------------------------------------------------
			--excepcion para cuando hay nodos de LPM
			
			_lpmRoot = #()

			--Primero preservaremos el LPM_Root (si es que lo hubiera)
			if mode == #merge then
			(
				_lpmRoot = ($'LPM_Root*') As Array
				
				for i=_lpmRoot.count to 1 by -1 do
					if classof _lpmRoot[i] == XRefObject then
						deleteItem _lpmRoot i
				
				--Si tengo más de uno me quedo con el primero
				if _lpmRoot.count > 1 then
					_lpmRoot = #(_lpmRoot[1])
			)
			-------------------------------------------------
			
			case mode of
			(
				#open:
				(
					yesNoCancel = #no --el estado por defecto es que no pregunte
					
					if getSaveRequired() then --si algo ha cambiado, pergunta
						yesNoCancel = yesNoCancelBox "The scene has been modified.\nDo you want to save your changes?"
					
					case yesNoCancel of
					(
						#yes:
						(
							proceed = true
							
							if checkForSave() and maxFilePath + maxFileName != "" then
								proceed = saveMaxFile (maxFilePath + maxFileName)
							
							if proceed do
							(
								resetMaxFile #noprompt
								this.sceneAssets = #()
								loadMaxFile filename quiet:false
								_assetNodes = objects
							)
						)
						
						#no:
						(
							resetMaxFile #noprompt
							this.sceneAssets = #()
							loadMaxFile filename quiet:false
							_assetNodes = objects
						)
					)
				)
				
				#xRefScene:
				(
					xRefs.addNewXRefFile filename; _assetNodes = #()
				)
				
				#merge:
				(
					--Todos los casos que no sean fx.
					if (filterString (getFilenameFile filename) "_")[1] != lb.nc.NC_fxFileName and (filterString (getFilenameFile filename) "_")[3] != lb.nc.NC_fxFileName then
					(
						objsBeforeMerge = for o in objects collect o		--	anotamos los nodos antes de hacer el merge.
						xRefRecordsBeforeMerge = for i = 1 to objXrefMgr.recordCount collect (objXrefMgr.getRecord i)		--	recopilamos las escenas de xref antes de mergear
						
						-- merge del fichero
						if objectNames.count != 0 then mergeMaxFile filename objectNames #mergeDups #useMergedMtlDups
						else mergeMaxFile filename #mergeDups #useMergedMtlDups
						
						--	los nodos del asset son las piezas que no estaban en la escena antes de hacer el merge
						_assetNodes = for o in objects where (finditem objsBeforeMerge o == 0) collect o
						
						xrefBadMergedObjects = #() --array para almacenar los objetos nuevos que se han quedado por xref
						xrefBadMergedObjectsModifiers = #() --almacenamos los modificadores
						
						--los xRef no se mergean bien. Los actualizamos para verlos correctamente.
						--tambien almacenamos los modificadores para poder comprobar luego si ha metido alguno de más
						for o in _assetNodes where classof o == xRefObject do
						(
							if o.unresolved then updateXref o.baseobject
								
							mods = #() --array de modificadores del objeto
							for m in o.modifiers do append mods m					
							append xrefBadMergedObjects o
							append xrefBadMergedObjectsModifiers mods
						)
						
						--	Por último mergeamos los objetos xRef del asset en la escena
						--	Obligatorio recorrer los records del final al principio.
						if breakXrefsOnmerge then --solo si se solicita, por defecto siempre pero se puede forzar que no
						(
							for i = objXrefMgr.recordCount to 1 by -1 do
							(
								record = objXRefMgr.getRecord i
								if finditem xRefRecordsBeforeMerge record == 0 and record != undefined then 
								(
									record.Update() --por si se habia quedado unresolved, para que lo encuentre antes
									objXRefMgr.MergeRecordIntoScene record
								)
							)
						)
						
						--comprueba que no hay modificadrores de más, producto de un mal merge
						for i=1 to xrefBadMergedObjects.count do
						(
							o = xrefBadMergedObjects[i]
							auxMods = for m in o.modifiers collect m --recolecta los modificadores del objeto despues de mergear
								
							for m in auxMods do --recorre los modificadores
							(
								index = findItem xrefBadMergedObjectsModifiers[i] m --mira a ver si ya estaba
								
								if index == 0 then --si no estaba lo elimina
									deleteModifier o m
							)--for
						)--for
					)
					--Si lo que cargo es un archivo de fx
					else if (filterString (getFilenameFile filename) "_")[3] == lb.nc.NC_fxFileName then
					(
						_oldObjects = Objects As Array
						
						--Vamos a guardar los objetos que hay ahora en un array y luego a cargar los nuevos por xref para luego mergearlos.
						_xRefRecord = objXRefMgr.AddXRefItemsFromFile filename objNames:objectNames promptObjNames:false xRefOptions:#(#mergeModifiers)
						
						--solo si se solicita, por defecto siempre pero se puede forzar que no
						if breakXrefsOnmerge then objXRefMgr.MergeRecordIntoScene _xRefRecord
						
						for i=1 to objects.count do
						(
							if finditem _oldObjects objects[i]== 0 then
								append _assetNodes objects[i]
						)
					)
					--Cuando hablemos de un objeto de fx.
					else
					(
						--Primero sacaremos la lista de nodos del asset viejo (si es que está duplicado)
						_allAssets = this.getSceneAssets()
						_oldAssetNodes = #()
						for i=1 to _allAssets.count do
						(
							--Si encuentro un asset guardo sus nodos.
							if _allAssets[i].fullname == ((filterString (getFilenameFile filename) "_")[1] + "_" + (filterString (getFilenameFile filename) "_")[2]) then
								_oldAssetNodes = _allAssets[i].nodes
						)
	 					--print ("Nodos del asset antes de cargar: " + _oldAssetNodes.count)
						
						--Cargamos todo por xref y luego romper las referencias.
						_xRefRecord = objXRefMgr.AddXRefItemsFromFile filename objNames:objectNames promptObjNames:false xRefOptions:#(#mergeModifiers)
						
						--solo si se solicita, por defecto siempre pero se puede forzar que no
						if breakXrefsOnmerge then objXRefMgr.MergeRecordIntoScene _xRefRecord
						
						--Volvemos a obtener los nodos del asset (que ahora estarán duplicados) y a partir de la lista de nodos del asset viejo sacaremos los nuevos.
						_allAssets = this.getSceneAssets()
						_allAssetNodes = #()
						for i=1 to _allAssets.count do
						(
							--Si encuentro un asset guardo sus nodos.
							if _allAssets[i].fullname == ((filterString (getFilenameFile filename) "_")[1] + "_" + (filterString (getFilenameFile filename) "_")[2]) then
								_allAssetNodes = _allAssets[i].nodes
						)
						
						--Una vez tenemos la lista de nodos del asset viejos junto la que tiene nuevos y viejos, sacaremos la lista de nodos nuevos.
						for i=1 to _allAssetNodes.count do
						(
							if findItem _oldAssetNodes _allAssetNodes[i] == 0 then
								append _assetNodes _allAssetNodes[i]
						)
						
						/*
						--Ahora lo que haremos será romper las referencias de los objetos y meterlas en _assetNodes.
						_items = #()
						_nodes = #()
						_xRefRecord.getItems #XRefObjectType &_items
						--Recorreremos los items sacando todos sus nodos
						for i=1 to _items.count do (_items[i].GetNodes &_tmpNodes; join _nodes _tmpNodes)
						objXRefMgr.MergeXRefItemsIntoScene _xRefObjs
						
						_assetNodes = _nodes
						
						--Reusamos _items para poner los atmosféricos
						_items = #()
						_xRefRecord.getItems #XRefAtmosphericType &_items
						objXRefMgr.MergeXRefItemsIntoScene _items
						
						objXRefMgr.RemoveRecordFromScene _xRefRecord
						*/
						
					)
					---------------------------------------------------------------------------------------------------------
					---------------------------------------------------------------------------------------------------------
					--	DEJAR UN SOLO MATERIAL DE TODOS LOS QUE TENGAN NOMBRES DUPLICADOS
					---------------------------------------------------------------------------------------------------------
					---------------------------------------------------------------------------------------------------------
				)
				
				#xRefObjects:
				(
					--	capturamos la selección de objetos actual
					oldSelection = for o in selection collect o
					
					--	indicamos qué objetos del fichero xRef hay que cargar
					objectsToLoad = xRefNodes
					if xRefNodes.count == 0 then
					(
						if objectNames.count != 0 then
						(
							objectsToLoad = objectNames
						)
						else
						(
							objectsToLoad = getMAXFileObjectNames filename
						)
					)
					
					--	Max no se come como opción #mergeTransforms en la carga de XrefObjects. La eliminamos
					--	y la anotamos para hacerlo luego a mano.
					nT = findItem xRefOptions #mergeTransformsAnimNodes
					nTA = findItem xRefOptions #mergeTransforms
					
					if nT != 0 then
					(
						deleteItem xRefOptions nT
						_mergeTransformsAnimNodes = true
					)
					
					if nTA != 0 then
					(
						deleteItem xRefOptions nTA
						mergeTransforms = true
					)
					
	 				--print ("Opciones finales de xref antes de cambiar: " + xRefOptions As String)
					
					--	creamos la nueva entrada de xRefObjects
					xRefRecord = objXRefMgr.AddXRefItemsFromFile filename objNames:objectsToLoad promptObjNames:false xRefOptions:xRefOptions
						
					--	seleccionamos los objetos
					items = #()
					nodes = #()
					nodesTMP = #()
					xRefRecord.getItems #XRefObjectType &items
					for i in items do (i.getNodes &nodesTMP; join nodes nodesTMP)
					select nodes
					
					-- Si se ha pedido cargar todos los objetos activamos el IncludeAll
					if xRefNodes.count == 0 then xRefRecord.includeAll = true		
					
					--	Si viene como opción #mergeTransforms, en las piezas animables mergeamos el controlador de animación 
					--	para poder manipularlas. Lo suyo sería hacerlo activando el tick Merge Transforms en el panel xRefObjects, 
					--	pero como no hay soporte para él a través de Maxscript lo hacemos a mano.
					tempAssets = this.getAssetsFromNodes nodes
					objsToMergeTransforms = #()
					
					if _mergeTransformsAnimNodes then
					(
						objsToMergeTransforms = #()
						for a in tempAssets do
							objsToMergeTransforms += (this.getAssetAnimNodes a lb.nc.NC_classAnim)
					)
					
					if mergeTransforms != 0 then
					(
						objsToMergeTransforms = #()
						for a in tempAssets do
							objsToMergeTransforms += this.getAssetNodes a
					)
					
					for o in objsToMergeTransforms do
						if classof o.controller == xRef_controller then
							o.controller = o.controller.getSourceCtrl true
					
						--quita el tick de includeall para que no meta todos los objetos la proxima vex que se abra el archivo
					xRefRecord.includeAll = false
					xRefRecord.update()
					
					--	restauramos la selección
					clearSelection()
					select oldSelection
					
					_assetNodes = nodes
				)
				
				#xRefMeshObjects:																					--	xRefObjects
				(
					--	capturamos la selección de objetos actual
					oldSelection = for o in selection collect o
					
					--	indicamos qué objetos del fichero xRef hay que cargar
					objectsToLoad = xRefNodes
					if xRefNodes.count == 0 then
					(
						if objectNames.count != 0 then
						(
							objectsToLoad = objectNames
						)
						else
						(
							objectsToLoad = getMAXFileObjectNames filename
							if objectsToLoad == undefined then objectsToLoad = #()
						)
					)
					
					--	Max no se come como opción #mergeTransforms en la carga de XrefObjects. La eliminamos
					--	y la anotamos para hacerlo luego a mano.
					nT = findItem xRefOptions #mergeTransformsAnimNodes
					nTA = findItem xRefOptions #mergeTransforms
					
					if nT != 0 then
					(
						deleteItem xRefOptions nT
						_mergeTransformsAnimNodes = true
					)
					
					if nTA != 0 then
					(
						deleteItem xRefOptions nTA
						mergeTransforms = true
					)
					
					--	creamos la nueva entrada de xRefObjects
					appendIfUnique xRefOptions #mergeModifiers

					xRefRecord = objXRefMgr.AddXRefItemsFromFile filename objNames:objectsToLoad promptObjNames:false xRefOptions:xRefOptions
					
					--	seleccionamos los objetos
					items = #()
					nodes = #()
					nodesTMP = #()
					xRefRecord.getItems #XRefObjectType &items
					for i in items do (i.getNodes &nodesTMP; join nodes nodesTMP)
					select nodes
					
					-- Si se ha pedido cargar todos los objetos activamos el IncludeAll
					if xRefNodes.count == 0 then xRefRecord.includeAll = true		
					
					--	Si viene como opción #mergeTransforms, en las piezas animables mergeamos el controlador de animación 
					--	para poder manipularlas. Lo suyo sería hacerlo activando el tick Merge Transforms en el panel xRefObjects, 
					--	pero como no hay soporte para él a través de Maxscript lo hacemos a mano.
					tempAssets = this.getAssetsFromNodes nodes
					objsToMergeTransforms = #()
					
					if _mergeTransformsAnimNodes then
					(
						objsToMergeTransforms = #()
						for a in tempAssets do
							objsToMergeTransforms += (this.getAssetAnimNodes a lb.nc.NC_classAnim)
					)
					
					if mergeTransforms != 0 then
					(
						objsToMergeTransforms = #()
						for a in tempAssets do
							objsToMergeTransforms += this.getAssetNodes a
					)
					
					for o in objsToMergeTransforms do
						if classof o.controller == xRef_controller then
							o.controller = o.controller.getSourceCtrl true
					
					--Obtenemos todos los objetos que no sean de tipo mesh y los mergeamos del todo
					for ast in tempAssets do
					(
						--print ast
						allAssetNodes = ast.nodes
						astMeshNodes = ast.meshNodesAll
						astClothNodes = ast.clothNodesAll

						astNoMeshNodes = for o in allAssetNodes where findItem (astMeshNodes + astClothNodes) o == 0 collect o
						for obj in astNoMeshNodes do
							objXRefMgr.MergeXRefItemsIntoScene obj.baseobject
						
	 					--for o in astNoMeshNodes do --mergeamos cada objeto que no sea un mesh
	 					--(
	 					--	o = o.GetSrcItem resolveNested:true
	 					--)
					)
					
					--quita el tick de includeall para que no meta todos los objetos la proxima vex que se abra el archivo
					if (xRefRecord as string) != "<MixinInterface:deleted interface>" then
					(
						xRefRecord.includeAll = false
						xRefRecord.update()
					)
					
					--	restauramos la selección
					clearSelection()
					select oldSelection
						
					_assetNodes = nodes
				)

				#xRefMeshObjectsAll:
				(
					--	capturamos la selección de objetos actual
					oldSelection = for o in selection collect o
					
					--	indicamos qué objetos del fichero xRef hay que cargar
					objectsToLoad = xRefNodes
					if xRefNodes.count == 0 then
					(
						if objectNames.count != 0 then
							objectsToLoad = objectNames
						else
							objectsToLoad = getMAXFileObjectNames filename
					)
					
					--	creamos la nueva entrada de xRefObjects
					xRefRecord = objXRefMgr.AddXRefItemsFromFile filename objNames:objectsToLoad promptObjNames:false xRefOptions:xRefOptions
						
					--	seleccionamos los objetos
					items = #()
					nodes = #()
					nodesTMP = #()
					xRefRecord.getItems #XRefObjectType &items
					for i in items do (i.getNodes &nodesTMP; join nodes nodesTMP)
					select nodes
					
					-- Se deja el includeAll activado para que meta los objetos nuevos
					xRefRecord.includeAll = true		
					
					--	Si viene como opción #mergeTransforms, en las piezas animables mergeamos el controlador de animación 
					--	para poder manipularlas. Lo suyo sería hacerlo activando el tick Merge Transforms en el panel xRefObjects, 
					--	pero como no hay soporte para él a través de Maxscript lo hacemos a mano.
					tempAssets = this.getAssetsFromNodes nodes
					objsToMergeTransforms = #()
					for a in tempAssets do objsToMergeTransforms += this.getAssetNodes a
					
					--mergea los controladores y bloquea sus pistas de transformacion
					for o in objsToMergeTransforms where (classof o.controller == xRef_controller) do
					(
						o.controller = o.controller.getSourceCtrl true
						lb.animation.setLocks o.transform.controller true affectChildren:true
						o.isfrozen = true
					)
					
					--	restauramos la selección
					clearSelection()
					select oldSelection
					
					_assetNodes = nodes
				)
			)
			
			-------------------------------------------------
			--Vamos a ver si tenemos nodos de LPM nuevos y si es así los reemparentaremos a nuestro root.
			if mode == #merge and _lpmRoot.count == 1 then
			(
				_lpmNewRoots = #()
				_lpmNodes = #()
				
				if (LayerManager.getLayerFromName lb.nc.NC_layerLPM) != undefined then
					(LayerManager.getLayerFromName lb.nc.NC_layerLPM).nodes &_lpmNodes
				
				--Vamos a recolectar todos los roots que no sean el inicial de la escena.
				for i=1 to _lpmNodes.count do
				(
					--Si el nodo es de root pero no es el inicial lo apilaré en mis nodos.
					if _lpmNodes[i].name == "LPM_Root" and _lpmNodes[i] != _lpmRoot[1] and classof _lpmNodes[i] != XRefObject then
						append _lpmNewRoots _lpmNodes[i]
				)
				
				--Ahora recorreré todos los nuevos roots, e iré reemparentando sus hijos al inicial.
				for i=_lpmNewRoots.count to 1 by -1 do
				(
					--Una primera pasada para reemparentar hijos
					for j=_lpmNewRoots[i].children.count to 1 by -1 do 
					(
						--Reemparentamos todos los pases
						if _lpmNewRoots[i].children[j].type == "pass" or _lpmNewRoots[i].children[j].type == "label" then
							_lpmNewRoots[i].children[j].parent = _lpmRoot[1]
					)
				)
				
				_deathList = deepCopy _lpmNewRoots
					
				--Una segunda pasada para eliminar
				for obj in _deathList do 
					for child in obj.children do
						append _deathList child
				
				--Elimino el root
					delete _deathList
			)
			-------------------------------------------------
			
	 		-------------------------------------------------
	 		--Si hay duplicados hay que renombrar el asset

	 		--obtiene los nuevos objetos de la escena
	 		_nodesAfterLoad = objects as array
	 		_newNodes = for o in _nodesAfterLoad where findItem _nodesBeforeLoad o == 0 collect o
	 		
	 		--averigua los nombres
	 		_newNodesAssetNames = #()
	 		for o in _newNodes do
	 		(
	 			_nParts = filterString o.name "_"
	 			if _nParts.count >= 2 then appendIfUnique _newNodesAssetNames (_nParts[1] + "_" + _nParts[2])
	 		)--for

	 		for _newAsset in _newNodesAssetNames do
	 		(
	 			_copyIndex = 0

	 			for _layer in _layersBeforeLoad where _newAsset == _layer or matchPattern _layer pattern:(_newAsset + "#*") do
	 			(
	 				if _newAsset == _layer then (if  _copyIndex == 0 then _copyIndex = 1)
	 				else
	 				(
	 					_tempIndex = (filterstring _layer "#")[2] as integer
	 					if _tempIndex >= _copyIndex then _copyIndex = _tempIndex + 1
	 				)--if else
	 			)--for

	 			if _copyIndex != 0 then
	 			(
	 				_defAssetName = _newAsset + "#" + (formattedPrint _copyIndex format:"03d")
	 				
	 				_newAssetLayer = lb.layer.newLayer name:_defAssetName
	 				for o in _newNodes where matchPattern o.name pattern:(_newAsset + "*") do
	 				(
	 					o.name = substituteString o.name _newAsset _defAssetName
	 					_newAssetLayer.addNode o
	 				)--for
	 			)--if
	 		)--for

	 		-------------------------------------------------
	 		--Bug de max, borramos materiales duplicados
	 		if mode != #open do
	 			lb.materials.deleteDuplicatedMaterials _assetNodes
	 		-------------------------------------------------
			
			_assetNodes --devolvemos los nodos del objeto
		),

		----------------------------------------------------------------------------------
		--oculta los controles extras de rig y facial
		--type puede ser #all, #anim, #facial
		----------------------------------------------------------------------------------
		fn hideExtraControls ast type =
		(
			this.showExtraControls ast type _hide:true
		),
		
		----------------------------------------------------------------------------------
		--muestra el sitema de animacion facial del asset
		----------------------------------------------------------------------------------
		fn showHeadSystem ast hideRigNodes:true =
		(
			--recorre los objetos de mesh mostrando los que sean del sistema facial
			for obj in (ast.meshNodesAll + ast.hairNodesAll) do
			(
				--si es de sistema facial
				if (lb.skinconnectioninfo.hasSkinConnectionInfo obj) and (obj.skinConnectionInfo.headSystem) then
				(
					if not (lb.nc.hasFlag obj lb.nc.NC_hiddenFlag) then obj.ishidden = false
					
					--habilita el modificador headSystem si es que el mesh lo tiene para ocultar poligonos que sobren
					_headSystemMod = obj.modifiers[#headSystem]
					if _headSystemMod != undefined then _headSystemMod.enabled = true
				)
				else
					obj.ishidden = true 
				
				obj.isfrozen = true --congela la malla
			)--for
			
			--recorre los objetos de rig (mostrando u ocultando) los que sean del sistema facial
			--si los tiene que mostrar, los pone en modo caja
			for obj in (ast.animNodesAll /*+ ast.facialNodesAll*/) where ((lb.skinconnectioninfo.hasSkinConnectionInfo obj) or hideRigNodes) do
			(
				--si el objeto de rig tiene skinConnectionInfo pero no headSystem, lo aculta.
				_forceHideRigNodes = false
				if (lb.skinconnectioninfo.hasSkinConnectionInfo obj) and not (obj.skinConnectionInfo.headSystem) then _forceHideRigNodes = true
				
				--coloca el hueso en el modo correcto
				obj.ishidden = hideRigNodes or _forceHideRigNodes or (lb.nc.hasFlag obj lb.nc.NC_hiddenFlag)
				obj.isfrozen = hideRigNodes or _forceHideRigNodes or (lb.nc.hasFlag obj lb.nc.NC_frozenFlag)
				obj.boxmode = not (hideRigNodes or _forceHideRigNodes)
			)--for		
		),

		----------------------------------------------------------------------------------
		--selecciona las piezas del ASSET que tengan los FLAGS
		--TYPE indica el tipo de piezas que quieres (All, rig, skin, mesh, facial, ....)
		--MODE (#or, #and) indica el modo de busqueda, todas las piezas que tengal alguno de los flags o todos los flags,
		----------------------------------------------------------------------------------
		fn selectAssetPiecesByFlag ast type flags mode:#and = 
		(
			--algun dia habra que rellenar la funcion digo yo o no.
		),

		----------------------------------------------------------------------------------
		--rellena todos los parametros de un asset que almacenan nodos
		----------------------------------------------------------------------------------
		fn fillAssetInfo newAsset layer =
		(
			newAsset.layer = layer
			
			--obtenemos el tipo y nombre del asset
			newAsset.fullname = layer.name
			layerParts = filterString layer.name "_"
			if layerParts.count > 1 then
			(
				newAsset.type = layerParts[1]
				newAsset.name = layerParts[2]
				assetNameParts = (filterString newAsset.name "-")
				newAsset.namePrefix = (filterstring (filterString assetNameParts[1] "()")[1] "{}")[1]
				newAsset.nameSuffix = if assetNameParts[2] != undefined then (filterstring (filterString assetNameParts[2] "()")[1] "{}")[1]
				
				part = (filterString newAsset.name "()")[2]
				if part != undefined then
				(
					newAsset.part = part
					partParts = filterstring part "-"
					newAsset.partPrefix = partParts[1]
					newAsset.partSuffix = if partParts[2] != undefined then partParts[2] else ""
				)
				
				preset = (filterString newAsset.name "{}")[2]
				if preset != undefined then
				(
					newAsset.preset = preset
					presetParts = filterstring preset "-"
					newAsset.presetPrefix = presetParts[1]
					newAsset.presetSuffix = if presetParts[2] != undefined then presetParts[2] else ""
				)
				
				--obtenemos el numero de copia
				copyN = (filterString layerParts[2] "#")[2]
				copyN = (if copyN != undefined then copyN as integer else 0)
				newAsset.copyNumber = copyN
			)
			
			--nodos de la capa
			nodes = #()
			(newAsset.layer).nodes &nodes
			newAsset.nodes = nodes
				
			--	si es un asset cargado por xRefScenes anotamos los datos necesarios
			if this.getAssetXRefScene newAsset != undefined then
			(
				nodes = this.getAssetNodesFromXrefScenes newAsset
				newAsset.nodes = nodes
				newAsset.isXrefScene = true
			)
			
			--rellena los arrays de piezas de cada tipo---------------------------
			if not newAsset.isXrefScene then
			(
				newAsset.meshNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classMesh + "_*_*_*_*'")) as array
				--newAsset.draftNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classDraft + "_*_*_*_*'")) as array
				newAsset.proxyNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classProxy + "_*_*_*_*'")) as array
				newAsset.morphNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classMorph + "_*_*_*_*'")) as array
				newAsset.puppetNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classPuppet + "_*_*_*_*'")) as array
				newAsset.facialNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classFacial + "_*_*_*_*'")) as array
				newAsset.facialEditNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classFacialEdit + "_*_*_*_*'")) as array
				newAsset.animNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classAnim + "_*_*_*_*'")) as array
				newAsset.animEditNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classAnimEdit + "_*_*_*_*'")) as array
				newAsset.skinNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classSkin + "_*_*_*_*'")) as array
				newAsset.hairNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classHair + "_*_*_*_*'")) as array
				newAsset.clothNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classCloth + "_*_*_*_*'")) as array
				newAsset.dynNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classDynamic + "_*_*_*_*'")) as array
				newAsset.fxNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classFx + "_*_*_*_*'")) as array
				newAsset.lightNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classLight + "_*_*_*_*'")) as array
				newAsset.connectNodesAll = (execute ("$'" + newAsset.fullName + "_" + lb.nc.NC_classConnect + "_*_*_*_*'")) as array
			)
			else
			(
				for obj in nodes where lb.nc.ncOK obj.name do
				(
					nameParts = filterString obj.name "_"
					
					case nameParts[3] of
					(
						(lb.nc.NC_classMesh):
						(
							append newAsset.meshNodesAll obj
							
							nParts = filterString obj.name "_"
							
							if findString nParts[7] lb.nc.NC_draftFlag != undefined then append newAsset.meshNodesl0 obj
							else if findString nParts[7] lb.nc.NC_lowResFlag != undefined then append newAsset.meshNodesl1 obj
							else if findString nParts[7] lb.nc.NC_middleResFlag != undefined then append newAsset.meshNodesl2 obj
							else if findString nParts[7] lb.nc.NC_highResFlag != undefined then append newAsset.meshNodesl3 obj
						)
						
						(lb.nc.NC_classProxy): append newAsset.proxyNodesAll obj
						(lb.nc.NC_classMorph): append newAsset.morphNodesAll obj
						(lb.nc.NC_classPuppet): append newAsset.puppetNodesAll obj
						(lb.nc.NC_classFacial): append newAsset.facialNodesAll obj
						(lb.nc.NC_classFacialEdit): append newAsset.facialEditNodesAll obj
						(lb.nc.NC_classAnim): append newAsset.animNodesAll obj
						(lb.nc.NC_classAnimEdit): append newAsset.animEditNodesAll obj
						(lb.nc.NC_classSkin): append newAsset.skinNodesAll obj
						(lb.nc.NC_classHair): append newAsset.hairNodesAll obj
						(lb.nc.NC_classCloth): append newAsset.clothNodesAll obj
						(lb.nc.NC_classDynamic): append newAsset.dynNodesAll obj
						(lb.nc.NC_classFx): append newAsset.fxNodesAll obj
						(lb.nc.NC_classLight): append newAsset.lightNodesAll obj
						(lb.nc.NC_classConnect): append newAsset.connectNodesAll obj
					)--case
				)--for
			)--else
			--------------------------------------------------------------------------
			
			--detecta si es un asset de layout
			_assetNameParts = filterString newAsset.name ":"
			if _assetNameParts[2] == lb.nc.NC_layoutFileName then newAsset.isLayoutAsset = true

			--detecta si los objetos de mesh están metidos por xrefObject y pone a true esa propiedad entonces
			if not newAsset.isXrefScene and newAsset.meshNodesAll.count != 0 then
			(
				if classof newAsset.meshNodesAll[1] == XrefObject then
					newAsset.isXrefObject = true
			)--if
			
			---- detecta si es un asset de tipo draft o cache
			--for i=1 to nodes.count where isValidNode nodes[i] and lb.nc.ncOK nodes[i].name do
			--(
			--	nameParts = filterString nodes[i].name "_"
				
			--	--if nameParts[3] == lb.nc.NC_classMesh then
			--	--(
			--	--	if (filterString nameParts[2] "-")[2] == lb.nc.NC_classDraft then 
			--	--		newAsset.isDraftAsset = true
			--	--)--if
			--)

			--detecta si el asset es de tipo draft
			if newAsset.meshNodesAll.count != 0 then
			(
				stop = false
				_isDraftAsset = true

				for meshNode in newAsset.meshNodesAll where not stop do
				(
					if lb.nodeInfo.hasNodeInfo meshNode and meshNode.nodeInfo.fileHistory.count != 0 then
					(
						_fhParts = filterString (getFileNameFile (meshNode.nodeInfo.fileHistory[meshNode.nodeInfo.fileHistory.count])) "_"
						if _fhParts[3] != lb.nc.NC_draftFileName then
						(
							_isDraftAsset = false
							stop = true
						)
					)
					else
					(
						_isDraftAsset = false
						stop = true
					)
				)--for

				newAsset.isDraftAsset = _isDraftAsset
			)--if
			
			--detecta si alguna pieza de rig del asset tiene Puppets
			stop = false
			for rigNode in (newAsset.animNodesAll) where not stop do
			(
				for m in rigNode.modifiers where findString m.name "Puppet" != undefined do
				(
					newAsset.hasPuppets = true
					stop = true
				)
			)
			
			--detecta si alguna pieza de mesh del asset tiene Proxy
			stop = false
			for meshNode in newAsset.meshNodesAll where not stop do
			(
				for m in meshNode.modifiers where findString m.name "Proxy" != undefined do
				(
					newAsset.hasProxy = true
					stop = true
				)
			)
			
			--obtiene el folder del asset, version, filePath y loadMode
			if nodes.count != 0 then
			(
				stop = false
				cont = 1
				while not stop and cont <= nodes.count do
				(
					_node = nodes[cont]
					if isValidNode _node and lb.nodeInfo.hasNodeInfo _node and (findItem newAsset.connectNodesAll _node) == 0 then
					(
						newAsset.folder = lb.nodeInfo.getNodeAssetFolder _node type:#actual
						if newAsset.folder == undefined or newAsset.folder == "undefined" do
						(
							cont += 1
							continue
						)
						newAsset.version = lb.nodeInfo.getNodeAssetVersion _node type:#actual -- TO DO: se equivoca con algun asset y por eso falla luego el modo de carga del asset
						newAsset.filePath = _node.fileHistory[1]
						
						if newAsset.filePath != undefined then
						(
							_fileParts = filterString (getFileNameFile newAsset.filePath) "_"
							newAsset.subType = if _fileParts[3] != undefined then _fileParts[3] else ""
							_subTypeParts = if newAsset.subType != undefined then (filterString newAsset.subType "-") else #()
							newAsset.subTypePrefix = if _subTypeParts[1] != undefined then _subTypeParts[1] else ""
							newAsset.subTypeSuffix = if _subTypeParts[2] != undefined then _subTypeParts[2] else ""
						)
						
						--	recopilamos todos los ficheros del asset
						_files = #()
						_filesLoadMode = #()
						
						for _node in newAsset.nodes where lb.nodeInfo.hasNodeInfo _node do 
						(
							if _node.nodeInfo.fileHistory.count > 0 then
							(
								_file = _node.nodeInfo.fileHistory[_node.nodeInfo.fileHistory.count]
								if findItem _files _file == 0 then
								(
									if findString _node.name lb.nc.NC_classHair != undefined then
									(
										--el postopen y postmerge saltan antes de que max reconozca los classof de hairfarm, dando un unknown system exception 
										try
										(
											_loadMode = if classOf _node == XRefObject then #xrefObjects else #merge

											append _files _file
											append _filesLoadMode _loadMode
										)
										catch()
									)
									else
									(
										_loadMode = if classOf _node == XRefObject then #xrefObjects else #merge

										append _files _file
										append _filesLoadMode _loadMode
									)--if else
								)--if
							)
						)
						
						newAsset.files = _files
						newAsset.filesLoadMode = _filesLoadMode
						
						--rellena el parametro filePath y loadMode
						if (getFilenameType newAsset.filePath) == ".prt" then
						(
							newAsset.loadMode = #load
						)
						else
						(
							if newAsset.meshNodesAll.count != 0 then
							(
								if (newAsset.folder != undefined and newAsset.version != undefined) then
								(
									--si el nodo esta por xref puede ser xrefMeshObjects o xRefMeshObjectsAll si estan los controladores bloqueados
									if classof newAsset.meshNodesAll[1] == XRefObject then
									(
										newAsset.loadMode = #xrefMeshObjects
										if lb.animation.isLockedTransform (newAsset.meshNodesAll[1]) considerOverride:false then newAsset.loadMode = #xrefMeshObjectsAll
									)
									else --si no, es merge
									(
										newAsset.loadMode = #merge
									)
									
									if newAsset.animNodesAll.count != 0 then
									(
			 							if classof newAsset.animNodesAll[1] == XRefObject then newAsset.loadMode = #xrefObjects
									)
									else if newAsset.facialNodesAll.count != 0 then
									(
										if classof newAsset.facialNodesAll[1] == XRefObject then newAsset.loadMode = #xrefObjects
									)
									else if newAsset.clothNodesAll.count != 0 then
									(
										newAsset.loadMode = if classof newAsset.clothNodesAll[1] == XRefObject then #xrefObjects else #merge
									)
									else if newAsset.hairNodesAll.count != 0 then
									(
										newAsset.loadMode = if classof newAsset.hairNodesAll[1] == XRefObject then #xrefObjects else #merge
									)
									else if newAsset.lightNodesAll.count != 0 then
									(
										newAsset.loadMode = if classof newAsset.lightNodesAll[1] == XRefObject then #xrefObjects else #merge
									)
								)
							)
							else
							(
								if newAsset.animNodesAll.count != 0 then
								(
									newAsset.loadMode = if classof newAsset.animNodesAll[1] == XRefObject then #xrefObjects else #merge
								)
								else if newAsset.facialNodesAll.count != 0 then
								(
									newAsset.loadMode = if classof newAsset.facialNodesAll[1] == XRefObject then #xrefObjects else #merge
								)
								else if newAsset.clothNodesAll.count != 0 then
								(
									newAsset.loadMode = if classof newAsset.clothNodesAll[1] == XRefObject then #xrefObjects else #merge
								)
								else if newAsset.hairNodesAll.count != 0 then
								(
									newAsset.loadMode = if classof newAsset.hairNodesAll[1] == XRefObject then #xrefObjects else #merge
								)
								else if newAsset.lightNodesAll.count != 0 then
								(
									newAsset.loadMode = if classof newAsset.lightNodesAll[1] == XRefObject then #xrefObjects else #merge
								)
							)
						)

						stop = true
					)
					
					cont += 1
				)--while
			)--if
			
			--Rellenamos los efectos atmosfericos de los assets de fx
			if newAsset.type == lb.nc.NC_fxFileName then
			(
				--Recorremos todos los atmosfericos.
				for i=1 to numAtmospherics do
				(
					if matchPattern (getAtmospheric i).name pattern: (newAsset.fullname + "_*") or matchPattern (getAtmospheric i).name pattern: ("XRef(" + newAsset.fullname + "_*)") then
					(
						append newAsset.fxAtmospherics (getAtmospheric i)
					)
				)
			)
		),

		----------------------------------------------------------------------------------
		--	ordena los elementos del listado de assets ASSETLIST
		----------------------------------------------------------------------------------
		fn sortAssets assetList =	
		(
			names = #()
			sortedAssetList = #()
			
			for a in assetList do
				appendIfUnique names a.fullName
				
			sort names
			
			for a in assetList do
				sortedAssetList[findItem names a.fullName] = a
				
			sortedAssetList
		),

		----------------------------------------------------------------------------------
		-- Crea una copia del asset AST indicado y la localiza en la posición pos
		----------------------------------------------------------------------------------
		fn copyAsset ast dependentAssets:#() pos:[0,0,0] rot:(quat 1) scale:[1,1,1] =
		(
	 		--start = timeStamp() --tiempo de inicio de la copia
			
			dependentAssetsNames = for a in dependentAssets collect (a.type + "_" + a.name)
			copiedAssets = #() --assets copiados
			
			if not ast.isXrefScene then --si el asset es un XrefScene no puede hacer un copy asique se descarta
			(			
				copyMode = #copy --modo de copia
				
				--segun el tipo de asset tiene que hacer la copia en modo copia o en modo merge
				case ast.type of
				(
					(lb.nc.NC_chrPrefix): --caso para personajes
					(
						--print "es un personaje"
							
						copyMode = #merge
					)--lb.nc.NC_chrPrefix
					
					default: --caso para el resto de tipos de asset
					(
						--print "no es un personaje"
						copyMode = #copy
						
						--si es un asset dependiente de un personaje, hay que meterlo por merge igualmente
						if ast.isDependent and findString ast.mainAsset lb.nc.NC_chrPrefix != undefined then
							copyMode = #merge
					)--default
					
				)--case segun el tipo de asset

				allAssets = if this.sceneAssets != undefined and this.sceneAssets.count != 0 then this.sceneAssets else this.getSceneAssets()
				
				--segun el modo de copia merge el asset o lo copia directamente
				case copyMode of
				(
					#merge:
					(
						with undo off --dasactiva los undos para el caso de merge
						(
							if doesFileExist ast.filePath then --si no existe el archivo del que mergear ni lo intenta
							(
								objsToMergeNames = getMAXFileObjectNames ast.filePath quiet:true --nombres de los objetos del archivo a mergear
								
								--si hay que cargar algun asset dependiente, necesita conocer los nombres de los objetos
								if dependentAssetsNames.count != 0 then
									append dependentAssetsNames (ast.type + "_" + ast.name)
								else
									dependentAssetsNames = #((ast.type + "_" + ast.name))
								
								defNames = #()
								
								for n in objsToMergeNames do
									for depA in dependentAssetsNames where findString n depA != undefined do
										appendIfUnique defNames n
									
								objsToMergeNames = defNames
								
								--si es un personaje hay que mirar cual es el modo en el que fue cargado y volver a cargarlo
								newAssetsNodes = this.loadAsset ast.filePath ast.loadMode objectNames:objsToMergeNames xRefOptions:#(#mergeModifiers,#mergeTransformsAnimNodes)
								newAssets = this.getAssetsFromNodes newAssetsNodes --obtiene los nuevos assets
								
								depNewAssets = #() --array de arrays con los assets nuevos agrupados por dependientes
								
								--agrupa los nuevos assets por grupos de dependencia, para poder obtener el numero de copia en conjunto
								for a in newAssets do
								(
									found = false --flag para saber si ya se ha tratado
									
									for dg in depNewAssets where not found do --averigua si ya se ha tratado ese asset
										for da in dg where not found do
											if a.fullName == da.fullName then found = true
									
									if not found then -- si no se había tratado se busca su grupo de dependencia
									(
										depGroup = this.getDependencyGroup a allAssets
										append depNewAssets depGroup
									)
								)
								
								--recorre esos grupos de dependencia separando los objetos nuevos en assets nuevos
								-- y asignandoles el numero de copia que les toque.
								for dg in depNewAssets do
								(
									assetsToProcess = #()
									
									for da in dg do
										for a in newAssets where a.fullname == da.fullname do
											appendIfUnique assetsToProcess da
										
									newCopyNumber = this.getNewAssetCopyNumber assetsToProcess
									
									if newCopyNumber > 0 then --si el numero de copia es mayor que 0 hay que asignarle numero de copia
									(
										for a in assetsToProcess do
										(
											assetName = a.type + "_" + a.name
											
											--allAssets = (this.getSceneAssets())
											
											--	si encontramos el asset cargado en la escena, le asignamos un número de copia
											if (this.findAssetByName allAssets assetName != 0) then
											(
												newLayerName = "<newAssetLayer>"
												l = layerManager.newLayerFromName newLayerName		--	Creamos el nuevo layer
												if l == undefined then l = layerManager.getLayerFromName newLayerName	--	si ya existía el layer lo capturamos directamente
												
												--  creamos e iniciamos el nuevo asset
												newAsset = a
												oldLayer = a.layer
												a.layer.nodes &layerNodes
												newAsset.nodes = for o in newAssetsNodes where (finditem layerNodes o != 0) collect o -- recopilamos los nodos del nuevo asset
												newAsset.layer = l
												
												this.setAssetCopyNumber newAsset newCopyNumber
												
												oldLayer.nodes &oldLayerNodes
												if newCopyNumber == 1 or oldLayerNodes.count == 0 then
													LayerManager.deleteLayerByName oldLayer.name
												
												this.fillAssetInfo newAsset l
												append copiedAssets newAsset
												append allAssets newAsset										
											)
										)--for a in newAssets
									)--if newCopyNumber
								)--for dg
								
							)--doesFileExist
						)--with undo off
					)--merge
					
					#copy:
					(
						--obtiene los nodos de los assets a copiar
						assetsToCopyNodes = ast.nodes
						for ast in dependentAssets do assetsToCopyNodes += ast.nodes
						
						actualNodes = #()
						newAssetsNodes = #()
						maxOps.cloneNodes assetsToCopyNodes actualNodeList:&actualNodes newNodes:&newAssetsNodes
						
						--si hay nodos de assets a copiar
						if newAssetsNodes.count != 0 then
						(
							newAssets = this.getAssetsFromNodes newAssetsNodes --obtiene los nuevos assets
							
							depNewAssets = #() --array de arrays con los assets nuevos agrupados por dependientes
							
							--agrupa los nuevos assets por grupos de dependencia, para poder obtener el numero de copia en conjunto
							for a in newAssets do
							(
								found = false --flag para saber si ya se ha tratado
								
								for dg in depNewAssets where not found do --averigua si ya se ha tratado ese asset
									for da in dg where not found do
										if a.fullName == da.fullName then found = true
								
								if not found then -- si no se había tratado se busca su grupo de dependencia
								(
									depGroup = this.getDependencyGroup a allAssets
									append depNewAssets depGroup
								)
							)
							
							--recorre esos grupos de dependencia separando los objetos nuevos en assets nuevos
							-- y asignandoles el numero de copia que les toque.
							for dg in depNewAssets do
							(
								assetsToProcess = #()
								
								for da in dg do
									for a in newAssets where a.fullname == da.fullname do
										appendIfUnique assetsToProcess da
									
								newCopyNumber = this.getNewAssetCopyNumber assetsToProcess
								
								if newCopyNumber > 0 then --si el numero de copia es mayor que 0 hay que asignarle numero de copia
								(
									for a in assetsToProcess do
									(
										assetName = a.fullname --a.type + "_" + a.name
										
										--	si encontramos el asset cargado en la escena, le asignamos un número de copia
										if (this.findAssetByName allAssets assetName != 0) then
										(
											newLayerName = "<newAssetLayer>"
											l = layerManager.newLayerFromName newLayerName		--	Creamos el nuevo layer
											if l == undefined then l = layerManager.getLayerFromName newLayerName	--	si ya existía el layer lo capturamos directamente
											
											--  creamos e iniciamos el nuevo asset
											newAsset = (deepCopy #(a))[1] --a --(asset layer:l)
											oldLayer = a.layer
											a.layer.nodes &layerNodes
											newAsset.nodes = for o in newAssetsNodes where (finditem layerNodes o != 0) collect o -- recopilamos los nodos del nuevo asset
											newAsset.layer = l
											
											this.setAssetCopyNumber newAsset newCopyNumber
											
											oldLayer.nodes &oldLayerNodes
											if newCopyNumber == 1 or oldLayerNodes.count == 0 then
												LayerManager.deleteLayerByName oldLayer.name
											
											this.fillAssetInfo newAsset l
											append copiedAssets newAsset
											append allAssets newAsset										
										)
									)--for a in newAssets
								)--if newCopyNumber
							)--for dg
						)--if assetsToCopyNodes						
					)--copy
				)
			)--if XrefScene
			
			 -- si se han conseguido copiar assets, hay que recolocarlos segun la posicion pasada por parametro
			if copiedAssets.count != 0 then
				for ast in copiedAssets where not ast.isDependent do --coloca los nuevos assets en la nueva posicion
				(
					nodeToLocate = this.getAssetRootNode ast
					if nodeToLocate != undefined then
					(
						--coloca el asset en la nueva posicion.
						nodeToLocate.pos = pos
						
						--actualiza la rotacion del nuevo asset.
						newRot = (nodeToLocate.transform.rotation - rot) as eulerangles
						rotate nodeToLocate newRot
						--in coordsys (transmatrix nodeToLocate.pos) (nodeToLocate.rotation = rot)
						
						--actualiza la escala del nuevo asset.
						nodeToLocate.scale = scale
					)
				)
			--if copiedAssets------------------------------------------------------------------------------------------
			
			copiedAssets --develve los assets copiados
		),
		
		----------------------------------------------------------------------------------
		-- Ducplica los objetos pasados por parametro y los coloca, rota y escala según lo indicado
		-- mode:
		----------------------------------------------------------------------------------
		fn copyObjects nodes mode:#copy sufix:"" index:"" transform:undefined pos:[0,0,0] rot:(quat 1) scale:[1,1,1] =
		(
			copiedObjects = #() --array donde se almacenarán los nuevos objetos
			actualNodes = #()
	 		--nodesBckp = deepCopy nodes
			maxOps.cloneNodes nodes cloneType:mode actualNodeList:&actualNodes newNodes:&copiedObjects
			
			if copiedObjects.count != 0 then --si ha conseguido copiar objetos
			(
				hierarchies = lb.rig.getHierarchiesFromNodes copiedObjects --obtiene las jerarquías de los objetos copiados
				
				for h in hierarchies do
				(
					nodeToLocate = h[1]
					
					--si se le ha pasado una matrix completa a la funcion se le aplica esa
					--si no se le ha pasado, se crea una a partir de pos, rot y scale
					newMatrix = transform
					if newMatrix == undefined then
					(
						newMatrix = matrix3 1
						newMatrix.pos = pos
						newMatrix.rotation = rot
						newMatrix.scale = scale
					)
					----------------------------------------------------------------------------
						
					nodeToLocate.transform = newMatrix
						/* --coloca el asset en la nueva posicion.
						nodeToLocate.pos = pos
						
						--actualiza la rotacion del nuevo asset.
						newRot = (nodeToLocate.transform.rotation - rot) as eulerangles
						rotate nodeToLocate newRot
						--in coordsys (transmatrix nodeToLocate.transform.pos) (nodeToLocate.rotation = rot)
						
						--actualiza la escala del nuevo asset.
						nodeToLocate.scale = scale */
					
					--si hay que añadirle un sufijo y/o un indice
					if sufix != "" or index != "" then
					(
						for obj in h do
						(
							auxName = obj.name
							stop = false
							
							for i=auxName.count to 1 by -1 where not stop do
								if lb.math.isNumeric auxName[i] then
									auxName = subString auxName 1 (i-1)
								else
									stop = true
							
							nParts = filterString auxName "_"
							
							--si cumple el NC hay que poner el sufijo y el inidce en la parte 5 del nombre, si no lo cumple, el final
							if nParts.count == lb.nc.NC_objectNamesLength then
								obj.name = substituteString auxName ("_" + nParts[5] + "_") ("_" + nParts[5] + sufix + "-" + (index as string) + "_")
							else
								obj.name = auxName + sufix + (index as string)
						)--for						
					)--if
					
				)--for h
			)--if copiedAssets
			
	 		--nodes = nodesBckp
			copiedObjects --devuelve los nuevos objetos
		),

		------------------------------------------------
		--elimina las modificaciones específicas de un asset para la cámara abierta
		--necesita que le pases un asset con el que trabajar
		------------------------------------------------
		fn removeAssetCameraVariations assetToUse =
		(
			disableSceneRedraw()
			for o in assetToUse.nodes do
				for i=o.modifiers.count to 1 by -1 do
				(
					m = o.modifiers[i]
					if MatchPattern m.name pattern:"s???*-c???" then deleteModifier o m
				)--for
			EnableSceneRedraw()
			completeRedraw()
	  ),

		------------------------------------------------
		--carga las modificaciones específicas de un asset para la cámara abierta
		--necesita que le pases un asset con el que trabajar
		------------------------------------------------
		fn loadAssetCameraVariations assetToUse type:undefined=
		(
			_errlog = ""
			if MatchPattern maxfilename pattern:"seq_???*_cam???_*" or MatchPattern maxfilename pattern:"seq_*_layout.max" then
			(
				------------------------------------------------
				--busca los archivos especificos para camara del set pasado por parametro para la cámara abierta

				_fParts = filterString (getFilenameFile maxfilename) "_"
				_seq = (filterString _fParts[2] "-")[1]
				_cam = substituteString _fParts[3] "cam" ""
				
				if type == undefined then
					case _fParts[4] of
					(
						(lb.nc.NC_animFileName): _type = lb.nc.NC_draftFileName
						(lb.nc.NC_PCFileName): _type = lb.nc.NC_meshFileName
						(lb.nc.NC_renderFileName): _type = lb.nc.NC_meshFileName
						default: _type = lb.nc.NC_draftFileName
					)--case
				else
					_type = type

				_seqCamAssetPart = "s" + _seq + "-c" + _cam
				-- Buscamos que coincidan en versión y subversión
				_isreplacement = true

				-- Buscamos si se ha sacado de un part y se llama main
				_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "?" + assetToUse.part + "." + _seqCamAssetPart + "-replacement?",  _type, "v??.max") "_"
				_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)

				if _camAssetFiles.count == 0 do
				(
					--print _camAssetFilePattern
					-- Buscamos que coincidan en versión
					_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "?" + assetToUse.partPrefix + "-*." + _seqCamAssetPart + "-replacement?",  _type, "v??.max") "_"
					_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
				)

				if _camAssetFiles.count == 0 do
				(
					--print _camAssetFilePattern
					-- Buscamos el estándar
					_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "?std-std" + "." + _seqCamAssetPart + "-replacement?",  _type, "v??.max") "_"
					_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
				)
				
				if _camAssetFiles.count == 0 do
				(
					--print _camAssetFilePattern
					-- Buscamos si se ha sacado de un part y se llama main
					_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "?main-std" + "." + _seqCamAssetPart + "-replacement?",  _type, "v??.max") "_"
					_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
				)

				if _camAssetFiles.count == 0 do
				(
					--print _camAssetFilePattern
					-- Buscamos que coincidan en versión
					_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "?" + assetToUse.part + "." + _seqCamAssetPart + "?",  _type, "v??.max") "_"
					_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
					_isreplacement = false
				)
				
				if _camAssetFiles.count == 0 do
				(
					--print _camAssetFilePattern
					-- Buscamos que coincidan en versión
					_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "?" + assetToUse.partPrefix + "-*." + _seqCamAssetPart + "?",  _type, "v??.max") "_"
					_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
					_isreplacement = false
				)

				if _camAssetFiles.count == 0 do
				(
					--print _camAssetFilePattern
					-- Buscamos el estándar
					_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "?std-std" + "." + _seqCamAssetPart + "?",  _type, "v??.max") "_"
					_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
					_isreplacement = false
				)
				
				if _camAssetFiles.count == 0 do
				(
					--print _camAssetFilePattern
					-- Buscamos si se ha sacado de un part y se llama main
					_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "{" + "*-*" + "." + _seqCamAssetPart + "-replacement}",  _type, "v??.max") "_"
					_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
					_isreplacement = true
				)

				if _camAssetFiles.count == 0 do
				(
					--print _camAssetFilePattern
					-- Buscamos si se ha sacado de un part y se llama main
					_camAssetFilePattern = lb.str.join #(assetToUse.type, assetToUse.namePrefix + "*-*" + "." + _seqCamAssetPart + "*",  _type, "v??.max") "_"
					_camAssetFiles = getFiles (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
					_isreplacement = false
				)

				------------------------------------------------

				------------------------------------------------
				--si hay archivos coge el más reciente por numero de version y lo carga

				if _camAssetFiles.count != 0 then
				(
					if (not _isreplacement) then 
					(
						--print "Entro"
						_camAssetFile = _camAssetFiles[_camAssetFiles.count]

						--print "Uso este"
						--print _camAssetFiles
						DisableSceneRedraw()

						_objsBefore = objects as array
						_merged = mergeMAXFile _camAssetFile #mergeDups #useSceneMtlDups #neverReparent quiet:true
						_objsAfter = objects as array

						_newObjects = #()
						_layers = #()
						
						--si consigue hacer el merge
						if _merged then
						(
							--print "Merge conseguido"
							completeRedraw()
							--Comentado porque puede estar rompiendo referencias
							--objXRefMgr.UpdateAllRecords()

							_newObjects = for o in _objsAfter where (findItem _objsBefore o) == 0 collect o --averigua los objetos nuevos
							--print _newObjects
							------------------------------------------------
							--para cada objeto nuevo busca su equivalente en los viejos y si lo encuentra le pega los modificadores de variacion

							_objsBeforeNames = for o in _objsBefore collect o.name

							for o in _newObjects do
							(
								appendifUnique _layers o.layer

								--if classof o == XRefObject then objXRefMgr.MergeRecordIntoScene o.xrefRecord --no sé por qué estaba esto aquí
								
								--Miramos si esta el objeto tal como su nombre
								_index = findItem _objsBeforeNames o.name
								--Si hemos pillado el nombre del part sustituiremos los corchetes y el main por std
								if _index == 0 then
								(
									--Primero miraremos el nombre cambiando los paréntesis por corchetes
									_target = lb.misc.getNodeByPattern (substituteString (substituteString o.name "(" "?") ")" "?")
									--print (substituteString (substituteString o.name "(" "?") ")" "?")
									if _target != undefined and _target != o then
									(
										_index = findItem _objsBeforeNames _target.name
									)
									else
									(
										--Si aun así no lo encuentra, sustituiremos paréntesis y main por std
										if (findString o.name "main-") != undefined then
										(
											_target = lb.misc.getNodeByPattern(substituteString (substituteString (substituteString o.name "(" "?") ")" "?") "main-" "std-")
											--print (substituteString (substituteString (substituteString o.name "(" "?") ")" "?") "main-" "std-")
											if _target != undefined then
											(
												_index = findItem _objsBeforeNames _target.name
											)
										)
									)
								)

								if _index != 0 then
								(
									--print "Llego"
									--si el objeto al que pegar los modificadores es xref lo actualiza para evitar errores
									--if classof _objsBefore[_index] == XRefObject then _objsBefore[_index].xrefRecord.Update() --no sé por qué estaba esto aquí

									--recopila los modificadores que copiar y los aplica a los objetos originales
									_modsOnTop = #(TurboSmooth)
									for m in o.modifiers where MatchPattern m.name pattern:"s???*-c???" and ((classof m == XForm) or (classof m == Morpher)) do
									(
										_m = copy m
										_m.name = m.name
										_beforeIndex = 1
										for i=1 to _objsBefore[_index].modifiers.count where findItem _modsOnTop (classof _objsBefore[_index].modifiers[i]) != 0 do _beforeIndex = i

										addModifier _objsBefore[_index] _m before:_beforeIndex
									)
								)--if
								else
								(
									_errlog += "Matching object not found for variation -> " + o.name  + "\n"
								)
							)--for
							------------------------------------------------
						)--if

						--despues elminina los objetos nuevos

						delete _newObjects

						--Y sus capas si están vacías
						for i=_layers.count to 1 by -1 do
						(
							_layerNodes = #()
							_layers[i].nodes &_layerNodes
							if _layerNodes.count == 0 do
							(
								LayerManager.deleteLayerByName _layers[i].name
							)
						)
						EnableSceneRedraw()
						completeRedraw()

					)
					else 
					(
						--Si se trata de un replacement.
						_loadedSets = lb.asset.getSceneAssets type:lb.nc.NC_setPrefix

						DisableSceneRedraw()

						for _set in _loadedSets do 
						(
							lb.asset.deleteAsset _set
						)
						_camAssetFile = _camAssetFiles[_camAssetFiles.count]
						_merged = mergeMAXFile _camAssetFile #mergeDups #useSceneMtlDups #neverReparent quiet:true

						EnableSceneRedraw()
						completeRedraw()
						objXRefMgr.updateAllRecords() 
					)
				)--if
				else
				(
					_errLog += "Variation files not found matching this pattern: " + (maxfilePath + "..\\asset\\" + _camAssetFilePattern)
				)
				------------------------------------------------
			)--if
			else
			(
				_errLog += "Not a sequence file, aborting. Please open a sequence file to proceed."
			)

			if _errLog != "" then
			(
				print _errlog
				--lb.message.show _errLog type:#message modal:true
			)
			else
			(
				--lb.message.show "Variation imported successfully" type:#message modal:true
				print (maxfilename + " variation loaded successfully.")
			)
		),
		
		------------------------------------------------
		--prepare animation. 
		------------------------------------------------
		fn prepareAnimation assetToUse previousFrames =
		(
			_firstFrame = animationRange.start --	primer fotograma del rango de animación

			------------------------------------------------
			--Desconectamos el rig de skin del asset
			_skinConnected = this.isSkinConnected assetToUse			
			if _skinConnected then this.setSkinConnection assetToUse false 
			------------------------------------------------
			
			------------------------------------------------
			--Obtenemos los nodos de animación, el root y la base
			_animNodes = this.getAssetAnimNodes assetToUse #all
			------------------------------------------------

			------------------------------------------------
			_baseNode = (this.getAssetRootNode assetToUse)
			_rootNode = undefined
			
			for _animNode in _animNodes do
			(
				if (filterString _animNode.name "_")[5] == lb.nc.NC_ANIM_root then
				(
					_rootNode = _animNode
				)
			)
			------------------------------------------------

			------------------------------------------------
			--Guardamos las transformaciones de ambos nodos
			at time _firstFrame
			(
				_baseNodeOriginalTransform = _baseNode.transform
			)
			
			_posOffset = (at time _firstFrame _rootNode.pos) - (at time (_firstFrame - (previousFrames/2)) _rootNode.pos)
			------------------------------------------------

			------------------------------------------------
			--Creamos una clave en todos los nodos de animación al comienzo del rango
			for _o in _animNodes where not (lb.animInfo.hasAnimTracksKey _o time:_firstFrame ignoreLinkTimes:true) do lb.animInfo.createAnimTracksKey _o time:_firstFrame
			------------------------------------------------

			------------------------------------------------
			-- Borramos la animación que pueda haber antes del primer fotograma de animación
			lb.animation.deleteAnimation _animNodes (interval -1000 (_firstFrame-1))	
			------------------------------------------------

			------------------------------------------------
			--obtiene los nodos que lleven point constraint y les crea clave al mundo en el frame de inicio del prepare

			_pointConstraintNodes = for o in _animNodes where lb.links.pointConstraint.hasPCAttribute o collect o
			for o in _pointConstraintNodes do
			(
				lb.links.pointConstraint.addTarget o undefined frameNo:(_firstFrame - previousFrames)
			)--for
			------------------------------------------------

			------------------------------------------------
			with animate on
			(
				--Primero nos vamos a la mitad del rango de preparar animación
				at time (_firstFrame - (previousFrames / 2))
				(
					--Transform to zero a todo y luego movemos la base
					for _animNode in _animNodes do
					(
						lb.animInfo.createAnimTracksKey _animNode time:(_firstFrame - (previousFrames/2))
						lb.animInfo.setAnimTracksValue _animNode #default
					)					
				)

				at time (_firstFrame - previousFrames)
				(
					--Transform to zero a todo
					for _animNode in _animNodes do
					(
						lb.animInfo.createAnimTracksKey _animNode time:(_firstFrame - previousFrames)
						lb.animInfo.setAnimTracksValue _animNode #default
					)
				)

				at time (_firstFrame - (previousFrames/2))
				(
					_baseNode.transform = _baseNodeOriginalTransform
					_baseNode.pos += _posOffset
				)
			)
			------------------------------------------------

			------------------------------------------------
			--Si estaba conectado lo dejamos asi
			if _skinConnected == true then this.setSkinConnection assetToUse true
			------------------------------------------------
		),
		
		------------------------------------------------
		--devuevle TRUE si el asset ya tiene el pelo cargado
		------------------------------------------------
		fn hasHairAsset assetToUse =
		(
			_hasHair = false

			for o in assetToUse.nodes where not _hasHair do
			(
				_part5 = lb.nc.getNamePart o.name 5

				if (MatchPattern _part5 pattern:lb.nc.NC_HAIR_drvPattern) or (MatchPattern _part5 pattern:lb.nc.NC_HAIR_scalpPattern) or (MatchPattern _part5 pattern:lb.nc.NC_HAIR_shadowPattern) or (MatchPattern _part5 pattern:lb.nc.NC_HAIR_wrapPattern) then _hasHair = true
			)--for

			_hasHair
		),

		------------------------------------------------
		--devuevle TRUE si el asset ya tiene el draft cargado
		------------------------------------------------
		fn hasDraftAsset assetToUse =
		(
			_hasDraft = false

			for o in assetToUse.nodes where not _hasDraft do
			(
				_part5 = lb.nc.getNamePart o.name 5

				if (MatchPattern _part5 pattern:lb.nc.NC_HAIR_draftPattern)  then _hasDraft = true
			)--for

			_hasDraft
		),

		------------------------------------------------
		--elimina la parte de hair de un asset
		------------------------------------------------
		fn removeHairAsset assetToUse =
		(
			--print "----------------------------------"

			for i=assetToUse.nodes.count to 1 by -1 do
			(
				_part5 = lb.nc.getNamePart assetToUse.nodes[i].name 5
				if (MatchPattern _part5 pattern:lb.nc.NC_HAIR_drvPattern) or (MatchPattern _part5 pattern:lb.nc.NC_HAIR_scalpPattern) or (MatchPattern _part5 pattern:lb.nc.NC_HAIR_shadowPattern) or (MatchPattern _part5 pattern:lb.nc.NC_HAIR_wrapPattern) then
				(
					--print assetToUse.nodes[i]

					_index = findItem assetToUse.meshNodesAll assetToUse.nodes[i]
					if _index != 0 then deleteItem assetToUse.meshNodesAll _index

					_index = findItem assetToUse.hairNodesAll assetToUse.nodes[i]
					if _index != 0 then deleteItem assetToUse.hairNodesAll _index

					delete assetToUse.nodes[i]
					deleteItem assetToUse.nodes i
				)--if
			)--for

			--print "----------------------------------"
		),

		------------------------------------------------
		--elimina la parte de draft de un asset
		------------------------------------------------
		fn removeDraftAsset assetToUse =
		(
			--print "----------------------------------"
			_fileHistoryFile = undefined
			for i=assetToUse.nodes.count to 1 by -1 do
			(
				_part5 = lb.nc.getNamePart assetToUse.nodes[i].name 5
				if (MatchPattern _part5 pattern:lb.nc.NC_HAIR_draftPattern) or (MatchPattern _part5 pattern:lb.nc.NC_HAIR_refPattern)  then
				(
					if lb.nodeInfo.hasNodeInfo assetToUse.nodes[i] do 
					(
						for _fileHistory in assetToUse.nodes[i].nodeInfo.fileHistory do
						(
							if (MatchPattern _fileHistory pattern:("*" + lb.nc.NC_HAIR_draft + "*")) do  _fileHistoryFile = _fileHistory
						)
					)

					_index = findItem assetToUse.meshNodesAll assetToUse.nodes[i]
					if _index != 0 then deleteItem assetToUse.meshNodesAll _index

					delete assetToUse.nodes[i]
					deleteItem assetToUse.nodes i
				)--if
			)--for
			return _fileHistoryFile
			--print "----------------------------------"
		),

		------------------------------------------------
		--Obtiene la ruta de la carpeta part asset al que pertenece el objeto a traves de la base.
		------------------------------------------------
		fn getPartAssetFolder assetToUse =
		(
			--print "----------------------------------"
			_fileHistoryFile = undefined

			for _node in assetToUse.nodes do
			(
				if (MatchPattern _node.name pattern:("*"+(lb.nc.NC_ANIM_base)+"*")) then
				(
					if lb.nodeInfo.hasNodeInfo _node do 
					(
						for _fileHistory in _node.nodeInfo.fileHistory do
						(
							_stripPath = (FilterString _fileHistory "\\")
							if _stripPath[7] == lb.nc.NC_presetFolderName do
							(
								_fileHistoryFile = _stripPath[1] + "\\" + _stripPath[2] + "\\" + _stripPath[3] + "\\" + _stripPath[4] + "\\" + _stripPath[5] + "\\" + _stripPath[6] + "\\" + _stripPath[7] + "\\" 
								_fileHistoryFile = substituteString _fileHistoryFile (lb.nc.NC_presetFolderName) (lb.nc.NC_partFolderName)
							)
						)
					)
				)--if
			)
			return _fileHistoryFile
			--print "----------------------------------"
		),

		------------------------------------------------
		--carga el asset de hair del asset indicado si existe
		------------------------------------------------
		fn importDraftAsset assetToUse ref _specifyRoute:false=
		(	
			disableSceneRedraw()
			local _success = true
			-------------------------
			--Si el asset tiene variaciones de Morph cargadas las resetearemos y guardaremos sus valores para volverlas a configurar una vez cargado el pelo
			_morphVariations = #()

			for _node in assetToUse.nodes do
			(
				for m in _node.modifiers where ((classof m) == Morpher) do
				(
					for n=1 to 100 do
					(
						if (WM3_MC_HasData m n) do
						(
							_name = WM3_MC_GetName m n
							
							if matchpattern _name pattern: lb.nc.NC_morphVariationPattern then 
							(
								_morphvariation = #()
								_name = WM3_MC_GetName m n
								append _morphvariation _node
								append _morphvariation _name
								append _morphvariation (m[n].value)
								append _morphVariations _morphvariation
								m[n].value = 0
							)
						)
					)
				)
			)
			------------------------
			
			--Cargaremos el archivo de pelo de draft
			if not _specifyRoute then 
			(
				--Si habia el archivo en escena, y este existe en la ruta correcta se abrirá directamente, sino se podra especificar un archivo
				if (FilterString ref "\\").count > 7 then
				(
					if doesFileExist ref then _assetPath = ref
					else _assetPath = getOpenFileName filename:ref 
				)
				else 
				(
					_assetPath = getOpenFileName filename:ref 
				)
			)
			else 
			(
				--En el caso que queramos cargar un archivo distinto especificaremos la ruta.
				_assetPath = getOpenFileName filename:ref 
			)
			if _assetPath != undefined then 
			(
				------------------------------------------------
				--clave al asset en el fotograma de inicio de camara
				------------------------------------------------
				_camera = undefined
				for _cam in cameras where superclassof _cam == camera and _cam.custAttributes[#camInfo] != undefined do _camera = _cam
				
				_firstFrame = animationRange.start
				_lastFrame = animationRange.end
				if _camera != undefined then
				(
					_firstFrame = _camera.custAttributes[#camInfo].recStart As Time
					_lastFrame = _camera.custAttributes[#camInfo].recEnd As Time
				)

				sliderTime = _firstFrame
				_animNodes = getAssetAnimNodes assetToUse #all

				lb.animInfo.createAnimTracksKey _animNodes time:_firstFrame
				
				animationRange = (interval _firstFrame _lastFrame)

				------------------------------------------------
				--hace el prepare animation del asset
				
				lb.asset.prepareAnimation assetToUse 20
				
				--colocarse en el inicio del prepare animation
				animationRange = interval (_firstFrame-20) animationRange.end
				sliderTime = animationRange.start

				--Cargamos el archivo de pelo.
				_mergedElements = lb.asset.loadAsset _assetPath #xrefObjects

				_assetLayer = layerManager.getLayerFromName assetToUse.fullName
				_hairLayer = layerManager.getLayerFromName ((filterString (getFilenameFile _assetPath) "_")[1] + "_" + (filterString (getFilenameFile _assetPath) "_")[2]) 
				_hairNodes = #()

				_hairLayer.nodes &_hairNodes
				_oldNodesNames = #()
				--Renombramos los nodos y los movemos a la capa del asset
				for _node in _hairNodes do
				(
					append _oldNodesNames _node.name
					_node.name = substituteString _node.name _hairLayer.name _assetLayer.name
					if _node.material != undefined then
					(
						_node.material.name = substituteString _node.material.name _hairLayer.name _assetLayer.name
					)
					_assetLayer.addNode _node
				)
				--Borramos la capa del pelo
				LayerManager.deleteLayerByName _hairLayer.name

				_skinVersionNumber = substring (filterString (getFilenameFile _assetPath) "_")[4] 2 2
				_skinPath = ""
				_skinVersions = getDirectories (substituteString (getFilenamePath _assetPath) "version\\part\\" ("rig\\skin\\v" + _skinVersionNumber))
				_dyncVersions = getDirectories (substituteString (getFilenamePath _assetPath) "version\\part\\" ("rig\\dynConnect\\v" + _skinVersionNumber))

				--Cargamos el skin de los objetos que tengan un archivo skin con su nombre.
				for i = 1 to _hairNodes.count do 
				(
					if doesfileExist ( _skinVersions[1]+(_oldNodesNames[i])+".skn") then 
					(
						_skinMod = lb.skin.addSkinModifier _hairNodes[i]
						lb.skin.loadSkin ( _skinVersions[1]+(_oldNodesNames[i])+".skn") _skinMod alwaysDeformRefFrame:(_firstFrame - 20)
					)
					
					if doesfileExist ( _dyncVersions[1]+(_oldNodesNames[i])+".dyc") then 
					(
						_selObj = _hairNodes[i]
						_file = ( _dyncVersions[1]+(_oldNodesNames[i])+".dyc")

						if not (lb.dynConnect.hasDynConnectInfo _selObj) then
						(
							lb.dynConnect.addAttribute _selObj	
						)
				
						lb.dynConnect.load _selObj _file
						lb.dynConnect.connect _selObj
					)
				)
				--Restauramos el rango de animacion
				animationRange = (interval _firstFrame _lastFrame)
			)
			else _success = false
			
			-----------------------------
			--volvemos a dejar las variaciones como estaban antes de importar el pelo
			for _mv in _morphvariations do
			(
				for _node in assetToUse.nodes do
				(
					if _mv[1] == _node then
					(
						for m in _node.modifiers where ((classof m) == Morpher) do
						(
							for n=1 to 100 do
							(
								if (WM3_MC_HasData m n) do
								(
									_name = WM3_MC_GetName m n
									if _mv[2] == _name then
									(
										m[n].value = _mv[3]
									)
								)
							)	
						)	
					)
				)
			)
			-----------------------------
			enableSceneRedraw()
			return _success
		),

		------------------------------------------------
		--carga el asset de hair del asset indicado si existe
		------------------------------------------------
		fn importHairAsset assetToUse _specifyRoute:false=
		(	
			disableSceneRedraw()		
			_success = true

			--carga el preset del asset de hair correspondiente si existe
			--La información de lo que hemos de cargar está en la pieza llamada draft-head-hair-* en su quinta parte
			--si por un casual no estuviese, entonces lo haríamos con la pieza de ref ref-head-hair-*
			_sourceNode = lb.misc.getNodesByPattern (assetToUse.fullname + "_mesh_?_" + lb.nc.NC_HAIR_draft + "-head-hair-*_*_*")
			
			if _sourceNode.count == 0 then
				_sourceNode = lb.misc.getNodesByPattern (assetToUse.fullname + "_mesh_?_" + lb.nc.NC_HAIR_ref + "-head-*-*_*_*")
			
			--print _sourceNode.name

			if _sourceNode.count > 0 then
			(
				-------------------------
				--Si el asset tiene variaciones de Morph cargadas las resetearemos y guardaremos sus valores para volverlas a configurar una vez cargado el pelo
				_morphVariations = #()

				for _node in assetToUse.nodes do
				(
					for m in _node.modifiers where ((classof m) == Morpher) do
					(
						for n=1 to 100 do
						(
							if (WM3_MC_HasData m n) do
							(
								_name = WM3_MC_GetName m n
								
								if matchpattern _name pattern: lb.nc.NC_morphVariationPattern then 
								(
									_morphvariation = #()
									_name = WM3_MC_GetName m n
									append _morphvariation _node
									append _morphvariation _name
									append _morphvariation (m[n].value)
									append _morphVariations _morphvariation
									m[n].value = 0
								)
							)
						)
					)
				)
				
				--------------------------	
				
				--Asset en modo skin + box
				lb.asset.setAssetSkinBoxMode assetToUse

				------------------------------------------------
				--clave al asset en el fotograma de inicio de camara
				------------------------------------------------
				_camera = undefined
				for _cam in cameras where superclassof _cam == camera and _cam.custAttributes[#camInfo] != undefined do _camera = _cam
				
				_firstFrame = animationRange.start
				_lastFrame = animationRange.end
				if _camera != undefined then
				(
					_firstFrame = _camera.custAttributes[#camInfo].recStart As Time
					_lastFrame = _camera.custAttributes[#camInfo].recEnd As Time
				)

				sliderTime = _firstFrame
				_animNodes = getAssetAnimNodes assetToUse #all

				lb.animInfo.createAnimTracksKey _animNodes time:_firstFrame
				
				animationRange = (interval _firstFrame _lastFrame)

				------------------------------------------------
				--hace el prepare animation del asset
				
				--lb.message.show "Prepare animation" type:#message modal:true
				
				lb.asset.prepareAnimation assetToUse 20
				
				--colocarse en el inicio del prepare animation
				animationRange = interval (_firstFrame-20) animationRange.end
				sliderTime = animationRange.start
				_loadedAssetPaths = #()
				
				for o in _sourceNode where lb.nodeInfo.hasNodeInfo o do
				(
					--Sacamos el path del histórico del asset: la primera ruta cuyo archivo sea chr_personaje(headHair-std)_
					_assetPath = ""
					_exit = false
					_chrName = undefined

					for i=1 to o.nodeInfo.fileHistory.count where not _exit do
					(
						if matchPattern (getFilenameFile o.nodeInfo.fileHistory[i]) pattern: ("*_*(headHair-*)_" + lb.nc.NC_draftFileName + "_v??") then
						(
							_assetPath = substituteString o.nodeInfo.fileHistory[i] ("_" + lb.nc.NC_draftFilename + "_") ("_" + lb.nc.NC_hairFilename + "_")
							_chrName = (filterString o.nodeInfo.fileHistory[i] "\\")[5]
							_exit = true
						)
					)
					if appendIfUnique _loadedAssetPaths _assetPath do 
					(
						if (_specifyRoute) then
						(
							_assetPath = getOpenFileName filename:(_assetPath) caption: ("Hair file for "+ (_chrName ))
						)
						else 
						(
							--En el caso de la carga por defecto, sin el load from file, consultaremos que estemos cargando la ultima de las versiones de pelo; si no, preguntaremos si se quiere cargar la ultima en su lugar.
							_hairFileParts = filterString _assetPath "_"
							--Guardamos en currversion la versión que se deberia cargar por defecto.
							_currVersion = (FilterString _hairFileParts[_hairFileParts.count] ".")[1]
							_currVersion = substituteString _currVersion "v" ""
							--Obtenemos un patron de ficheros de pelo para el archivo en cuestión
							_hairFileParts[_hairFileParts.count] = "v??.max"
							_hairFilePattern = lb.str.join _hairFileParts "_"
							_hairFiles = getFiles _hairFilePattern
							_highestHairVersion = "00"
							--Guardamos la versión de pelo mas grande de entre los capturados.
							for _hairFile in _hairFiles do
							(
								_hairFileParts = FilterString _hairFile "_"
								_hairFileVersion = (FilterString _hairFileParts[_hairFileParts.count] ".")[1]
								_hairFileVersion = substituteString _hairFileVersion "v" ""
								if (_hairFileVersion as integer) > (_highestHairVersion as integer) do 
								(
									_highestHairVersion = _hairFileVersion
								)
							)
							--Si la versión mas alta de las capturadas es superior a currversion (la que deberia cargarse por defecto) se pregunta si se debe actualizar.
							if (_highestHairVersion as integer) > ( _currVersion as integer) do 
							(
								--En caso de pedir la actualización, se sobreescribe el path del asset a mergear.
								_switchVersion = lb.message.show ("There is a newer version of the hair file:\nLoad v"+ _highestHairVersion + "\ninstead of v"+_currVersion) type:#query
								if _switchVersion do 
								(
									_hairFileParts[_hairFileParts.count] = "v" + _highestHairVersion +".max"
									_assetPath  = lb.str.join _hairFileParts "_"
								)
							)

						)

						--lb.message.show "Antes de cargar" type:#message modal:true
						if _assetPath != undefined then 
						(
							_hairFileNC = (filterstring _assetPath "\\")[8]
							_hairFileNC = (filterstring _hairFileNC "_")[3]
						)
						else _success = false
						--Si no hay archivo de asset equivalente no seguiremos con el proceso
						if _assetPath != undefined and _hairFileNC == lb.nc.NC_classHair then
						(
							if _assetPath != "" and doesFileExist _assetPath then
							(
								--Antes de hacer las operaciones deshabilitaremos los turbosmooth del asset.
								for _node in assetToUse.nodes do 
								(
									for _mod in _node do 
									(
										if (classOF _mod == TurboSmooth) do _mod.enabled = false
									)
								)

								--mete el asset de pelo cargado en la misma capa del asset y renombra los objetos como deben
								lb.asset.loadAsset _assetPath #merge
								
								_assetLayer = layerManager.getLayerFromName assetToUse.fullName
								_hairLayer = layerManager.getLayerFromName ((filterString (getFilenameFile _assetPath) "_")[1] + "_" + (filterString (getFilenameFile _assetPath) "_")[2]) 
								_hairNodes = #()

								_hairLayer.nodes &_hairNodes

								--Renombramos los nodos y los movemos a la capa del asset
								for _node in _hairNodes do
								(
									_node.name = substituteString _node.name _hairLayer.name _assetLayer.name
									if _node.material != undefined then
									(
										_node.material.name = substituteString _node.material.name _hairLayer.name _assetLayer.name
									)
									_assetLayer.addNode _node
								)

								--Borramos la capa del pelo
								LayerManager.deleteLayerByName _hairLayer.name
								
								--lb.message.show "Preparar scalp, drv y shadow" type:#message modal:true

								--Dividimos las piezas del pelo en sus tres tipos (drv,scalp y shadow) antes de conectarlas.
								_scalpNodes = #()
								_driverNodes = #()
								_shadowNodes = #()
								
								for _node in _hairNodes do
								(
									if (filterString (filterString _node.name "_")[5] "-")[1] == lb.nc.NC_HAIR_scalp then
									(
										append _scalpNodes _node
									)
									else if (filterString (filterString _node.name "_")[5] "-")[1] == lb.nc.NC_HAIR_drv then
									(
										append _driverNodes _node
									)
									else if (filterString (filterString _node.name "_")[5] "-")[1] == lb.nc.NC_HAIR_shadow then
									(
										append _shadowNodes _node
									)
								)

								--print _scalpNodes
								--print _driverNodes
								--print _shadowNodes

								--lb.message.show "Scalp" type:#message modal:true
								--CONEXIÓN DE PIEZAS DE SCALP
								--buscar las piezas scalp por NC
								--añadir un skinwrap a cada scalp con weight all points activado sobre el base object (quitar los WSM antes porque si no el before del addmodifier no va)
								--buscar el target correspodiente y añadirlo al skinwrap
								for _scalp in _scalpNodes do
								(
									_target = undefined
									_target = lb.misc.getNodeByPattern (assetToUse.fullname + "_" + lb.nc.NC_meshFileName + "_?_" + (filterString (filterString _scalp.name "_")[5] "-")[2] + "_*_*")
									
									--print ("Scalp: " + _scalp.name)

									if _target != undefined then
									(
										----------------------------------------------------------
										--En caso de que sea el pelo general o el flequillo, en lugar de hacer skinwrap del scalp a la cabeza, hay que duplicar el
										--la cabeza y dejar solo el skin y un FFD. Despues dejamos solo los huesos que no sean de facial en el skin y usamos esto de target

										_scalpParts = lb.nc.getNamePart _scalp.name 5
										_scalpPart2 = (filterstring _scalpParts "-")[2]
										_scalpPart3 = (filterstring _scalpParts "-")[3]

										if _scalpPart2 == lb.nc.NC_ANIM_head and (_scalpPart3 == lb.nc.NC_HAIR_hair or _scalpPart3 == lb.nc.NC_HAIR_fringe) then
										(
											--------------------------------------
											--OTRA FORMA CON LA CABEZA ENTERA

											_targetNameParts = FilterString _target.name "_"
											_auxTargetName = substituteString _target.name lb.nc.NC_classMesh lb.nc.NC_classHair
											_auxTargetName = substituteString _auxTargetName _targetNameParts[5] ("wrap-" + _targetNameParts[5] + "-hair-all")

											_targetCopy = getNodeByName _auxTargetName

											if _targetCopy == undefined then
											(
												_targetCopy = copy _target
												
												
												for i = _targetCopy.modifiers.count to 1 by -1 where classof _targetCopy.modifiers[i] != Skin do deleteModifier _targetCopy _targetCopy.modifiers[i]
													
												_scalp.layer.addNode _targetCopy
												_targetCopy.name = _auxTargetName
												_targetCopy.material = undefined
												_targetCopy.wireColor = color 255 127 127

												_skinMod = undefined
												for m in _targetCopy.modifiers where classof m == Skin do _skinMod = m

												--addModifier _targetCopy _skinMod
												lb.skin.selectSkinModifier _skinMod subobject:false 
												_numBones = (_skinMod.numSubs/6)
												
												
												for i = _numBones to 1 by -1 do
												(
													-- Obtenemos el nombre del hueso pasando un indice y nos quedamos la parte 3 del nombre.
													_boneName = skinOps.GetBoneName _skinMod i 0
													_boneNamePart = lb.nc.getNamePart _boneName 3
													_boneNamePartFive = lb.nc.getNamePart _boneName 5
													
													-- Filtramos para borrar solo los de tipo facial
													if _boneNamePart == lb.nc.NC_classFacial then
													(
														skinOps.SelectBone _skinMod i
														skinOps.RemoveBone _skinMod
													)
												)

												-- Se captura el numero de huesos de nuevo.
												_numBones = (_skinMod.numSubs/6)
												_boneIndexHead = undefined
												
												-- Filtramos para obtener el hueso de cabeza
												for i = _numBones to 1 by -1 do
												(
													-- Obtenemos el nombre del hueso pasando un indice y nos quedamos la parte 3 del nombre.
													_boneName = skinOps.GetBoneName _skinMod i 0
													_boneNamePart = lb.nc.getNamePart _boneName 3
													_boneNamePartFive = lb.nc.getNamePart _boneName 5
													
													-- Filtramos  el hueso de head.
													if _boneNamePartFive == lb.nc.NC_ANIM_Head then
														_boneIndexHead = i
												)
												
												-- Obtenemos el num de vértices para revisar cuales tienen peso nulo y cuales a cero (porque es distinto)
												_numVertex = if (classOf _targetCopy == XRefObject) then (_targetCopy.GetSourceObject true).GetNumVertices() else _targetCopy.GetNumVertices()
												
												-- Recorremos los vertex y ponemos el peso a 1 con el hueso de la cabeza.
												for i = 1 to _numVertex do
												(
													if (skinOps.GetVertexWeightCount _skinMod i) == 0 then
														skinOps.ReplaceVertexWeights _skinMod i _boneIndexHead 1.0
													
													if (skinOps.GetVertexWeight _skinMod i 1) == 0 then
														skinOps.ReplaceVertexWeights _skinMod i _boneIndexHead 1.0
												)

												for _m in _target.modifiers do
													if classof _m == FFD_Binding then lb.modifiers.insertModifier _targetCopy (copy _m)
											)
											
											_target = _targetCopy

											--------------------------------------				
										)--if
										----------------------------------------------------------

										--print ("Scalp: " + _scalp.name)
										--print ("Target de skinWrap: " + _target.name)
										_newMod = Skin_Wrap()
										lb.modifiers.insertModifier _scalp _newMod before:_scalp.modifiers.count
										_newMod.meshList = #(_target)
										_newMod.engine = 0
										_newMod.weightAllVerts = true
									)
									else --No hay nodo al que anclar el scalp
									(
										--print "----------------------------------"
										--print "no hay nodo al que anclar el scalp"
										--print (assetToUse.fullname + "_" + lb.nc.NC_meshFileName + "_?_" + (filterString (filterString _scalp.name "_")[5] "-")[2] + "_*_*")
										_success = false
									)
								)

								--Buscamos la carpeta skin de la versión que toca
								--Sacar versión de skin
								_skinVersionNumber = substring (filterString (getFilenameFile _assetPath) "_")[4] 2 2
								_skinPath = ""
								--print (substituteString (getFilenamePath _assetPath) "version\\part\\" ("rig\\skin\\v" + _skinVersionNumber))
								_skinVersions = getDirectories (substituteString (getFilenamePath _assetPath) "version\\part\\" ("rig\\skin\\v" + _skinVersionNumber))

								if _skinVersions.count > 0 then
								(
									_skinPath = _skinVersions[1]
									--print _skinPath
								)

								--print ("SkinPath: " + _skinPath)

								--lb.message.show "Drivers" type:#message modal:true
								--Cargamos skin en los nodos de drv, si no hay skin, hacemos skinwrap
								for _drv in _driverNodes do
								(
									----------------------
									--Skin
									_skinFileName = lb.nc.getSimpleObjectName _drv.nodeInfo.nameHistory[_drv.nodeInfo.nameHistory.count] + "_*_*.skn"
									_skinFileNameParts = filterstring _skinFileName "()"
									_skinFileNamePart2Parts = filterstring _skinFileNameParts[2] "-"
									_skinFiles = getFiles (_skinPath + _skinFileName)
									----------------------
									
									----------------------
									--si no ha encontrado skin para este driver, lo busca para el std y si no para el std-std
									if _skinFiles.count == 0 then
									(
										_skinFileName = substituteString _skinFileName _skinFileNamePart2Parts[2] "std"
										_skinFiles = getFiles (_skinPath + _skinFileName)
									)--if

									if _skinFiles.count == 0 then
									(
										_skinFileName = substituteString _skinFileName _skinFileNamePart2Parts[1] "headHair"
										_skinFiles = getFiles (_skinPath + _skinFileName)
									)--if
									----------------------

									-----------------------------------------------------
									if _skinFiles.count > 0 then --Skin
									(
										_skinMod = lb.skin.addSkinModifier _drv
										lb.skin.loadSkin _skinFiles[1] _skinMod alwaysDeformRefFrame:(_firstFrame - 20)

										--print ("Archivo de Skin: " + _skinFiles[1])

										--Agregamos los FFDs
										_target = lb.misc.getNodeByPattern (assetToUse.fullname + "_" + lb.nc.NC_meshFileName + "_?_" + (filterString (filterString _drv.name "_")[5] "-")[2] + "_*_*")
										if _target != undefined then
										(
											for _m in _target.modifiers do
											(
												if classof _m == FFD_Binding then
												(
													lb.modifiers.insertModifier _drv _m
												)
											)
										)
										else
										(
											_success = false
										)
									)
									-----------------------------------------------------
									else --skinWrap
									(
										_target = lb.misc.getNodeByPattern (assetToUse.fullname + "_" + lb.nc.NC_meshFileName + "_?_" + (filterString (filterString _drv.name "_")[5] "-")[2] + "_*_*")
										if _target != "" then
										(
											----------------------------------------------------------
											--En caso de que sea el pelo general o el flequillo, en lugar de hacer skinwrap del scalp a la cabeza, hay que duplicar el
											--la cabeza y dejar solo el skin y un FFD. Despues dejamos solo los huesos que no sean de facial en el skin y usamos esto de target

											_drvParts = lb.nc.getNamePart _drv.name 5
											_drvPart2 = (filterstring _drvParts "-")[2]
											_drvPart3 = (filterstring _drvParts "-")[3]
											
											if _drvPart2 == lb.nc.NC_ANIM_head and (_drvPart3 == lb.nc.NC_HAIR_hair or _drvPart3 == lb.nc.NC_HAIR_fringe) then
											(
												--------------------------------------
												--OTRA FORMA CON LA CABEZA ENTERA

												_targetNameParts = FilterString _target.name "_"
												_auxTargetName = substituteString _target.name lb.nc.NC_classMesh lb.nc.NC_classHair
												_auxTargetName = substituteString _auxTargetName _targetNameParts[5] ("wrap-" + _targetNameParts[5] + "-hair-all")

												_targetCopy = getNodeByName _auxTargetName
												if _targetCopy != undefined then _target = _targetCopy

												--------------------------------------				
											)--if
											----------------------------------------------------------

											--print ("Driver: " + _drv.name)
											--print ("Target de skinWrap: " + _target.name)
											_newMod = Skin_Wrap()
											lb.modifiers.insertModifier _drv _newMod before:_drv.modifiers.count
											_newMod.meshList = #(_target)
											_newMod.engine = 0
											_newMod.weightAllVerts = true
										)
										else
										(
											_success = false
										)
									)
									-----------------------------------------------------
								)
								
								--lb.message.show "Shadow" type:#message modal:true
								--Cargamos skin en los nodos de drv, si no hay skin, hacemos skinwrap
								for _shadow in _shadowNodes do
								(
									----------------------
									--Skin
									_skinFileName = lb.nc.getSimpleObjectName _shadow.nodeInfo.nameHistory[_shadow.nodeInfo.nameHistory.count] + "_*_*.skn"
									_skinFileNameParts = filterstring _skinFileName "()"
									_skinFileNamePart2Parts = filterstring _skinFileNameParts[2] "-"
									_skinFiles = getFiles (_skinPath + _skinFileName)
									----------------------
									
									----------------------
									--si no ha encontrado skin para este driver, lo busca para el std y si no para el std-std
									if _skinFiles.count == 0 then
									(
										_skinFileName = substituteString _skinFileName _skinFileNamePart2Parts[2] "std"
										_skinFiles = getFiles (_skinPath + _skinFileName)
									)--if

									if _skinFiles.count == 0 then
									(
										_skinFileName = substituteString _skinFileName _skinFileNamePart2Parts[1] "headHair"
										_skinFiles = getFiles (_skinPath + _skinFileName)
									)--if
									----------------------

									if _skinFiles.count > 0 then
									(
										_skinMod = lb.skin.addSkinModifier _shadow
										lb.skin.loadSkin _skinFiles[1] _skinMod alwaysDeformRefFrame:(_firstFrame - 20)

										--print ("Archivo de Skin de shadow: " + _skinFiles[1])
										_target = lb.misc.getNodeByPattern (assetToUse.fullname + "_" + lb.nc.NC_meshFileName + "_?_" + (filterString (filterString _shadow.name "_")[5] "-")[2] + "_*_*")
										if _target != undefined then
										(
											for _m in _target.modifiers do
											(
												if classof _m == FFD_Binding then
												(
													lb.modifiers.insertModifier _shadow _m
												)
											)
										)
										else
										(
											_success = false
										)
									)
									--Skinwrap
									else
									(
										_target = lb.misc.getNodeByPattern (assetToUse.fullname + "_" + lb.nc.NC_meshFileName + "_?_" + (filterString (filterString _shadow.name "_")[5] "-")[2] + "_*_*")
										if _target != "" then
										(
											----------------------------------------------------------
											--En caso de que sea el pelo general o el flequillo, en lugar de hacer skinwrap del scalp a la cabeza, hay que duplicar el
											--la cabeza y dejar solo el skin y un FFD. Despues dejamos solo los huesos que no sean de facial en el skin y usamos esto de target

											_shadowParts = lb.nc.getNamePart _shadow.name 5
											_shadowPart2 = (filterstring _shadowParts "-")[2]
											_shadowPart3 = (filterstring _shadowParts "-")[3]
											
											if _shadowPart2 == lb.nc.NC_ANIM_head and (_shadowPart3 == lb.nc.NC_HAIR_hair or _shadowPart3 == lb.nc.NC_HAIR_fringe) then
											(
												--------------------------------------
												--OTRA FORMA CON LA CABEZA ENTERA

												_targetNameParts = FilterString _target.name "_"
												_auxTargetName = substituteString _target.name lb.nc.NC_classMesh lb.nc.NC_classHair
												_auxTargetName = substituteString _auxTargetName _targetNameParts[5] ("wrap-" + _targetNameParts[5] + "-hair-all")

												_targetCopy = getNodeByName _auxTargetName
												if _targetCopy != undefined then _target = _targetCopy

												--------------------------------------				
											)--if
											----------------------------------------------------------

											--print ("Shadow: " + _shadow.name)
											--print ("Target de skinWrap: " + _target.name)
											_newMod = Skin_Wrap()
											lb.modifiers.insertModifier _shadow _newMod before:_shadow.modifiers.count
											_newMod.meshList = #(_target)
											_newMod.engine = 0
											_newMod.weightAllVerts = true
										)
										else
										(
											_success = false
										)
									)
								)
								
								------------------------------------------------
								--si el pelo de draft tiene variaciones las aplica tb al pelo de alta cargado

								if lb.variations.hasMatVariationInfo o then
								(
									_objsToCopyVariation = _scalpNodes + _shadowNodes

									--copia las variaciones
									for _node in _objsToCopyVariation do
									(
										lb.variations.addMatVariationAttribute _node

										if isProperty o.matVariationInfo #matIndexes then _node.matVariationInfo.matIndexes = o.matVariationInfo.matIndexes
										if isProperty o.matVariationInfo #subMatIndexes then _node.matVariationInfo.subMatIndexes = o.matVariationInfo.subMatIndexes

										if isProperty o.matVariationInfo #matNames then _node.matVariationInfo.matNames = o.matVariationInfo.matNames
										if isProperty o.matVariationInfo #subMatNames then _node.matVariationInfo.subMatNames = o.matVariationInfo.subMatNames

										--ahora fuerza a que se apliquen
										_node.matVariationInfo.setStoredMatVariation()
									)--for
								)
								
							)-- if _assetPath != "" and doesFileExist _assetPath
							else
							(
								_success = false
								print "no hay archivo de path"
							)
						) 
						else
						(
							if _hairFileNC != lb.nc.NC_classHair then lb.message.show "You must select a Hair File"
							_success = false 
						)
					)

				)--if assetToUse.FILES.count > 1

				--Volvemos a restablecer los valores del morhp.
				-----------------------------
				--volvemos a dejar las variaciones como estaban antes de importar el pelo
				for _mv in _morphvariations do
				(
					for _node in assetToUse.nodes do
					(
						if _mv[1] == _node then
						(
							for m in _node.modifiers where ((classof m) == Morpher) do
							(
								for n=1 to 100 do
								(
									if (WM3_MC_HasData m n) do
									(
										_name = WM3_MC_GetName m n
										if _mv[2] == _name then
										(
											m[n].value = _mv[3]
										)
									)
								)	
							)	
						)
					)
				)
				-----------------------------
			)	
			else
			(
				_success = false
				print "No se encuentra ruta para el asset"
			)
			enableSceneRedraw()
			_success
		),

		------------------------------------------------
		--carga el asset de hair del asset indicado si existe
		------------------------------------------------
		fn importCacheHairAsset assetToUse _specifyRoute:false =
		(	
			disableSceneRedraw()		
			_success = true

			--carga el preset del asset de hair correspondiente si existe
			--La información de lo que hemos de cargar está en la pieza llamada draft-head-hair-* en su quinta parte
			--si por un casual no estuviese, entonces lo haríamos con la pieza de ref ref-head-hair-*
			_sourceNode = lb.misc.getNodesByPattern (assetToUse.fullname + "_mesh_?_" + lb.nc.NC_HAIR_draft + "-head-hair-*_*_*")
			
			if _sourceNode.count == 0 then
				_sourceNode = lb.misc.getNodesByPattern (assetToUse.fullname + "_mesh_?_" + lb.nc.NC_HAIR_ref + "-head-*-*_*_*")
			
			--print _sourceNode.name

			if _sourceNode.count > 0 then
			(
				for o in _sourceNode where lb.nodeInfo.hasNodeInfo o do
				(
					--Sacamos el path del histórico del asset: la primera ruta cuyo archivo sea chr_personaje(headHair-std)_
					_assetPath = ""
					_exit = false

					_chrName = undefined
					for i=1 to o.nodeInfo.fileHistory.count where not _exit do
					(
						if matchPattern (getFilenameFile o.nodeInfo.fileHistory[i]) pattern: ("*_*(headHair-*)_" + lb.nc.NC_draftFileName + "_v??") then
						(
							_assetPath = substituteString o.nodeInfo.fileHistory[i] ("_" + lb.nc.NC_draftFilename + "_") ("_" + lb.nc.NC_hairFilename + "_")
							_chrName = (filterString o.nodeInfo.fileHistory[i] "\\")[5]
							_exit = true
						)
					)

					if (_specifyRoute) then
					(
						_assetPath = getOpenFileName filename:(_assetPath) caption: ("Hair file for "+ (_chrName ))
					)
					else 
					(
						--En el caso de la carga por defecto, sin el load from file, consultaremos que estemos cargando la ultima de las versiones de pelo; si no, preguntaremos si se quiere cargar la ultima en su lugar.
						_hairFileParts = filterString _assetPath "_"
						--Guardamos en currversion la versión que se deberia cargar por defecto.
						_currVersion = (FilterString _hairFileParts[_hairFileParts.count] ".")[1]
						_currVersion = substituteString _currVersion "v" ""
						--Obtenemos un patron de ficheros de pelo para el archivo en cuestión
						_hairFileParts[_hairFileParts.count] = "v??.max"
						_hairFilePattern = lb.str.join _hairFileParts "_"
						_hairFiles = getFiles _hairFilePattern
						_highestHairVersion = "00"
						--Guardamos la versión de pelo mas grande de entre los capturados.
						for _hairFile in _hairFiles do
						(
							_hairFileParts = FilterString _hairFile "_"
							_hairFileVersion = (FilterString _hairFileParts[_hairFileParts.count] ".")[1]
							_hairFileVersion = substituteString _hairFileVersion "v" ""
							if (_hairFileVersion as integer) > (_highestHairVersion as integer) do 
							(
								_highestHairVersion = _hairFileVersion
							)
						)
						--Si la versión mas alta de las capturadas es superior a currversion (la que deberia cargarse por defecto) se pregunta si se debe actualizar.
						if (_highestHairVersion as integer) > ( _currVersion as integer) do 
						(
							--En caso de pedir la actualización, se sobreescribe el path del asset a mergear.
							_switchVersion = lb.message.show ("There is a newer version of the hair file \nfor: " + assetToUse.fullname + "\nLoad v"+ _highestHairVersion + "\ninstead of v"+_currVersion) type:#query
							if _switchVersion do 
							(
								_hairFileParts[_hairFileParts.count] = "v" + _highestHairVersion +".max"
								_assetPath  = lb.str.join _hairFileParts "_"
							)
						)

					)
					--lb.message.show "Antes de cargar" type:#message modal:true
					if _assetPath != undefined then 
					(
						_hairFileNC = (filterstring _assetPath "\\")[8]
						_hairFileNC = (filterstring _hairFileNC "_")[3]
					)
					else _success = false
					--Si no hay archivo de asset equivalente no seguiremos con el proceso
					if _assetPath != undefined and _hairFileNC == lb.nc.NC_classHair then
					(
						if _assetPath != "" and doesFileExist _assetPath then
						(
							--Antes de hacer las operaciones deshabilitaremos los turbosmooth del asset.
							for _node in assetToUse.nodes do 
							(
								for _mod in _node do 
								(
									if (classOF _mod == TurboSmooth) do _mod.enabled = false
								)
							)

							--mete el asset de pelo cargado en la misma capa del asset y renombra los objetos como deben
							lb.asset.loadAsset _assetPath #merge

							_assetLayer = layerManager.getLayerFromName assetToUse.fullName
							_hairLayer = layerManager.getLayerFromName ((filterString (getFilenameFile _assetPath) "_")[1] + "_" + (filterString (getFilenameFile _assetPath) "_")[2]) 
							_hairNodes = #()

							_hairLayer.nodes &_hairNodes

							_hairFarmClasses = #(HairStyle_Uncomb, HairTo_SplinesSpacewarpModifier, HairTo_PolySpacewarpModifier, HairTo_InstancesSpacewarpModifier, HairStyle_PushOutSpacewarpModifier, HairStyle_Forces, Hair_Display, HairTo_Splines, HairTo_Poly, HairTo_Instances, HairStyle_Wisps, HairStyle_Spiral, HairStyle_Scale, HairStyle_PushOut, HairStyle_Length, HairStyle_Kink, HairStyle_Gravity, HairStyle_Frizz, HairStyle_Displace, HairStyle_Curves, HairStyle_Cluster, HairMesh_to_Poly, HairMesh_Smooth, HairMesh_Sim, HairMesh_Mirror, HairMesh_Link, HairMesh_Extrude, HairMesh_Edit, HairMesh_Brush, Hair_Generate, Hair_Direction_on_Poly)
			

							--Renombramos los nodos y los movemos a la capa del asset
							for _node in _hairNodes do
							(
								_node.name = substituteString _node.name _hairLayer.name _assetLayer.name
								if _node.material != undefined then
								(
									_node.material.name = substituteString _node.material.name _hairLayer.name _assetLayer.name
								)
								_assetLayer.addNode _node

								--Dejamo los flags de las piezas como pieza de caché (Flag p)
								_nodeNameParts = FilterString _node.name "_" 
								_nodeNameParts[7] = substituteString _nodeNameParts[7] _nodeNameParts[7] lb.nc.NC_cacheFlag
								_node.name = lb.str.join _nodeNameParts "_"
							)

							--Borramos la capa del pelo
							LayerManager.deleteLayerByName _hairLayer.name

							--Cortamos los modificadores de hair farm.
							for _node in _hairNodes do
							(
								for m in _node.modifiers where findItem _hairFarmClasses (classof m) != 0 do
								(
									m.enabled = true
									m.enabledInViews = false
								)
							)

							--Apagaremos el modificador de point cache de la pieza de alta.	
							for _node in _hairNodes do 
							(
								_nodeNameParts = FilterString _node.name "_"
								_bodyPart = (FilterString _nodeNameParts[5] "-")[2]
								for _meshNode in assetToUse.meshNodesAll do 
								(
									_meshNodeNameParts = FilterString _meshNode.name "_"
									if _meshNodeNameParts[5] == _bodyPart do 
									(
										--Una vez tenemos capturada la pieza de alta para cada obj de hair Realizaremos el proceso de imoport.	
										--Piezas de hair _node
										--Piezas de alta (mesh)_meshNode

										--Apagamos el modificador de point Cache de la pieza 
										_pcMod = undefined 
										for _mod in _meshNode.modifiers where classOf _mod == Point_Cache do 
										(
											_pcMod = _mod
											_pcMod.enabled = false
										)
										--Añadimos un modificador Skin Wrap a la pieza de alta.
										_skinWrap = Skin_Wrap()
										addmodifier _node _skinWrap
										_skinWrap.weightAllVerts = true
										append _skinWrap.meshList _meshNode
										--Añadimos un Point Cache (WSM) al pelo
										_pcSWmod = Point_CacheSpacewarpModifier()
										addmodifier _node _pcSWmod


										--Obtendremos los parametros del record de la escena 
										--ontendremos el filename de los parametros del fichero de maxPath + nombre de la pieza+.pc2
										_fileName = MaxfilePath + lb.nc.NC_camCacheSourceFolder + "\\" + (lb.nc.getSimpleObjectName _node.name) 

										if doesFileExist _fileName do deleteFile (_filename+".pc2")

										--StartFrame/Endframe, saldran del recstart/recEnd de la camara (si la hay), sino se sacaran del valor por defecto del modificador. que es el timeline cuando se creo.
										_startFrame = undefined 
										_endFrame = undefined 
										_cams = lb.cameraFunctions.getSceneCameras()
										if _cams.count != 1 then 
										(
											_startFrame = _pcSWmod.recordStart
											_endFrame = _pcSWmod.recordEnd 
										)
										else 
										(
											--Si hay 1 Camara con CamInfo se sacan los valores de grabado de frames de esta, sino se queda los que llevaba el modificador por defecto.
											if lb.cameraFunctions.hasCamInfo _cams[1] then
											(
												_startFrame = _cams[1].recStart
												_endFrame = _cams[1].recEnd
											)
											else 
											(
												_startFrame = _pcSWmod.recordStart
												_endFrame = _pcSWmod.recordEnd 
											)
										)
										_pcSWmod.filename = _fileName + ".pc2"
									

										_pcMod.enabled = true
										--Grabamos los caches de las piezas de hair
										lb.cache.recordCache _node _filename _startFrame _endFrame newCacheFile:true ignoreTransforms:false
										--lb.cache.recordCacheFromObject _node (MaxfilePath + lb.nc.NC_camCacheSourceFolder + "\\") _startFrame _endFrame pcFormat:".pc2" forceTC:false ignoreTransforms:false 
										_cacheFile = _pcSWmod.fileName
										--Borramos el modificador skinWrap
										deletemodifier _node _skinWrap
										deletemodifier _node _pcSWmod
										
										--Añadimos un modificador PointCache a la pieza de hair y le cargamos el fichero de cache generado.
										lb.cache.addCacheModByName _node sceneType:#cache
										for _modifier in _node.modifiers where classof _modifier == Point_Cache do 
										(
											_modifier.fileName = _cacheFile
										)
										assetRootNode = lb.asset.getAssetRootNode assetToUse
										_node.parent = assetRootNode			
									)
								)
							)						

						)-- if _assetPath != "" and doesFileExist _assetPath
						else
						(
							_success = false
							print "no hay archivo de path"
						)
					) 
					else
					(
						if _hairFileNC != lb.nc.NC_classHair then lb.message.show "You must select a Hair File"
						_success = false 
					)
					_success

				)--if assetToUse.FILES.count > 1
				-----------------------------
			)	
			else
			(
				_success = false
				print "No se encuentra ruta para el asset"
			)
			enableSceneRedraw()
			_success
		),

		------------------------------------------------
		--crea en el asset pasado por parámetro los puntos de connect
		--necesita el asset donde crearlo
		------------------------------------------------
		fn createConnectNodesInAsset assetToUse =
		(
			_animNodes = this.getAssetAnimNodes assetToUse (lb.nc.NC_classAnim)
			_nodesToCreateConnect = #()

			for _node in _animNodes do
			(
				_namePart = lb.nc.getNamePart _node.name 5

				case _namePart of
				(
					"head": append _nodesToCreateConnect _node
					"hand": append _nodesToCreateConnect _node
					"root": append _nodesToCreateConnect _node
					"helmet-x-bon-x": append _nodesToCreateConnect _node
				)--case
			)--for

			for _node in _nodesToCreateConnect do lb.rig.createConnectNodeInObject _node
		),

		------------------------------------------------
		--COMMON
		------------------------------------------------
			
		------------------------------------------------
		--@fn: undefined | initSubLibraries | Inicializa todas las sublibrerías en el orden establecido.
		------------------------------------------------
		fn initSubLibraries =
		(
			_subLibraries = #()
			
			for sl in _subLibraries do sl.init()
		),
		
		------------------------------------------------
		--@fn: undefined | init | Inicializa la librería.
		------------------------------------------------
		fn init =
		(
			this.fxParticleFlowClasses = #(Birth,Position_Icon,speed,RenderParticles,DisplayParticles,Event,DeleteParticles,ScaleParticles,PFEngine,Particle_View,ShapeLibrary,Force,ParticleGroup,Material_Static)

			if (maxVersion())[1] > 15000 then
				append this.fxParticleFlowClasses Stop_Gradually

			this.initSubLibraries() --inicialza las librerías hijas
		),		
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--@event: create | Ejecución al crearse la instancia del struct.
		------------------------------------------------
		on create do
		(
			lb.addLibrary this --añade la libreria a la principal
		)		
	)--lib_asset
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--EXECUTION
	------------------------------------------------------------------------------------------------------------------------------------------------	
	lib_asset() --crea la libreria
)