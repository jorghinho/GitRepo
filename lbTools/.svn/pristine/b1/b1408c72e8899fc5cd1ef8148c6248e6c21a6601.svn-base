------------------------------------------------------------------------------------------------------------------------------------------------
--Descripcion: Herramienta Pass Manager.
------------------------------------------------------------------------------------------------------------------------------------------------
(
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollAddOverride | Contiene el listado de overrides permitidos.
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollAddOverrideDef "Allowed Overrides"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual.
			
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		local generalBackColor = (dotNetClass "System.drawing.color").fromArgb 50 50 50 --@var : generalBackColor | Color de fondo general.
		local generalForeColor = (dotNetClass "System.drawing.color").fromArgb 230 230 230 --@var : generalForeColor | Color de letra general.
		local disabledForeColor = (dotNetClass "System.drawing.color").fromArgb 80 80 80 --@var : disabledForeColor | Color de letra cuando esta deshabilitado .
		
		local cellColor1 = (dotNetClass "System.drawing.color").fromArgb 40 40 40 --@var : cellColor1 | Color de celda general.
		local cellColor2 = (dotNetClass "System.drawing.color").fromArgb 45 45 45 --@var : cellColor2 | Color de celda general.
			
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
			
		dotNetControl lvOverridesList "System.Windows.Forms.ListView" pos:[5,5] width:250 height:260 --@control | lvOverridesList | Listado de overrides permitidos.
		button btnOk "OK" pos:[5,275] width:125	--@control | btnOk | Devuelve el override que se ha elegido.
		button btnCancel "Cancel" pos:[130,275] width:125	--@control | btnCancel | Cancela la operacion.
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | Establece los parametros y aspecto inicial del listado
		------------------------------------------------
		fn initListView =
		(
			--configura el aspecto del listado
			lvOverridesList.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 9
			lvOverridesList.view = (dotNetClass "System.Windows.Forms.View").details
			lvOverridesList.headerStyle = (dotnetclass "System.Windows.Forms.ColumnHeaderStyle").none
			lvOverridesList.gridLines = false
			lvOverridesList.MultiSelect = true --false
			lvOverridesList.fullRowSelect = true
			lvOverridesList.backColor = generalBackColor
			lvOverridesList.foreColor = generalForeColor
			lvOverridesList.labelEdit = false
			
			lvOverridesList.columns.add "Overrides" (lvOverridesList.width - 70)
			lvOverridesList.columns.add "Added" 60
		)
		
		------------------------------------------------
		--@fn: undefined | fillOverridesList | Rellena el listado con los overrides permitidos.
		------------------------------------------------
		fn fillOverridesList =
		(
			lvOverridesList.items.clear() --vacia el listado
			
			--si existe un contenedor al que intentar añadir un override
			if parent.containerToAddOverride != undefined then
			(
				--obtiene los nombres de los overrides permitidos para el contenedor elegido
				_allowedOverrideTypes = parent.containerToAddOverride.getAllowedOverrideTypes()
				
				--obtiene los overrides ya añadidos para no permitir añadirlos de nuevo
				_addedOverrides = parent.containerToAddOverride.getOverrides()
				_addedOverridesTypes = for _ov in _addedOverrides collect _ov.getSubType()

				--si hay overrides permitidos los lista
				for i=1 to _allowedOverrideTypes.count do
				(
					--crea la fila del listado
					_row = dotNetObject "System.Windows.Forms.ListViewItem" _allowedOverrideTypes[i]
					_row.UseItemStyleForSubItems = false --hace que el color de cada celda pueda ser diferente
					--lvOverridesList.items.item[i-1].subItems.item[0]
					
					lvOverridesList.items.add _row --añade la fila
					lvOverridesList.items.item[i-1].subItems.add ""

					lvOverridesList.items.item[i-1].subItems.item[0].backColor = if (mod i 2) == 0 then cellColor1 else cellColor2
					lvOverridesList.items.item[i-1].subItems.item[1].backColor = if (mod i 2) == 0 then cellColor1 else cellColor2
					
					if finditem _addedOverridesTypes _allowedOverrideTypes[i] != 0 then
					(
						lvOverridesList.items.item[i-1].subItems.item[0].foreColor = disabledForeColor
						lvOverridesList.items.item[i-1].subItems.item[1].foreColor = disabledForeColor

						lvOverridesList.items.item[i-1].subItems.item[1].text = "In Use"
					)
				)--for
			)--if
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--no guarda settings
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--no carga settings
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--@event | MouseDoubleClick | Evento que se lanza al hacer doble click en un elemento del listado.
		--@control: ListView | lvOverridesList | Listado de tipos de overrides.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		on lvOverridesList MouseDoubleClick events do
		(
			_addedCount = 0

			for i=1 to lvOverridesList.items.count where (lvOverridesList.items.item[i-1].selected) and (lvOverridesList.items.item[i-1].subItems.item[1].text != "In Use") do
			(
				parent.containerToAddOverride.addOverride (lvOverridesList.items.item[i-1].text)
				parent.rollMain.updateTrvContainers mode:#update specificContainer:parent.containerToAddOverride
				lvOverridesList.items.item[i-1].selected = false
				_addedCount += 1
			)--for

			if _addedCount != 0 then 
			(
				parent.overrideCandidateTypes = #()
				destroyDialog parent.rollAddOverride
			)--if
		)

		------------------------------------------------
		--@event: pressed | Evento que se lanza al presionar el boton. Devuelve los nodeSets elegidos.
		--@control: button | btnOk | Boton presionado.
		------------------------------------------------
		on btnOk pressed do
		(
			for i=1 to lvOverridesList.items.count where lvOverridesList.items.item[i-1].selected and (lvOverridesList.items.item[i-1].subItems.item[1].text != "In Use") do
				append parent.overrideCandidateTypes (lvOverridesList.items.item[i-1].text)
				--parent.overrideCandidateType = lvOverridesList.items.item[i-1].text
			
			destroyDialog parent.rollAddOverride
		)
		
		------------------------------------------------
		--@event: pressed | Evento que se lanza al presionar el boton. Cancela la operacion.
		--@control: button | btnCancel | Boton presionado.
		------------------------------------------------
		on btnCancel pressed do
		(	
			parent.overrideCandidateTypes = #()
			destroyDialog parent.rollAddOverride
		)

		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollAddOverrideDef | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollAddOverrideDef resized size do
		(
			--no se redimensiona
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollAddOverrideDef | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollAddOverrideDef open do
		(
			loadSettings()
			initListView() --stablece los parametros y aspecto inicial del listado
			fillOverridesList()
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollAddOverrideDef | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollAddOverrideDef close do
		(
			saveSettings()			
		)
	)--rollAddOverrideDef
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollMultiChoice | Contiene un listado con multiseleccion
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollMultiChoiceDef "Multi choice"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual
		local minRollWidth = 200		--@var: minRollWidth | Ancho mínimo de la herramienta.
		local minRollHeight = 300		--@var: minRollHeight | Alto mínimo de la herramienta.	
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		local generalBackColor = (dotNetClass "System.drawing.color").fromArgb 50 50 50 --@var : generalBackColor | Color de fondo general.
		local generalForeColor = (dotNetClass "System.drawing.color").fromArgb 230 230 230 --@var : generalForeColor | Color de letra general.
		
		local cellColor1 = (dotNetClass "System.drawing.color").fromArgb 40 40 40 --@var : cellColor1 | Color de celda general.
		local cellColor2 = (dotNetClass "System.drawing.color").fromArgb 45 45 45 --@var : cellColor2 | Color de celda general.
			
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
			
		dotNetControl lvList "System.Windows.Forms.ListView" pos:[5,5] width:190 height:260 --@control | lvList | Listado de opciones disponibles.
		button btnOk "OK" pos:[5,275] width:190	--@control | btnOk | Devuelve las opciones que se han elegido.
			
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | Establece los parametros y aspecto inicial del listado
		------------------------------------------------
		fn initListView =
		(
			--configura el aspecto del listado
			lvList.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 9
			lvList.view = (dotNetClass "System.Windows.Forms.View").details
			lvList.headerStyle = (dotnetclass "System.Windows.Forms.ColumnHeaderStyle").none
			lvList.gridLines = false
			lvList.fullRowSelect = true
			lvList.backColor = generalBackColor
			lvList.foreColor = generalForeColor
			lvList.labelEdit = false
			
			lvList.columns.add "Options" (lvList.width - 10)			
		)
		
		------------------------------------------------
		--@fn: undefined | fillList | Rellena el listado con las opciones
		------------------------------------------------
		fn fillList =
		(			
			lvList.items.clear()
			
			--añade una fila al listado por cada opcion
			for i=1 to parent.choiceCandidates.count do
			(
				--crea la fila del listado
				_row = dotNetObject "System.Windows.Forms.ListViewItem" (parent.choiceCandidates[i])				
				_row.UseItemStyleForSubItems = false --hace que el color de cada celda pueda ser diferente
				
				lvList.items.add _row --añade la fila
				
				--lvList.items.item[i-1].subItems.item[0].backColor = if (mod i 2) == 0 then cellColor1 else cellColor2
			)--for
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------

		------------------------------------------------
		--@fn: undefined | resize | Redimensiona el UI.
		--@gets: point2 | size | Tamaño nuevo del rollout
		------------------------------------------------
		fn resize size =
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollMultiChoiceDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollMultiChoiceDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(
				lvList.width = 190 + _increment.x
				if lvList.columns.count != 0 then lvList.Columns.Item[0].width = _increment.x + (lvList.width - 10)
				btnOk.pos.x = 5 + (_increment.x/2)
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				lvList.height = 260 + _increment.y
				btnOk.pos.y = 275 + _increment.y
			)--if
			------------------------------------------------------------------------------
		)		

		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--no guarda settings
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--no carga settings
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--@event: pressed | Evento que se lanza al presionar el boton. Devuelve las opciones elegidas
		--@control: button | btnOk | Boton presionado.
		------------------------------------------------
		on btnOk pressed do
		(
			parent.choiceCandidates = (for i=1 to lvList.items.count where lvList.items.item[i-1].selected collect lvList.items.item[i-1].text)			
			destroyDialog parent.rollMultiChoice
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMultiChoice | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollMultiChoiceDef resized size do
		(
			resize size
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMultiChoice | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMultiChoiceDef open do
		(
			loadSettings()
			initListView() --stablece los parametros y aspecto inicial del listado
			fillList()

			if parent.rollMultiChoice != undefined then resize [parent.rollMultiChoice.width, parent.rollMultiChoice.height]
			parent.choiceCandidates = #() --Limpiamos el input/output para que no haya errores al cancelar
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMultiChoice | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMultiChoiceDef close do
		(
			saveSettings()			
		)
	)--rollMultiChoiceDef

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollRenamePassNode | Para renombrar un nodo de pase
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollRenamePassNodeDef "pass node renamer"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual
			
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		local pmPassNodes = #()
		local currNameParts = #()
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
			
		dropdownlist ddlPMpassContents "" width:35 pos:[5,5]
		label lblParentesis "(" pos:[47,8]
		dropdownlist ddlPMpassTypes "" width:45 pos:[60,5]
		label lblDash "-" pos:[112,8]
		dropdownlist ddlPMpassSubtypes "" width:60 pos:[125,5]
		label lblDash2 "-" pos:[192,8]
		edittext edtPMpassFreePart width:125 pos:[200,8]
		label lblParentesis2 ")" pos:[333,8]
		
		label lblDefNamePreview "passNamePreview: " width:400 pos:[5,40]
		
		button btnRenameApply "Apply" pos:[5,65] width:170
		button btnRenameCancel "Cancel" pos:[175,65] width:170
			
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------

		fn currentPassName =
		(
			return ddlPMpassContents.selected + "(" + ddlPMpassTypes.selected + "-" + ddlPMpassSubtypes.selected + "-" + edtPMpassFreePart.text + ")"
		)
		
		--------------------------------------------
		fn fillPassNamePreview =
		(
			lblDefNamePreview.caption = ("passNamePreview: " + currentPassName())
		)
		
		--------------------------------------------
		--rellena el interface con la informacion del nombre actual
		--si el nombre actual no cumple el NC no lo rellena y pode los ddl por defecto
		fn resetUI =
		(
			--primero intenta averiguar cual es el nombre acutal del pase, si cumple el NC y lo pone por defecto
			---------------------------------------------------------------------------------------
			currNameParts = #() --partes del nombre actual
			_caption = pmPassNodes[1].getCaption()
			if matchpattern _caption pattern:(lb.nc.NC_lpmPassPattern + "#???") then
				_caption = (filterString _caption "#")[1]
			if matchpattern _caption pattern:(lb.nc.NC_lpmPassPattern) then
				currNameParts = filterString _caption "(-)"
			if currNameParts.count != lb.nc.NC_lpmPassesNamesLength then currNameParts = #() --si no tiene el numero de partes correcto lo borra
			---------------------------------------------------------------------------------------
			
			--ahora rellena los ddl con los casos de cada tipo y si existe el actual lo deja puesto
			---------------------------------------------------------------------------------------
			ddlPMpassContents.items = lb.nc.NC_PMpassContents
			_index = findItem lb.nc.NC_PMpassContents currNameParts[1]
			if _index != 0 then ddlPMpassContents.selection = _index
			
			ddlPMpassTypes.items = lb.nc.NC_PMpassTypes
			_index = findItem lb.nc.NC_PMpassTypes currNameParts[2]
			if _index != 0 then ddlPMpassTypes.selection = _index
				
			if ddlPMpassTypes.selected == lb.nc.NC_PMpassTypeLIT then ddlPMpassSubtypes.items = lb.nc.NC_PMpassTypeLITsubtypes
			else if ddlPMpassTypes.selected == lb.nc.NC_PMpassTypePASS then ddlPMpassSubtypes.items = lb.nc.NC_PMpassTypePASSsubtypes
			_index = findItem ddlPMpassSubtypes.items currNameParts[3]
			if _index != 0 then ddlPMpassSubtypes.selection = _index
				
			if currNameParts[4] != undefined and currNameParts[4] != "" then edtPMpassFreePart.text = currNameParts[4]
			---------------------------------------------------------------------------------------
			
			fillPassNamePreview()
		)

		fn applyAndClose =
		(
			if edtPMpassFreePart.text != "" then
			(
				for pmPassNode in pmPassNodes do
				(
					_applyName = currentPassName()
					if pmPassNode.getCaption() != _applyName do
						pmPassNode.setCaption _applyName
					parent.rollMain.updateTrvContainers mode:#update specificContainer:pmPassNode
				)
				destroyDialog parent.rollRenamePassNode
			)
			else
			(
				messagebox "La parte libre del nombre no puede estar vacía."
				setFocus edtPMpassFreePart
			)
		)
				
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--no guarda settings
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--no carga settings
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------

		--------------------------------------------
		--renombra la capa al presionar enter
		on edtPMpassFreePart entered txt do applyAndClose()
		
		--------------------------------------------
		--cuando cambia el contenido del pase
		on ddlPMpassContents selected sel do fillPassNamePreview()
		
		--------------------------------------------
		--cuando cambia el tipo de pase
		on ddlPMpassTypes selected sel do
		(
			if ddlPMpassTypes.selected == lb.nc.NC_PMpassTypeLIT then ddlPMpassSubtypes.items = lb.nc.NC_PMpassTypeLITsubtypes
			else if ddlPMpassTypes.selected == lb.nc.NC_PMpassTypePASS then ddlPMpassSubtypes.items = lb.nc.NC_PMpassTypePASSsubtypes
			
			ddlPMpassSubtypes.selection = 1
			
			fillPassNamePreview()
		)
		
		--------------------------------------------
		--cuando cambia el subtipo de pase
		on ddlPMpassSubtypes selected sel do fillPassNamePreview()
		
		--------------------------------------------
		--cuando cambia el contenido de la parte libre del pase
		on edtPMpassFreePart changed text do
		(
			_fail = false
			
			_validChars = #("0","1","2","3","4","5","6","7","8","9",\
								"q","w","e","r","t","y","u","i","o","p","a","s","d","f","g","h","j","k","l","ñ","z","x","c","v","b","n","m",\
								"Q","W","E","R","T","Y","U","I","O","P","A","S","D","F","G","H","J","K","L","Ñ","Z","X","C","V","B","N","M")
				
			for i=1 to text.count where not _fail and findItem _validChars text[i] == 0 do _fail = true	
				
			if _fail then
			(
				_defText = ""
				for i=1 to text.count where findItem _validChars text[i] != 0 do _defText += text[i]
				edtPMpassFreePart.text = _defText
				messagebox "La parte libre del nombre solo puede estar formada por letras y numeros. Si está compuesta de varias palabras, el inicio de cada una deberá ser mayúsculas excepto la primera."
				setFocus edtPMpassFreePart
			)--if _fail
			
			fillPassNamePreview()
		)
		
		------------------------------------------------
		--@event: pressed | Evento que se lanza al presionar el boton.
		--@control: button | btnRenameApply | Boton presionado.
		------------------------------------------------
		on btnRenameApply pressed do applyAndClose()

		------------------------------------------------
		--@event: pressed | Evento que se lanza al presionar el boton.
		--@control: button | btnRenameCancel | Boton presionado.
		------------------------------------------------
		on btnRenameCancel pressed do
		(
			destroyDialog parent.rollRenamePassNode
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMultiChoice | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollRenamePassNodeDef resized size do
		(
			--no se redimensiona
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollRenamePassNode | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollRenamePassNodeDef open do
		(
			loadSettings()

			pmPassNodes = #()
			--obtiene los nodos seleccionados
			_trvSel = parent.rollMain.trvContainers.selection
			
			for i=0 to _trvSel.count-1 do
			(
				------------------------------------------------
				--hay que obtener el contenedor equivalente al nodo seleccionado					
				--recorre la seleccion de arboles de contenedores en el ui y busca el nodo seleccionado para aplicarle el nuevo nombre
				for _contTree in parent.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i] containerTree:_contTree
					if _containers.count != 0 then append pmPassNodes _containers[1]
				)--for
				------------------------------------------------
			)

			resetUI()
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollRenamePassNode | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollRenamePassNodeDef close do
		(
			saveSettings()			
		)
	)--rollRenamePassNode

	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollRenamePassGroupNode | Para renombrar un nodo de pase
	------------------------------------------------------------------------------------------------------------------------------------------------
	rollout rollRenamePassGroupNodeDef "passGroup node renamer"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual
			
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		local pmPassGroupNodes = #()
		local currNameParts = #()
		
		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
			
		label lblStart "--------" pos:[5,8]
		dropdownlist ddlPMpassGroupContents "" width:50 pos:[40,5]
		label lblSlash "-" pos:[93,8]
		edittext edtPMpassGroupFreePart width:125 pos:[100,8]
		label lblEnd "--------" pos:[230,8]
		
		label lblDefNamePreview "passGroupNamePreview: " width:400 pos:[5,40]
		
		button btnRenameApply "Apply" pos:[33,65] width:100
		button btnRenameCancel "Cancel" pos:[138,65] width:100
			
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------

		fn currentPassGroupName =
		(
			_freePart = edtPMpassGroupFreePart.text
			if _freePart != "" do _freePart = "-" + _freePart
			return ddlPMpassGroupContents.selected + _freePart
		)
		
		--------------------------------------------
		fn fillPassGroupNamePreview =
		(
			lblDefNamePreview.caption = ("passGroupNamePreview: ----------" + currentPassGroupName() + "----------")
		)
		
		--------------------------------------------
		--rellena el interface con la informacion del nombre actual
		--si el nombre actual no cumple el NC no lo rellena y pode los ddl por defecto
		fn resetUI =
		(
			--primero intenta averiguar cual es el nombre acutal del pase, si cumple el NC y lo pone por defecto
			---------------------------------------------------------------------------------------
			currNameParts = #() --partes del nombre actual
			if matchpattern (pmPassGroupNodes[1].getCaption()) pattern:(lb.nc.NC_PMpassGroupPattern) then
				currNameParts = filterString (pmPassGroupNodes[1].getCaption()) "(-)"
			---------------------------------------------------------------------------------------
			
			--ahora rellena los ddl con los casos de cada tipo y si existe el actual lo deja puesto
			---------------------------------------------------------------------------------------
			ddlPMpassGroupContents.items = lb.nc.NC_PMpassGroupContents
			_index = findItem lb.nc.NC_PMpassGroupContents currNameParts[1]
			if _index != 0 then ddlPMpassGroupContents.selection = _index
			
			if currNameParts[2] != undefined and currNameParts[2] != "" then edtPMpassGroupFreePart.text = currNameParts[2]
			---------------------------------------------------------------------------------------
			
			fillPassGroupNamePreview()
		)

		fn applyAndClose =
		(
			for pmPassGroupNode in pmPassGroupNodes do
			(
				_applyName = currentPassGroupName()
				if pmPassGroupNode.getCaption() != _applyName do
					pmPassGroupNode.setCaption _applyName
				parent.rollMain.updateTrvContainers mode:#update specificContainer:pmPassGroupNode
			)
			destroyDialog parent.rollRenamePassGroupNode
		)
				
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--no guarda settings
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--no carga settings
		)
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------

		--------------------------------------------
		--renombra la capa al presionar enter
		on edtPMpassGroupFreePart entered txt do applyAndClose()
		
		--------------------------------------------
		--cuando cambia el contenido del pase
		on ddlPMpassGroupContents selected sel do fillPassGroupNamePreview()
		
		--------------------------------------------
		--cuando cambia el contenido de la parte libre del pase
		on edtPMpassGroupFreePart changed text do
		(
			_fail = false
			
			_validChars = #("0","1","2","3","4","5","6","7","8","9",\
								"q","w","e","r","t","y","u","i","o","p","a","s","d","f","g","h","j","k","l","ñ","z","x","c","v","b","n","m",\
								"Q","W","E","R","T","Y","U","I","O","P","A","S","D","F","G","H","J","K","L","Ñ","Z","X","C","V","B","N","M")
				
			for i=1 to text.count where not _fail and findItem _validChars text[i] == 0 do _fail = true	
				
			if _fail then
			(
				_defText = ""
				for i=1 to text.count where findItem _validChars text[i] != 0 do _defText += text[i]
				edtPMpassGroupFreePart.text = _defText
				messagebox "La parte libre del nombre solo puede estar formada por letras y numeros. Si está compuesta de varias palabras, el inicio de cada una deberá ser mayúsculas excepto la primera."
				setFocus edtPMpassGroupFreePart
			)--if _fail
			
			fillPassGroupNamePreview()
		)
		
		------------------------------------------------
		--@event: pressed | Evento que se lanza al presionar el boton.
		--@control: button | btnRenameApply | Boton presionado.
		------------------------------------------------
		on btnRenameApply pressed do applyAndClose()

		------------------------------------------------
		--@event: pressed | Evento que se lanza al presionar el boton.
		--@control: button | btnRenameCancel | Boton presionado.
		------------------------------------------------
		on btnRenameCancel pressed do
		(
			destroyDialog parent.rollRenamePassGroupNode
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollRenamePassGroup | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollRenamePassGroupNodeDef resized size do
		(
			--no se redimensiona
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollRenamePassGroupNode | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollRenamePassGroupNodeDef open do
		(
			loadSettings()

			pmPassGroupNodes = #()
			--obtiene los nodos seleccionados
			_trvSel = parent.rollMain.trvContainers.selection
			
			for i=0 to _trvSel.count-1 do
			(
				------------------------------------------------
				--hay que obtener el contenedor equivalente al nodo seleccionado					
				--recorre la seleccion de arboles de contenedores en el ui y busca el nodo seleccionado para aplicarle el nuevo nombre
				for _contTree in parent.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i] containerTree:_contTree
					if _containers.count != 0 then append pmPassGroupNodes _containers[1]
				)--for
				------------------------------------------------
			)

			resetUI()
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollRenamePAssGroupNode | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollRenamePassGroupNodeDef close do
		(
			saveSettings()			
		)
	)--rollRenamePassGroupNode
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@rollout: rollMain | Contiene la herramienta del gestor de pases de render.
	------------------------------------------------------------------------------------------------------------------------------------------------	
	rollout rollMainDef "Pass Manager"
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		local parent = lb.getTool (lb.getFileToolName (getThisScriptFilename() as string)) --@var : parent | Herramienta o rolllout del que depende y/o contiene el rollout actual
		
		local minRollWidth = 400	--@var: minRollWidth | Ancho mínimo de la herramienta.
		local minRollHeight = 600	--@var: minRollHeight | Alto mínimo de la herramienta.		
			
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		local iconpath = lb.config.getIconsPath() --@var : iconpath | Ruta de iconos de las herramientas de 3dsMax
		
		local containersLevelOrder = #(#passTree, #passGroup, #pass, #settings, #setting, #overrides, #override, #lightSet, #light, #ObjectSet, #nodeSet, #hiddenObjectSet, #object, #lodSet, #flatColorObjectSet) --@var : containersLevelOrder | Orden de profundidad y de aparicion de contenedores, para saber la correspondencia de un contenedor con su icono, color, etc.
		
		--DEPRECATED/OBSOLETO
		--local allowRedrawColors = false --flag para saber si permitir redibujar colores, ya que el evento salta cada vez que se toca el arbol
		
		--------------------------------------
		local lastSelectionLevel = -1 --@var : lastSelectionLevel | Ultimo nivel de nodos seleccionado.
		local lastSelectionType = undefined --@var : lastSelectionType | Ultimo tipo de nodos seleccionados.
		local lastDragOverNode = undefined --@var : lastDragOverNode | Ultimo nodo sobre el que se hizo drag.
		local lastDropAllowed = undefined --@var : lastDragAllowed | Indica si se puede hacer drop.
		--------------------------------------

		--------------------------------------
		--------------------------------------
		--iconos para el interface
		
		--------------------------------------
		--iconos del arbol

		local passTreeIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passTree.png") --@var : passTreeIcon | Icono para arboles de pases.
		local passGroupIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passGroup.png") --@var : passGroupIcon | Icono para grupos de pases.
		local passIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\pass.png") --@var : passIcon | Icono para pases.
		local settingsIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\settings.png") --@var : settingsIcon | Icono para settings generales.
		local settingIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\setting.png") --@var : settingIcon | Icono para setting general.
		local overridesIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\overrides.png") --@var : overridesIcon | Icono para overrides de propiedades.
		local overrideIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\override.png") --@var : overrideIcon | Icono para override de propiedades.
		local lightSetIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lightSet.png") --@var : lightSetIcon | Icono para sets de luces.
		local lightIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\light.png") --@var : light | Icono para luces.
		local objectSetIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\objectSet.png") --@var : objectSetIcon | Icono para sets de objetos.
		local nodeSetIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\nodeSet.png") --@var : nodeSetIcon | Icono para sets de nodos.
		local hiddenObjectSetIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\hiddenObjectSet.png") --@var : hiddenObjectSetIcon | Icono para sets de nodos ocultos.
		local objectIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\object.png") --@var : objectIcon | Icono para objetos.
		local lodSetIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lodSet.png") --@var : lodSetIcon | Icono para sets de nivel de detalle.
		local flatColorObjectSetIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\flatColorObjectSet.png") --@var : lodSetIcon | Icono para sets de nivel de detalle.
		local overridesIcons = #() --@var : overridesIcons | Array para los iconos específicos de cada override.
		
		local treeIcons = #(passTreeIcon, passGroupIcon, passIcon, settingsIcon, settingIcon, overridesIcon, overrideIcon, lightSetIcon, lightIcon, objectSetIcon, nodeSetIcon, hiddenObjectSetIcon, objectIcon, lodSetIcon, flatColorObjectSetIcon) --@var : treeIcons | Agrupacion de todos los iconos en un array para que los reconozca el arbol. 
		--------------------------------------

		--------------------------------------
		--iconos de desactivados

		local passTreeIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passTreeOff.png") --@var : passTreeIconOff | Icono Off para arboles de pases.
		local passGroupIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passGroupOff.png") --@var : passGroupIconOff | Icono Off para grupos de pases.
		local passIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passOff.png") --@var : passIconOff | Icono Off para pases.
		local settingsIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\settingsOff.png") --@var : settingsIconOff | Icono Off para settings generales.
		local settingIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\settingOff.png") --@var : settingIconOff | Icono Off para setting general.
		local overridesIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\overridesOff.png") --@var : overridesIconOff | Icono Off para overrides de propiedades.
		local overrideIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\overrideOff.png") --@var : overrideIconOff | Icono Off para override de propiedades.
		local lightSetIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lightSetOff.png") --@var : lightSetIconOff | Icono Off para sets de luces.
		local lightIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lightOff.png") --@var : lightOff | Icono Off para luces.
		local objectSetIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\objectSetOff.png") --@var : objectSetIconOff | Icono Off para sets de objetos.
		local nodeSetIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\nodeSetOff.png") --@var : nodeSetIconOff | Icono Off para sets de nodos.
		local hiddenObjectSetIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\hiddenObjectSetOff.png") --@var : hiddenObjectSetIcon | Icono Off para sets de nodos ocultos.
		local objectIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\objectOff.png") --@var : objectIconOff | Icono Off para objetos.
		local lodSetIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lodSetOff.png") --@var : lodSetIcon | Icono Off para sets de nivel de dellae.
		local flatColorObjectSetIconOff = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\flatColorObjectSetOff.png") --@var : lodSetIcon | Icono Off para sets de nivel de dellae.
		
		local overridesIconsOff = #() --@var : overridesIconsOff | Array para los iconos específicos de cada override desactivado.
		
		local treeIconsOff = #(passTreeIconOff, passGroupIconOff, passIconOff, settingsIconOff, settingIconOff, overridesIconOff, overrideIconOff, lightSetIconOff, lightIconOff, objectSetIconOff, nodeSetIconOff, hiddenObjectSetIconOff, objectIconOff, lodSetIconOff, flatColorObjectSetIconOff) --@var : treeIconsOff | Agrupacion de todos los iconos Off en un array para que los reconozca el arbol. 
		--------------------------------------

		--------------------------------------
		--iconos de color claro, para operaciones como Cut

		local passTreeIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passTreeLight.png") --@var : passTreeIconLight | Icono Light para arboles de pases.
		local passGroupIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passGroupLight.png") --@var : passGroupIconLight | Icono Light para grupos de pases.
		local passIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passLight.png") --@var : passIconLight | Icono Light para pases.
		local settingsIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\settingsLight.png") --@var : settingsIconLight | Icono Light para settings generales.
		local settingIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\settingLight.png") --@var : settingIconLight | Icono Light para setting general.
		local overridesIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\overridesLight.png") --@var : overridesIconLight | Icono Light para overrides de propiedades.
		local overrideIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\overrideLight.png") --@var : overrideIconLight | Icono Light para override de propiedades.
		local lightSetIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lightSetLight.png") --@var : lightSetIconLight | Icono Light para sets de luces.
		local lightIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lightLight.png") --@var : lightLight | Icono Light para luces.
		local objectSetIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\objectSetLight.png") --@var : objectSetIconLight | Icono Light para sets de objetos.
		local nodeSetIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\nodeSetLight.png") --@var : nodeSetIconLight | Icono Light para sets de nodos.
		local hiddenObjectSetIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\hiddenObjectSetLight.png") --@var : hiddenObjectSetIcon | Icono Light para sets de nodos ocultos.
		local objectIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\objectLight.png") --@var : objectIconLight | Icono Light para objetos.
		local lodSetIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lodSetLight.png") --@var : lodSetIcon | Icono Light para sets de nivel de detalle.
		local flatColorObjectSetIconLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\flatColorObjectSetLight.png") --@var : lodSetIcon | Icono Light para sets de nivel de detalle.
		
		local overridesIconsLight = #() --@var : overridesIconsLight | Array para los iconos específicos de cada override en claro.
		
		local treeIconsLight = #(passTreeIconLight, passGroupIconLight, passIconLight, settingsIconLight, settingIconLight, overridesIconLight, overrideIconLight, lightSetIconLight, lightIconLight, objectSetIconLight, nodeSetIconLight, hiddenObjectSetIconLight, objectIconLight, lodSetIconLight, flatColorObjectSetIconLight) --@var : treeIconsLight | Agrupacion de todos los iconos Light en un array para que los reconozca el arbol. 
		--------------------------------------

		--------------------------------------
		--iconos de color claro en off, para operaciones como Cut

		local passTreeIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passTreeOffLight.png") --@var : passTreeIconOffLight | Icono OffLight para arboles de pases.
		local passGroupIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passGroupOffLight.png") --@var : passGroupIconOffLight | Icono OffLight para grupos de pases.
		local passIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\passOffLight.png") --@var : passIconOffLight | Icono OffLight para pases.
		local settingsIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\settingsOffLight.png") --@var : settingsIconOffLight | Icono OffLight para settings generales.
		local settingIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\settingOffLight.png") --@var : settingIconOffLight | Icono OffLight para setting general.
		local overridesIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\overridesOffLight.png") --@var : overridesIconOffLight | Icono OffLight para overrides de propiedades.
		local overrideIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\overrideOffLight.png") --@var : overrideIconOffLight | Icono OffLight para override de propiedades.
		local lightSetIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lightSetOffLight.png") --@var : OffLightSetIconOffLight | Icono OffLight para sets de luces.
		local lightIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lightOffLight.png") --@var : OffLightLight | Icono OffLight para luces.
		local objectSetIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\objectSetOffLight.png") --@var : objectSetIconOffLight | Icono OffLight para sets de objetos.
		local nodeSetIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\nodeSetOffLight.png") --@var : nodeSetIconOffLight | Icono OffLight para sets de nodos.
		local hiddenObjectSetIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\hiddenObjectSetOffLight.png") --@var : hiddenObjectSetIcon | Icono OffLight para sets de nodos ocultos.
		local objectIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\objectOffLight.png") --@var : objectIconOffLight | Icono OffLight para objetos.
		local lodSetIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\lodSetOffLight.png") --@var : lodSetIcon | Icono OffLight para sets de nivel de detalle.
		local flatColorObjectSetIconOffLight = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\flatColorObjectSetOffLight.png") --@var : lodSetIcon | Icono OffLight para sets de nivel de detalle.

		local overridesIconsOffLight = #() --@var : overridesIconsOffLight | Array para los iconos específicos de cada override desactivado en claro.
		
		local treeIconsOffLight = #(passTreeIconOffLight, passGroupIconOffLight, passIconOffLight, settingsIconOffLight, settingIconOffLight, overridesIconOffLight, overrideIconOffLight, lightSetIconOffLight, lightIconOffLight, objectSetIconOffLight, nodeSetIconOffLight, hiddenObjectSetIconOffLight, objectIconOffLight, lodSetIconOffLight, flatColorObjectSetIconOffLight) --@var : treeIconsOffLight | Agrupacion de todos los iconos OffLight en un array para que los reconozca el arbol. 
		--------------------------------------

		--------------------------------------
		--iconos de drag and drop

		local dragIconArrow = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\dragArrow.png") --@var : dragIconArrow | Icono de flecha de drag.
		local dragIconForbidden = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\dragForbidden.png") --@var : dragIconForbidden | Icono de prohibido de drag.
		--------------------------------------

		--------------------------------------
		--iconos de estado

		local okIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\ok.png") --@var : okIcon | Icono para estado correcto.
		local okOverrideIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\okOverride.png") --@var : okIcon | Icono para estado correcto con overrides internos.
		local warningIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\warning.png") --@var : warningIcon | Icono para estado de warning.
		local errorIcon = dotnetObject "System.Drawing.Bitmap" ((lb.config.getToolsIconsPath()) + @"passManager\error.png") --@var : errorIcon | Icono para estado erroneo.
		
		local stateIcons = #(okIcon, okOverrideIcon, warningIcon, errorIcon) --@var : stateIcons | Agrupacion de todos los iconos de estado en un array para que los reconozca el arbol. 
		--------------------------------------

		--------------------------------------
		--colores para el interface
		
		local passTreeColor = (dotNetClass "System.drawing.color").fromArgb 75 105 140 --@var : passTreeColor | Color para grupos de pases.
		local passGroupColor = (dotNetClass "System.drawing.color").fromArgb 75 105 140 --@var : passGroupColor | Color para grupos de pases.
		local passColor = (dotNetClass "System.drawing.color").fromArgb 75 105 140 --@var : passColor | Color para pases.
		local settingColor = (dotNetClass "System.drawing.color").fromArgb 135 70 85 --@var : settingColor | Color para settings generales.
		local overrideColor = (dotNetClass "System.drawing.color").fromArgb 135 70 85 --@var : overrideColor | Color para overrides de propiedades.
		local lightSetColor = (dotNetClass "System.drawing.color").fromArgb 100 80 50 --@var : lightSetColor | Color para sets de luces.
		local objectSetColor = (dotNetClass "System.drawing.color").fromArgb 65 110 75 --@var : objectSetColor | Color para sets de objetos.
		
		local passTreeColor2 = (dotNetClass "System.drawing.color").fromArgb 75 175 230 --@var : passTreeColor2 | Color para grupos de pases.
		local passGroupColor2 = (dotNetClass "System.drawing.color").fromArgb 75 175 230 --@var : passGroupColor2 | Color para grupos de pases.
		local passColor2 = (dotNetClass "System.drawing.color").fromArgb 75 175 230 --@var : passColor2 | Color para pases.
		local settingColor2 = (dotNetClass "System.drawing.color").fromArgb 255 70 105 --@var : settingColor2 | Color para settings generales.
		local overrideColor2 = (dotNetClass "System.drawing.color").fromArgb 255 70 105 --@var : overrideColor2 | Color para overrides de propiedades.
		local lightSetColor2 = (dotNetClass "System.drawing.color").fromArgb 255 185 70 --@var : lightSetColor2 | Color para sets de luces.
		local objectSetColor2 = (dotNetClass "System.drawing.color").fromArgb 65 200 100 --@var : objectSetColor2 | Color para sets de objetos.
		
		local treeColors = #(passTreeColor, passGroupColor, passColor, settingColor, settingColor, overrideColor, overrideColor, lightSetColor, lightSetColor, objectSetColor, objectSetColor) --@var : treeColors | Agrupacion de todos los Colores en un array para poder averiguar la correspondencia entre un contenedor y su color.
		local treeColors2 = #(passTreeColor2, passGroupColor2, passColor2, settingColor2, settingColor2, overrideColor2, overrideColor2, lightSetColor2, lightSetColor2, objectSetColor2, objectSetColor2) --@var : treeColors2 | Agrupacion de todos los Colores en un array para poder averiguar la correspondencia entre un contenedor y su color.
		
		local generalBackColor = (dotNetClass "System.drawing.color").fromArgb 50 50 50
		local selectedRowBackColor = (dotNetClass "System.drawing.color").fromArgb 120 145 215
		local selectedCellBackColor = (dotNetClass "System.drawing.color").fromArgb 120 145 215
	
		local generalForeColor = (dotNetClass "System.drawing.color").fromArgb 200 200 200 --230 230 230
		--local infoColumnForeColor = (dotNetClass "System.drawing.color").fromArgb 150 150 150
		local selectedRowForeColor = (dotNetClass "System.drawing.color").fromArgb 30 30 30
		local selectedCellForeColor = (dotNetClass "System.drawing.color").fromArgb 30 30 30
		
		local treeLinesColor = (dotNetClass "System.drawing.color").fromArgb 120 120 120
		local generalGridColor = (dotNetClass "System.drawing.color").fromArgb 70 70 70
		
		local disabledColor1 = (dotNetClass "System.drawing.color").fromArgb 150 150 150
		local disabledColor2 = (dotNetClass "System.drawing.color").fromArgb 180 180 180
		
		local cameraLcolor = (dotNetClass "System.drawing.color").fromArgb 20 150 250
		local cameraRcolor = (dotNetClass "System.drawing.color").fromArgb 0 150 75
		
		local errorColor = (dotNetClass "System.drawing.color").fromArgb 255 10 010
		local warningColor = (dotNetClass "System.drawing.color").fromArgb 255 150 50
		--------------------------------------		

		------------------------------------------------------------------------------------------------
		--CONTROLS
		------------------------------------------------------------------------------------------------
		
		local rtbCaptionEditor = dotNetObject "System.Windows.Forms.richtextbox" --@control: rtbCaptionEditor | Cuadro de edicion para los nombres de los contenedores de los contenedores.
			
		local cmsRmenu = dotnetObject "System.Windows.Forms.ContextMenuStrip" --@control: cmsRmenu | Menu de boton derecho para las opciones del arbol de contenedores.
		
		dotNetControl msMainMenu "System.Windows.Forms.MenuStrip" pos:[0,0] width:400 height:25 visible:true --@control: msMainMenu | Menú principal de la herramienta.
		
		--checkbutton ckbMode
		label lblMode "Mode: " pos:[5,31] width:85
		--checkbox chkShowLogs "Save/Show logs" pos:[5,31] checked:true visible:true
		
		label lblSeparator01 "|" pos:[125,31] enabled:false
		
		checkbutton ckbLcameraMode "L Mode" pos:[140,29] width:60 height:20 highlightColor:(color 20 120 250) --@control: ckbLcameraMode | Indica el modo de camara L o R en el que esta la herramienta.
		checkbutton ckbRcameraMode "R Mode" pos:[200,29] width:60 height:20 highlightColor:(color 0 150 75) --@control: ckbRcameraMode | Indica el modo de camara L o R en el que esta la herramienta.		
		
		dotNetControl btnCameraModeBorderU "System.Windows.Forms.Button" pos:[0,50] width:400 height:5 enabled:false
		dotNetControl btnCameraModeBorderL "System.Windows.Forms.Button" pos:[0,50] width:5 height:523 enabled:false
		dotNetControl btnCameraModeBorderR "System.Windows.Forms.Button" pos:[395,50] width:5 height:523 enabled:false
		dotNetControl btnCameraModeBorderB "System.Windows.Forms.Button" pos:[0,568] width:400 height:5 enabled:false
		
		label lblSeparator02 "|" pos:[270,31] enabled:false
		
		label lblPreviewPercent "Preview %" pos:[295,31]
		dropdownlist ddlPreviewPercent pos:[352,27] width:45 height:15 items:#("100", "75", "50", "25") selection:3 --@control: ddlPreviewPercent | Listado de porcentajes de preview de render.
		
		label lblRender "Render:" pos:[6,578] width:40
		button btnRenderLocal "Local" pos:[50,575] width:110 height:20 tooltip:"Render Local" --@control: btnRenderLocal | Boton para hacer render en local.
		button btnRenderNetwork "Network" pos:[165,575] width:110 height:20 tooltip:"Render Network" --@control: btnRenderNetwork | Boton para hacer render de todos los pases en granja.
		button btnCommandRenderNetwork "Console Network" pos:[280,575] width:110 height:20 tooltip:"Fast Render Network" --@control: btnRenderNetwork | Boton para hacer render de todos los pases en granja a traves de consola de comandos (automatizado).
		

		progressbar pbRender "" pos:[48,575] width:344 height:20 color:green visible:false
		
		dotNetControl trvContainers "DevExpress.XtraTreeList.TreeList" pos:[5,55] width:390 height:515 --@control: trvContainers | Arbol de representación de contenedores.
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | createSceneEvents | Crea los callbacks relacionados con el rollout
		------------------------------------------------
		fn createSceneEvents =
		(
			_id = ((parent.className + "_" + (substituteString parent.rollMain.name "Def" "")) as name)
			callbacks.addscript #filePostMerge "undo off (lb.passManagerUI.rollMain.updateTrvContainers clear:true; lb.passManagerUI.expandTree level:2)" id:_id
			callbacks.addscript #filePostOpenProcess "undo off (lb.passManagerUI.rollMain.updateTrvContainers clear:true; lb.passManagerUI.expandTree level:2)" id:_id
		)
		
		------------------------------------------------
		--@fn: undefined | removeSceneEvents | Destruye los callbacks relacionados con el rollout
		------------------------------------------------
		fn removeSceneEvents =
		(
			_id = ((parent.className + "_" + (substituteString parent.rollMain.name "Def" "")) as name)
			callbacks.removescripts id:_id
		)
		
		------------------------------------------------
		--@fn: undefined | forceTrvContainersCorrectSelection | Hace que la seleccion del arbol sea correcta. Solo elementos del mismo nivel y del mismo tipo
		------------------------------------------------
		fn forceTrvContainersCorrectSelection =
		(
			_currSel = trvContainers.selection --almacena la seleccion actual

			--solo si hay elementos seleccionados
			if _currSel.count == 0 then
			(
				lastSelectionLevel = -1
				lastSelectionType = undefined
			)
			else if _currSel.count == 1 then
			(
				lastSelectionLevel = _currSel.item[0].level --almaena el nivel de los nodos seleccionados actualmente
				lastSelectionType = (_currSel.item[0]).getValue 2 --almacena el tipo del
			)
			else
			(
				--por si no habia nada previo seleccionado
				if lastSelectionLevel == -1 then lastSelectionLevel = _currSel.item[0].level
				if lastSelectionType == undefined then lastSelectionType = (_currSel.item[0]).getValue 2

				for i=_currSel.count to 1 by -1 where ((_currSel.item[i-1]).getValue 2) != lastSelectionType or _currSel.item[i-1].level != lastSelectionLevel do
					trvContainers.selection.Remove _currSel.item[i-1]
			)--if

			_topIndex = trvContainers.TopVisibleNodeIndex --hace backup del nodo visible mas arriba para no perderlo al deseleccionar
			trvContainers.FocusedNode = undefined --impide que se quede pintado un nodo no seleccionado
			trvContainers.TopVisibleNodeIndex = _topIndex --restarua el scroll
		)	
		
		------------------------------------------------
		--@fn: integer | getIconIndex | Devuelve el índice del icono que debe usar en funcion del tipo de contenido.
		--@gets: name | type | Tipo del icono del que se quiere el índice.
		--@gets: string | state | Estado del icono del que se quiere el índice.
		------------------------------------------------
		fn getIconIndex type state subtype:undefined =
		(
			_index = 0
				
			_index = (findItem containersLevelOrder type) - 1

			if _index >= 0 then
			(
				if type == #override then
				(
					_ovIndex = (findItem containersLevelOrder subtype) - 1
					if _ovIndex >= 0 then _index = _ovIndex
				)--if
				case state of
				(
					"off": _index += treeIcons.count
					"light": _index += 2*(treeIcons.count)
					"offLight": _index += 3*(treeIcons.count)
				)--case
			)--if
			
			if _index < 0 then _index = 0
			
			_index
		)
		
		------------------------------------------------
		--@fn: integer | getColorIndex | Devuelve el índice del color que debe usar en funcion del tipo de contenido.
		--@gets: name | type | Tipo del color del que se quiere el índice.		
		------------------------------------------------
		fn getColorIndex type =
		(
			(getIconIndex type "on") + 1
		)
		
		------------------------------------------------
		--@fn: undefined | updateTrvContainerAppearance | rellena la informacion visual de apariencia del nodo segun sus propiedades.
		--@opt: name | mode | #icon | Indica que parte del nod actualizar. #init, #icon, #color.
		--@opt: xtraTreeListNode | node | undefined | Nodo que actualizar.
		--@opt: event | event | undefined | Evento que lo ha lanzado si es que lo ha lanzado un evento.
		------------------------------------------------
		fn updateTrvContainerAppearance mode:#none node:undefined event:undefined =
		(
			------------------------------------------------
			case mode of
			(
				#init:
				(
					if node != undefined then node.imageIndex = 0
				)--init
				
				#icon:
				(
					if event != undefined then
					(						
						_type = (event.Node.getValue 2) as name
						_subSubType = (event.Node.getValue 3) as name
						_state = (event.Node.getValue 4)
						_intensity = (event.Node.getValue 6)
						if _intensity == "light" then _state = (if _state == "off" then "offLight" else "light")

						--caso especial, si es un override requerido, el icono debe ser el de settings
						if _type == #overrides and _subSubType == #required then _type = #settings
						if _type == #override and _subSubType == #required then _type = #setting

						_iconIndex = getIconIndex _type _state subType:_subSubType
						event.NodeImageIndex = _iconIndex
					)
					else if node != undefined then
					(
						_type = (node.getValue 2) as name
						_subSubType = (node.getValue 3) as name
						_state = (node.getValue 4)
						_intensity = (node.getValue 6)
						if _intensity == "light" then _state = (if _state == "off" then "offLight" else "light")

						--caso especial, si es un override requerido, el icono debe ser el de settings
						if _type == #overrides and _subSubType == #required then _type = #settings
						if _type == #override and _subSubType == #required then _type = #setting

						_iconIndex = getIconIndex _type _state subType:_subSubType
						node.imageIndex = _iconIndex
						node.SelectImageIndex = _iconIndex						
					)--if else			
				)--icon
				
				#state:
				(	
					if event != undefined then
					(
						--TO DO
					)
					else if node != undefined then
					(
						case (node.getValue 5) of
						(
							"ok": node.StateImageIndex = 0
							"okOverride": node.StateImageIndex = 1
							"warning": node.StateImageIndex = 2
							"error": node.StateImageIndex = 3
							default: node.StateImageIndex = 0
						)
					)--if else			
				)--icon
				
				#color:
				(
					if event != undefined then
					(
						if event.Node.Selected then
							event.appearance.BackColor = selectedCellBackColor
						else if event.Node.Focused then
							event.appearance.BackColor = selectedRowBackColor
						else
						(					
							_colorIndex = getColorIndex ((event.Node.getValue 2) as name)
							_state = (event.Node.item[4] == "on") --para saber si el nodo esta deshabilitado
							
							if event.column.AbsoluteIndex == 0 then
							(
								event.appearance.BackColor = if _state then generalBackColor else disabledColor1
								event.appearance.BackColor2 = if _state then treeColors[_colorIndex] else disabledColor2
							)--if
							
							if event.column.AbsoluteIndex == 1 then
							(
								event.appearance.BackColor = if _state then treeColors[_colorIndex] else disabledColor2
								event.appearance.BackColor2 = treeColors2[_colorIndex]
							)--if
						)
					)
					else if node != undefined then
					(
						_intensity = (node.getValue 6)
						if _intensity == "light" and (findString node.item[0] "<< cut >> " == undefined) then
						(
							node.setValue 0 ("<< cut >> " + node.item[0])							
						)--if

						/*--ESTO NO FUNCIONA, nunca llega a pintar las celdas
						
						_index = trvContainers.GetVisibleIndexByNode(node)						
 						_rowsCount = trvContainers.ViewInfo.RowsInfo.Rows.count
						
						--obtiene el control de apariencia de cada nodo
 						if _index < _rowsCount then
 						(
 							_rowInfo = trvContainers.ViewInfo.RowsInfo.Rows.item[_index]
 							_cellInfo = _rowInfo.Cells.item[1]						
 							_cellAppearance = _cellInfo.PaintAppearance
 							
 							_colorIndex = getColorIndex (node.item[2] as name)
 							_state = (node.item[4] == "on") --para saber si el nodo esta deshabilitado

 							_cellAppearance.ForeColor = generalBackColor
 							_cellAppearance.BackColor = if _state then generalBackColor else disabledColor1
 							_cellAppearance.BackColor2 = if _state then treeColors[_colorIndex] else disabledColor2
 						)--if*/
					)--if else
				)--color

				#cut:
				(
					if node != undefined then
					(
						_intensity = (node.getValue 6)
						
						if _intensity == "light" then
						(
							if (findString node.item[0] "<< cut >> " == undefined) then node.setValue 0 ("<< cut >> " + node.item[0])
						)
						else
						(
							node.setValue 0 (substituteString node.item[0] "<< cut >> " "")
						)				
					)--if
				)--color
			)--case
			------------------------------------------------
		)
		
		------------------------------------------------
		--@fn: undefined | updateTrvContainers | Rellena la información del arbol y los listados
		--@opt: name | mode | #add | Indica si la actualizacion es porque se han añadido contenedores o porque se han eliminado, para no redibujar el arbol entero.
		--@opt: boolean | clear | false | Si está a TRUE, limpia el arbol entero antes de redibujarlo.
		--@opt: container | specificContainer | undefined | Si se suminstra un contenedor en concreto, actualiza solo ese contenedor.
		--@opt: boolean | useParentToAdd | true | Si es TRUE, idica que en el modo #add se añade desde el nodo padre del pasado en specificContainer, si es FALSE se hace desde el mismo.
		------------------------------------------------
		fn updateTrvContainers mode:#add clear:false specificContainer:undefined useParentToAdd:true =
		(
			if clear then --si tiene que redibujar el arbol entero
			(
				trvContainers.ClearNodes() --limpia el arbol
				parent.fillContainerTrees() --recolecta la informacion de los contenedores
			)
			
			case mode of
			(
				#update:
				(
					--este caso solo se da si se suministra un contenedor que actualizar
					if specificContainer != undefined then
					(
						--lb.timeStamps.start()

						--obtiene el objeto de ui del contenedor
						_uiObj = specificContainer.getUiObj()
						--lb.timeStamps.printTime message:("updateTrvContainers - getUiObj - " + (specificContainer.getCaption()))

						--si el contenedor tiene objeto de ui
						if _uiObj != undefined then
						(
							--allowRedrawIcons = true
							
							------------------------------------------------
							--solo si el nombre ha cambiado se actualiza
							_specificContainerCaption = specificContainer.getCaption()
							if (specificContainer.getSubType()) == #passGroup do
								_specificContainerCaption = "----------" + _specificContainerCaption + "----------"
							if _uiObj.item[0] != _specificContainerCaption then _uiObj.setValue 0 (_specificContainerCaption)
							------------------------------------------------
							
							--lb.timeStamps.printTime message:("updateTrvContainers - update caption - " + (specificContainer.getCaption()))

							------------------------------------------------
							--actualiza la informacion específica del contenedor para la columna 2
							specificContainer.updateUIinfo()
							------------------------------------------------								
							
							--lb.timeStamps.printTime message:("updateTrvContainers - updateUIinfo - " + (specificContainer.getCaption()))

							------------------------------------------------
							--si el numero de nodeSets ha variado se debe actualizar.
							
							--lb.timeStamps.start()

							--obtiene los nombres de los nodeSets mostrados y de los que tiene que mostrar y sus estados
							_currentShownNodeSets = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "nodeSet" collect _uiObj.nodes.item[i-1].item[0]

							--lb.timeStamps.printTime message:("updateTrvContainers - _currentShownNodeSets - " + (specificContainer.getCaption()))
							--lb.timeStamps.start()

							--lb.timeStamps.printTime message:("updateTrvContainers - _realNodeSets - " + (specificContainer.getCaption()))

							_realNodeSetList = specificContainer.getNodeSetNames()

							--lb.timeStamps.printTime message:("updateTrvContainers - _realNodeSetList - " + (specificContainer.getCaption()))

							_realNodeSetStates = specificContainer.getNodeSetEnabledStates()

							--lb.timeStamps.printTime message:("updateTrvContainers - getNodeSetEnabledStates - " + (specificContainer.getCaption()))
							
							--lb.timeStamps.printTime message:("updateTrvContainers - current info - " + (specificContainer.getCaption()))

							--si el numero de nodeSets ha cambiado
							if _currentShownNodeSets.count != _realNodeSetList then
							(
								--si hay que añadir
								if _realNodeSetList.count > _currentShownNodeSets.count then
								(
									--_realNodeSets = specificContainer.getNodeSets()

									for i=(_currentShownNodeSets.count + 1) to _realNodeSetList.count do
									(
										_enabledState = (if _realNodeSetStates[i] then "on" else "off")	
										_nodesText = "nodeSet" --("nodes(" + ((_realNodeSets[i].getNodesNames purgue:false).count as string) + ")")
										_newUiObj = trvContainers.AppendNode #(_realNodeSetList[i], _nodesText, "nodeSet", "", _enabledState, "ok", "dark") _uiObj --crea el nodo
										updateTrvContainerAppearance mode:#icon node:_newUiObj
										updateTrvContainerAppearance mode:#state node:_newUiObj
									)
								)
								else --si hay que quitar
								(	
									--obtiene los Ids en el arbol de los nodeSets mostrados
									_currentShownNodeSetsIds = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "nodeSet" collect _uiObj.nodes.item[i-1].id
									
									--elimina todos los que sobren
									for i=(_currentShownNodeSets.count) to 1 by -1 do
									(
										_index = findItem _realNodeSetList _currentShownNodeSets[i]
										if _index == 0 then trvContainers.DeleteNode (trvContainers.FindNodeByID _currentShownNodeSetsIds[i])
									)--for									
								)--else
							)
							else --si no ha cambiado el numero de nodeSets, puede haber cambiado su informacion y la actualiza
							(
								--_realNodeSets = specificContainer.getNodeSets()

								_nodeSetsUINodes = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "nodeSet" collect _uiObj.nodes.item[i-1]
								for i=1 to _realNodeSetList.count do _nodeSetsUINodes[i].setValue 1 "nodeSet" --("nodes(" + (((_realNodeSets[i]).getNodesNames purgue:false).count as string) + ")")
							)--if else
							------------------------------------------------
							
							--lb.timeStamps.printTime message:("updateTrvContainers - nodeSets - " + (specificContainer.getCaption()))

							------------------------------------------------
							--si el numero de luces ha variado se debe actualizar.
							
							--obtiene los nombres de las luces mostradas y de las que tiene que mostrar y sus estados
							_currentShownLights = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "light" collect _uiObj.nodes.item[i-1].item[0]
							_realLights = specificContainer.getLightNodes()
							_realLightList = specificContainer.getLightNames()
							_realLightStates = specificContainer.getLightEnabledStates()
							
							--si el numero de luces ha cambiado
							if _currentShownLights.count != _realLightList.count then
							(
								--si hay que añadir
								if _realLightList.count > _currentShownLights.count then
								(
									for i=(_currentShownLights.count + 1) to _realLightList.count do
									(
										_enabledState = (if _realLightStates[i] == true then "on" else "off")
										_nodesText = (classOf _realLights[i]) as string
										_newUiObj = trvContainers.AppendNode #(_realLightList[i], _nodesText, "light", "", _enabledState, "ok", "dark") _uiObj --crea el nodo
										updateTrvContainerAppearance mode:#icon node:_newUiObj
										updateTrvContainerAppearance mode:#state node:_newUiObj
									)
								)
								else --si hay que quitar
								(	
									--obtiene los Ids en el arbol de los nodeSets mostrados
									_currentShownLightsIds = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "light" collect _uiObj.nodes.item[i-1].id
									
									--elimina todos los que sobren
									for i=(_currentShownLightsIds.count) to 1 by -1 do
									(
										_index = findItem _realLightList _currentShownLights[i]
										if _index == 0 then trvContainers.DeleteNode (trvContainers.FindNodeByID _currentShownLightsIds[i])
									)--for									
								)--else
							)
							else --si no ha cambiado el numero de luces, puede haber cambiado su informacion y la actualiza
							(
								_lightsUINodes = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "light" collect _uiObj.nodes.item[i-1]
								for i=1 to _realLights.count do _lightsUINodes[i].setValue 1 ((classOf _realLights[i]) as string)
							)--if else
							------------------------------------------------
							
							--lb.timeStamps.printTime message:("updateTrvContainers - lights - " + (specificContainer.getCaption()))

							------------------------------------------------
							--si el numero de overrides ha variado se debe actualizar.
							if /*specificContainer.getSubType() == #settings or*/ specificContainer.getSubType() == #overrides then
							(
								--obtiene los nombres de los overrides mostrados y de los que tiene que mostrar y sus estados
								_currentShownOverrides = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "override" collect _uiObj.nodes.item[i-1].item[0]
								_realOverrides = specificContainer.getOverrides()
								_realOverridesList = specificContainer.getOverrideNames()
								_realOverridesStates = specificContainer.getOverrideEnabledStates()
								_realOverridesTypes = for _ov in _realOverrides collect _ov.getSubType()
								_requiredOverrides = specificContainer.getRequiredOverrideTypes()
								
								if _currentShownOverrides.count != _realOverridesList.count then
								(
									--obtiene los Ids en el arbol de los overrides mostrados y los elimina
									_currentShownOverridesIds = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "override" collect _uiObj.nodes.item[i-1].id
									
									--elimina todos los que sobren
									for i=_currentShownOverridesIds.count to 1 by -1 do trvContainers.DeleteNode (trvContainers.FindNodeByID _currentShownOverridesIds[i])
									
									for i=1 to _realOverridesList.count do
									(
										_enabledState = (if _realOverridesStates[i] then "on" else "off")
										_state = (_realOverrides[i].getState()) as string
											
										_subSubType = if findItem _requiredOverrides _realOverridesTypes[i] != 0 then "required" else _realOverridesTypes[i]
										
										_ovUiObj = trvContainers.AppendNode #(_realOverridesList[i], (_realOverrides[i].getInfo()), "override", _subSubType, _enabledState, _state, "dark") _uiObj --crea el nodo
										_realOverrides[i].setUiObj _ovUiObj --añade el objeto de ui al override
										updateTrvContainerAppearance mode:#icon node:_ovUiObj
										updateTrvContainerAppearance mode:#state node:_ovUiObj
									)--for
									
									/*--si hay que añadir
									if _realOverridesList.count > _currentShownOverrides.count then
									(
										for i=(_currentShownOverrides.count + 1) to _realOverridesList.count do
										(
											_enabledState = (if _realOverridesStates[i] then "on" else "off")
											_subSubType = (if findItem _requiredOverrides _realOverridesTypes[i] != 0 then "required" else "optional")
											
											_ovUiObj = trvContainers.AppendNode #(_realOverridesList[i], (_realOverrides[i].getInfo()), "override", _subSubType, _enabledState) _uiObj --crea el nodo
											_realOverrides[i].setUiObj _ovUiObj --añade el objeto de ui al override
										)
									)
									else --si hay que quitar
									(	
										--obtiene los Ids en el arbol de los overrides mostrados
										_currentShownOverridesIds = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "override" collect _uiObj.nodes.item[i-1].id
										
										--elimina todos los que sobren
										for i=(_currentShownOverrides.count) to 1 by -1 do
										(
											_index = findItem _realOverridesList _currentShownOverrides[i]
											if _index == 0 then trvContainers.DeleteNode (trvContainers.FindNodeByID _currentShownOverridesIds[i])
										)--for									
									)--else*/
								)
								else --si no ha cambiado el numero de nodeSets, puede haber cambiado su informacion y la actualiza
								(
									for _ov in _realOverrides do 
									(	
										(_ov.getUIobj()).SetValue 0 (_ov.getCaption())
										_ov.updateUIinfo()
									)
								)--if else
							)--if
							------------------------------------------------

							------------------------------------------------
							--si el numero de objetos ha variado se debe actualizar.
							
							--obtiene los nombres de los objetos mostrados y de los que tiene que mostrar y sus estados
							_currentShownObjects = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "object" collect _uiObj.nodes.item[i-1].item[0]
							_realObjects = specificContainer.getNodes()
							_realObjectList = specificContainer.getNodesNames()
							_realObjectStates = specificContainer.getNodesEnabledStates()
							
							--si el numero de objetos ha cambiado
							if _currentShownObjects.count != _realObjectList.count then
							(
								--si hay que añadir
								if _realObjectList.count > _currentShownObjects.count then
								(
									for i=(_currentShownObjects.count + 1) to _realObjectList.count do
									(
										_enabledState = (if _realObjectStates[i] then "on" else "off")
										_nodesText = (classOf _realObjects[i]) as string
										_newUiObj = trvContainers.AppendNode #(_realObjectList[i], _nodesText, "object", "", _enabledState, "ok", "dark") _uiObj --crea el nodo
										updateTrvContainerAppearance mode:#icon node:_newUiObj
										updateTrvContainerAppearance mode:#state node:_newUiObj
									)
								)
								else --si hay que quitar
								(	
									--obtiene los Ids en el arbol de los nodeSets mostrados
									_currentShownObjectsIds = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "object" collect _uiObj.nodes.item[i-1].id
									
									--elimina todos los que sobren
									for i=(_currentShownObjectsIds.count) to 1 by -1 do
									(
										_index = findItem _realObjectList _currentShownObjects[i]
										if _index == 0 then trvContainers.DeleteNode (trvContainers.FindNodeByID _currentShownObjectsIds[i])
									)--for									
								)--else
							)
							else --si no ha cambiado el numero de luces, puede haber cambiado su informacion y la actualiza
							(
								_objectsUINodes = for i=1 to _uiObj.nodes.count where (_uiObj.nodes.item[i-1].item[2]) == "object" collect _uiObj.nodes.item[i-1]
								for i=1 to _realObjects.count do _objectsUINodes[i].setValue 1 ((classOf _realObjects[i]) as string)
							)--if else
							------------------------------------------------
							
							--lb.timeStamps.printTime message:("updateTrvContainers - overrides - " + (specificContainer.getCaption()))

							--updateTrvContainerAppearance mode:#icon node:_uiObj
							--updateTrvContainerAppearance mode:#state node:_uiObj
							--allowRedrawIcons = false
						)--if					
					)--if
				)--update
				
				#add: --MEJORA RENDIMIENTO 2 (las otras versiones anteriores se han eliminado ya del codigo)
				(					
					------------------------------------------------
					--funcion para rellenar recursivamente los contenedores
					global _updateTrvContainers
					fn _updateTrvContainers treeContainer treeView redraw:false _firstCall:true _updateFn:updateTrvContainers =
					(
						--lb.timeStamps.start()

						---------------------------------
						_redraw = redraw --flag interno que puede cambiar
						_parentTrvNode = if treeContainer.getParent() != undefined then (if (treeContainer.getParent()).getUiObj() != undefined then (treeContainer.getParent()).getUiObj() else -1) else -1
						_uiNode = treeContainer.getUiObj() --si ya tenía objeto de UI lo usa
						---------------------------------
						
						--lb.timeStamps.printTime message:("_updateTrvContainers - getUiObj - " + (treeContainer.getCaption()))

						---------------------------------	
						_type = (treeContainer.getSubType() as string)
						_subSubType = ""
						if _type == "overrides" and treeContainer.getParent() != undefined and (treeContainer.getParent()).getSubType() == #passTree then _subSubType = "required"
						_enabledState = (if treeContainer.getEnabledState() then "on" else "off")
						_state = (treeContainer.getState()) as string
						---------------------------------
						
						--lb.timeStamps.printTime message:("_updateTrvContainers - getState - " + (treeContainer.getCaption()))

						_treeContainerCaption = treeContainer.getCaption()
						if (treeContainer.getSubType()) == #passGroup do
							_treeContainerCaption = "----------" + _treeContainerCaption + "----------"
						---------------------------------
						--si no hay nodo creado lo crea
						if _uiNode == undefined then
						(
							_uiNode = treeView.AppendNode #(_treeContainerCaption, "", _type, _subSubType, _enabledState, _state, "dark") _parentTrvNode --crea el nodo
							_redraw = true
						)
						else if redraw then
						(--si hay nodo y se le ha indicado dibujar lo elimina
							treeView.DeleteNode (treeView.FindNodeByID (_uiNode.id))
							treeContainer.removeUiObjHierarchy()
							
							_uiNode = treeView.AppendNode #(_treeContainerCaption, "", _type, _subSubType, _enabledState, _state, "dark") _parentTrvNode --crea el nodo
						)--if else if
						---------------------------------
						
						--lb.timeStamps.printTime message:("_updateTrvContainers - _uiNode - " + (treeContainer.getCaption()))

						---------------------------------
						treeContainer.setUiObj _uiNode --almacena el nodo de UI en el contenedor
						treeContainer.updateUIinfo() --actualiza la informacion específica del contenedor para la columna 2
						---------------------------------
						
						--lb.timeStamps.printTime message:("_updateTrvContainers - updateUIinfo - " + (treeContainer.getCaption()))

						---------------------------------
						--si hay subnodos dibjados ya, pero puede haber mas
						if _uiNode.nodes.count != 0 then
						(
							--numero de subnodos
							_nodesCount = _uiNode.nodes.count
							
							--almacena los hijos para hacer operaciones y no estar todo el tiempo obteniandolos y asi ahorrar tiempo
							_children = treeContainer.getChildren()
							
							--numero de hijos
							_childrenCount = _children.count
							_childrenCount += (treeContainer.getOverrides()).count
							_childrenCount += (treeContainer.getLightNames()).count
							_childrenCount += (treeContainer.getNodeSetNames()).count
							_childrenCount += (treeContainer.getNodes()).count
							
							--si es un arbol de pases no hay que tener en cuenta que de el pueden colgar overrides obligatorios ocultos para que se haga backup de ellos
							if (treeContainer.getSubType()) == #passTree then _childrenCount -= (treeContainer.getOverrides()).count
							
							--si se ha añadido solo un nodo	
							if _nodesCount == (_childrenCount - 1) then
							(
								_index = 0 --indice del nuevo nodo a ser dibujado
								_stop = false --flag de parada
								for i=1 to _children.count where not _stop do --recorre los hijos hasta averiguar cual es el nuevo
								(
									_index = i
									if not _redraw and i < _children.count do
									(
										_uiCaption = (_uiNode.nodes.item[i-1].getValue 0)
										if _children[i].getSubType() == #passGroup do
											_uiCaption = substituteString _uiCaption "----------" ""
										if _children[i].getCaption() != _uiCaption then _stop = true
									)
								)--for
								
								if _index != 0 then --si hay nodo nuevo lo dibuja y lo pone en su sitio
								(									
									_updateTrvContainers _children[_index] treeView redraw:true _firstCall:false _updateFn:_updateFn
									treeView.SetNodeIndex (_children[_index].getUiObj()) (_index - 1)								
								)--if
							)
							else if _nodesCount != _childrenCount then --si hay uan diferencia de mas de un solo nodo
							(
								--ESTO SE PODRÍA HACER AMPLIANDO EL IF ANTERIOR PARA TODO NODO QUE NO TENGA UIOBJ
								
								--si hay diferente numero de nodos los redibuja todos
								--dibuja los subcontainers
								for _ch in (treeContainer.getChildren()) do _updateTrvContainers _ch treeView redraw:true _firstCall:false _updateFn:_updateFn --crea los subnodos
							)
						)
						else --si no tenia subnodos dibujados, dibuja todos los hijos nuevos
						(
							--lb.timeStamps.start()

							--dibuja los subcontainers
							for _ch in (treeContainer.getChildren()) do _updateTrvContainers _ch treeView redraw:true _firstCall:false _updateFn:_updateFn --crea los subnodos

							--lb.timeStamps.printTime message:("_updateTrvContainers - subnodes - " + (treeContainer.getCaption()))
								
							_updateContent = false --indica si llamar a la actualizacion del contenido del nodo, por si tiene ObjectSets, luces u overrides
								
							--si es un lightSet, puede tener nodeSets añadidos
							if (treeContainer.getLightNames()).count != 0 then _updateContent = true

							--lb.timeStamps.printTime message:("_updateTrvContainers - getLightNames - " + (treeContainer.getCaption()))
								
							--si es un ObjectSet, puede tener nodeSets añadidos
							if (treeContainer.getNodeSetNames()).count != 0 then _updateContent = true

							--lb.timeStamps.printTime message:("_updateTrvContainers - getNodeSetNames - " + (treeContainer.getCaption()))

							--si es un hiddenObjectSet/lodSet, puede tener objetos añadidos
							if (treeContainer.getNodesNames()).count != 0 then _updateContent = true
							
							--si es un overrides, puede tener overrides añadidos
							if (treeContainer.getOverrideNames()).count != 0 then _updateContent = true

							--lb.timeStamps.printTime message:("_updateTrvContainers - getOverrideNames - " + (treeContainer.getCaption()))
							
							--si tiene que llamar a la actualizacion del contenido del nodo, por si tiene ObjectSets, luces u overrides
							if _updateContent then _updateFn mode:#update specificContainer:treeContainer

							--lb.timeStamps.printTime message:("_updateTrvContainers - _updateContent - " + (treeContainer.getCaption()))
						)

						--lb.timeStamps.printTime message:("_updateTrvContainers - subnodes - " + (treeContainer.getCaption()))

						---------------------------------
						
						updateTrvContainerAppearance mode:#icon node:_uiNode
						updateTrvContainerAppearance mode:#state node:_uiNode

						--lb.timeStamps.printTime message:("_updateTrvContainers - updateTrvContainerAppearance - " + (treeContainer.getCaption()))
					)--_updateTrvContainers
					------------------------------------------------
					
					------------------------------------------------
					--trvContainers.BeginUpdate()
					
					if specificContainer != undefined then
					(
						if useParentToAdd and specificContainer.getParent() != undefined then (_updateTrvContainers (specificContainer.getParent()) trvContainers _updateFn:updateTrvContainers)
						else (_updateTrvContainers specificContainer trvContainers _updateFn:updateTrvContainers)
					)
					else
					(
						--lb.timeStamps.start()
						
						for i=1 to parent.containerTrees.count do
						(
							_updateTrvContainers parent.containerTrees[i] trvContainers _updateFn:updateTrvContainers

							--lb.timeStamps.printTime message:("_updateTrvContainers - " + (parent.containerTrees[i].getCaption()))
						)--for

						--lb.timeStamps.printTime message:"_updateTrvContainers"
					)--if else
					
					--trvContainers.EndUpdate()
					--trvContainers.Refresh()
					------------------------------------------------
					
					_updateTrvContainers = undefined --libera de la memoria la funcion temporal
				)--add
				
				#remove:
				(
					if specificContainer != undefined then
					(
						trvContainers.DeleteNode (trvContainers.FindNodeByID (specificContainer.getUiObj()).id)
					)--if
				)--remove
			)--case
		)--updateTrvContainers
		
		------------------------------------------------
		--@event | mainMenuItemClickedEvent | Evento que se lanza al levantar el raton despues de hacer click.
		--@control: System.Windows.Forms.ToolStripMenuItem | msMainMenu | Menu principal.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		fn mainMenuItemClickedEvent self events =
		(
			--_itemName = (events.clickeditem.tostring())
			parent.menuItemClickedProcess self.text
		)
		
		------------------------------------------------
		--@fn: undefined | initMainMenu | Rellena las opciones del menu principal.		
		------------------------------------------------
		fn createMainMenu =
		(
			_menuItemNames = #("File", "Tools", "Mode", "Render", "Settings", "View")
			_menuSubItemNames = #( \
									#(), \
									#("Overrides Path Tracker", "Find nodeSet", "Find light"), \
									#("I+D+I", "Production"), \
									#(), \
									#("Save/Show Logs"), \
									#("Overrides", "Lightsets", "ObjectSets", "HiddenObjectSets", "LODSets", "NodeSets", "FlatColorobjectSets") \
								)
			
 			msMainMenu.items.clear()			
			--dotNet.setLifetimeControl msMainMenu #mxs
								
			--recorre los elemento del menu añadiendolos a la barra
			for i=1 to _menuItemNames.count do
			(
				_menuItem = (dotNetObject  "System.Windows.Forms.ToolStripMenuItem" _menuItemNames[i])
				dotNet.setLifetimeControl _menuItem #dotnet
				
				msMainMenu.items.add _menuItem
				
				--por cada subelemento de cada menu lo añade y le pone un evento
				for subItem in _menuSubItemNames[i] do
				(
					_itemTmp = undefined
					
					if classOf subItem == string then 
					(
						_itemTmp = (dotnetobject "System.Windows.Forms.ToolStripMenuItem" subItem)
						
						dotNet.addEventHandler _itemTMP "click" mainMenuItemClickedEvent --rollMainDef.mainMenuItemClickedEvent
						
						case subItem of
						(
							"I+D+I": _itemTmp.checked = (parent.mode == #idi)
							"Production": _itemTmp.checked = (parent.mode == #production)
							"Save/Show Logs": _itemTmp.checked = parent.saveLogs
							"Overrides Path Tracker":
							(
								_itemTmp.checked = (lb.getTool "overridesPathTracker").isOpen()
							)
							"Overrides": _itemTmp.checked = parent.viewOverrides
							"Lightsets": _itemTmp.checked = parent.viewLightSets
							"ObjectSets": _itemTmp.checked = parent.viewObjectSets
							"HiddenObjectSets": _itemTmp.checked = parent.viewHiddenObjectSets
							"LODSets": _itemTmp.checked = parent.viewLodSets
							"NodeSets": _itemTmp.checked = parent.viewNodeSets
							"FlatColorobjectSets": _itemTmp.checked = parent.viewFlatColorObjectSets
						)--case
					)
					else 
						_itemTmp = (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					
					dotNet.setLifetimeControl _itemTMP #dotnet
					_menuItem.dropDownItems.add _itemTmp					
				)--for
				
			)--for
		)
		
		------------------------------------------------
		--@event | rMenuItemclickedEvent | Evento que se lanza al levantar el raton despues de hacer click o click derecho.
		--@control: System.Windows.Forms.ContextMenuStrip | cmsRmenu | Menu de boton derecho.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		fn rMenuItemclickedEvent self events =
		(
			_itemName = (events.clickeditem.tostring())
			parent.menuItemClickedProcess _itemName
		)

		------------------------------------------------
		--@event | rSubMenuItemclickedEvent | Evento que se lanza al levantar el raton despues de hacer click o click derecho.
		--@control: System.Windows.Forms.ContextMenuStrip | cmsRmenu | Menu de boton derecho.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		fn rSubMenuItemclickedEvent self events =
		(
			_itemName = (self.tostring())
			parent.menuItemClickedProcess _itemName
		)
		
		------------------------------------------------
		--@fn: undefined | createRMenu | Rellena el menu de boton derecho en función de la opcion.
		--@gets: point2 | pos | Posición en la que debe dibujarse el menu.
		--@gets: name | menuType | Tipo de menu, que marca cuales serán los elementos internos del menu. Opciones -> #empty, #passTree, #passGroup, #pass, #ObjectSet, #lightSet.
		------------------------------------------------
		fn createRMenu pos menuType =
		(
			_rMenuItems = #() --array para almacenar los items del menu
			
			cmsRmenu.items.clear() --vacía el menú
			cmsRmenu.rendermode = (dotnetclass "System.Windows.Forms.ToolStripRenderMode").system --elige el modo de dibujado del menu
			
			case menuType of
			(
				#empty:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "New Pass Tree"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")					
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]					
				)--empty
				
				#passTree:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable Pass Tree/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "New Pass Group"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Render Local"
					append _rMenuItems "Render Network"					
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Duplicate Pass Tree/s"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "View Level 1"
					append _rMenuItems "View Level 2"
					append _rMenuItems "Expand All"
					append _rMenuItems "Collapse All"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove Pass Tree/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[8].enabled = parent.copyBufferItemsType == "passGroup" --solo se pueden pegar grupos de pases					
				)--sceneSettings
				
				#passGroup:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable Group/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "New Pass"
					append _rMenuItems "New Pass from preset"
					_rPresetPassesItems = #()
					append _rPresetPassesItems "New AO Pass"
					append _rPresetPassesItems "New Y Pass"
					append _rPresetPassesItems "New Z Pass"
					append _rPresetPassesItems "New Mask-XYZ Pass"
					append _rPresetPassesItems "New ETS Pass"
					append _rPresetPassesItems "New Pupil Pass"
					append _rPresetPassesItems "New UV Pass"
					append _rPresetPassesItems "New SMV Pass"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Render Local"
					append _rMenuItems "Render Network"
					append _rMenuItems "Console Network"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Duplicate Group/s"					
					append _rMenuItems "Copy"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Import Pass from file"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "View Level 1"
					append _rMenuItems "View Level 2"
					append _rMenuItems "Expand All"
					append _rMenuItems "Collapse All"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove Pass Group/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[10].enabled = parent.copyBufferItemsType == "pass" --solo se pueden pegar pases

					--añade todos los items a los submenús
					for i = 1 to _rPresetPassesItems.count do
					(
						_itemTMP = (dotnetobject "System.Windows.Forms.ToolStripMenuItem" _rPresetPassesItems[i])
						dotNet.addEventHandler _itemTMP "click" rSubMenuItemclickedEvent
						cmsRmenu.items.item[3].DropDownItems.add _itemTMP
					)
				)--passGroup
				
				#pass:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable Pass/es"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Render Preview"
					append _rMenuItems "Render Local"
					append _rMenuItems "Render Network"
					append _rMenuItems "Console Network"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Isolate"
					append _rMenuItems "Show all"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "New ObjectSet"
					append _rMenuItems "New LightSet"
					append _rMenuItems "New HiddenObjectSet"
					append _rMenuItems "New LODSet"
					append _rMenuItems "New FlatColorObjectSet"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Duplicate Pass/es"
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "View Level 1"
					append _rMenuItems "View Level 2"
					append _rMenuItems "Expand All"
					append _rMenuItems "Collapse All"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove Pass/es"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[6].enabled = (trvContainers.selection.count == 1) --solo se puede isolar si hay un solo elemento seleccionado
					cmsRmenu.items.item[23].enabled = (trvContainers.selection.count == 1) --solo se puede renombrar si hay un solo elemento seleccionado
					cmsRmenu.items.item[16].enabled = (parent.copyBufferItemsType == "lightSet") or (parent.copyBufferItemsType == "ObjectSet") or (parent.copyBufferItemsType == "hiddenObjectSet") or (parent.copyBufferItemsType == "lodSet") or (parent.copyBufferItemsType == "flatColorObjectSet") --solo se pueden pegar lightSets, ObjectSets, lodSets y HiddenObjectSets
				)--pass
				
				#settings:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable Settings"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "New Setting/Override"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")					
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Clear Settings/Overrides"
						
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[4].enabled = parent.copyBufferItemsType == "setting" --solo se pueden pegar settings
					cmsRmenu.items.item[2].enabled = (trvContainers.selection.count == 1) --solo se puede crear si hay un solo elemento seleccionado
				)--settings
				
				#overrides:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable Overrides"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "New Override"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")					
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")	
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Clear Overrides"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[6].enabled = parent.copyBufferItemsType == "override" --solo se pueden pegar overrides
					cmsRmenu.items.item[2].enabled = (trvContainers.selection.count == 1) --solo se puede crear si hay un solo elemento seleccionado					
				)--overrides
				
				#override:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable Override/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Edit"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"					
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Show override warning/error"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove Override/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
				)--override
				
				#lightSet:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable LightSet/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Add Selected Scene Lights"
					append _rMenuItems "Clear Lights"
					append _rMenuItems "Select LightSet/s lights"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Duplicate LightSet/s"
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove LightSet/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[9].enabled = parent.copyBufferItemsType == "light" --solo se pueden pegar luces
				)--lightSet
				
				#light:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable Light/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Select Light/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")					
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove Light/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
				)--lightSet
				
				#ObjectSet:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable ObjectSet/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Add Node Set/s"
					append _rMenuItems "Clear NodeSet/s"
					append _rMenuItems "Select ObjectSet/s objects"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Duplicate ObjectSet/s"
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove ObjectSet/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[9].enabled = parent.copyBufferItemsType == "nodeSet" --solo se pueden pegar nodeSets
				)--ObjectSet

				#nodeSet:
				(
					--rellena el array de items con todas las opciones					
					append _rMenuItems "Enable/Disable NodeSet/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Select NodeSet/s objects"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")					
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove NodeSet/s"					
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
				)--nodeSet	

				#hiddenObjectSet:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable HiddenNodeSets/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Add Node Set/s"
					append _rMenuItems "Add Selected Scene objects"
					append _rMenuItems "Clear objects"
					append _rMenuItems "Select HiddenNodeSets/s objects"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Duplicate HiddenNodeSets/s"
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove HiddenNodeSets/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[10].enabled = parent.copyBufferItemsType == "nodeSet" or parent.copyBufferItemsType == "object"--solo se pueden pegar nodeSets y objects
				)--hiddenObjectSet

				#lodSet:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable LODSet/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Add Node Set/s"
					append _rMenuItems "Add Selected Scene objects"
					append _rMenuItems "Clear objects"
					append _rMenuItems "Select LODSet/s objects"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Duplicate LODSet/s"
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove LODSet/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[10].enabled = parent.copyBufferItemsType == "nodeSet" or parent.copyBufferItemsType == "object"--solo se pueden pegar nodeSets y objects
				)--lodSet

				#flatColorObjectSet:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable FlatColorObjectSet/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Add Node Set/s"
					append _rMenuItems "Clear FlatColorNodeSet/s"
					append _rMenuItems "Add Selected Scene objects"
					append _rMenuItems "Clear Selected Object/s"
					append _rMenuItems "Select FlatColorObject/s objects"
					append _rMenuItems "Clear all"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Duplicate FlatColorObjectSet/s"
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems "Paste"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Rename"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove FlatColorObjectSet/s"

					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
					cmsRmenu.items.item[15].enabled = parent.copyBufferItemsType == "nodeSet" or parent.copyBufferItemsType == "object"--solo se pueden pegar nodeSets y objects
				)--flatColorObjectSet


				#object:
				(
					--rellena el array de items con todas las opciones
					append _rMenuItems "Enable/Disable Object/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Select Object/s"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")					
					append _rMenuItems "Cut"
					append _rMenuItems "Copy"
					append _rMenuItems (dotnetobject "System.Windows.Forms.ToolStripSeparator")
					append _rMenuItems "Remove Object/s"
					
					--añade todos los items al menú
					for i = 1 to _rMenuItems.count do cmsRmenu.items.add _rMenuItems[i]
					
					--Inhabilita las opciones que no puedan ser utilizadas
				)--object
				
			)--case
			
			cmsRmenu.Show pos.x pos.y --muestra el menú
		)
		
		------------------------------------------------
		--@fn: undefined | createRMenu | Rellena el menu de boton derecho en función de la opcion.
		--@gets: point2 | pos | Posición en la que debe dibujarse el menu.
		--@gets: name | menuType | Tipo de menu, que marca cuales serán los elementos internos del menu. Opciones -> #empty, #passTree, #passGroup, #pass, #ObjectSet, #lightSet.
		------------------------------------------------
		fn expandAllTrees =
		(
			--expande todos los nodos de todos los arboles
			for i=1 to trvContainers.nodes.count do trvContainers.nodes.item[i-1].ExpandAll()		
		)
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | updateCameraMode | Pone las partes del UI relacionadas con el modo de camara R o L segun el estado del arbol de pases
		------------------------------------------------
		fn updateCameraMode =
		(	
			_overallState = #Lmode --estado general de todos los arboles
			_cameraOverrides = #() --array para los overrides de camara
			
			--recorre los arboles mirando el modo de camara en el que estan
			for i=1 to parent.containerTrees.count do
			(
				_overridesNodes = (for _ch in parent.containerTrees[i].getChildren() where _ch.getSubType() == #overrides collect _ch)[1] --obtiene el contenedor de overrides
				for _ov in _overridesNodes.getOverrides() where _ov.getSubType() == "camera" do append _cameraOverrides _ov --obtiene los overrides de camara
			)--for
			
			--si hay overrides de camara
			if _cameraOverrides.count != 0 then
			(
				_Rcameras = for _ovCam in _cameraOverrides where _ovCam.customOverride.infoNode.custAttributes[#overrideCameraInfo].useRcamera collect _ovCam
				_Lcameras = for _ovCam in _cameraOverrides where not _ovCam.customOverride.infoNode.custAttributes[#overrideCameraInfo].useRcamera collect _ovCam
				
				if _Rcameras.count != 0 and _Lcameras.count != 0 then _overallState = #error --si hay de los dos tipos está en modo error
				else if _Rcameras.count != 0 then _overallState = #Rmode
				else if _Lcameras.count != 0 then _overallState = #Lmode
			)--if
			
			case _overallState of
			(
				#Lmode:
				(
					ckbLcameraMode.checked = true
					ckbRcameraMode.checked = false
					btnCameraModeBorderU.backColor = cameraLcolor
					btnCameraModeBorderL.backColor = cameraLcolor
					btnCameraModeBorderR.backColor = cameraLcolor
					btnCameraModeBorderB.backColor = cameraLcolor
				)--L mode
				
				#Rmode:
				(
					ckbLcameraMode.checked = false
					ckbRcameraMode.checked = true
					btnCameraModeBorderU.backColor = cameraRcolor
					btnCameraModeBorderL.backColor = cameraRcolor
					btnCameraModeBorderR.backColor = cameraRcolor
					btnCameraModeBorderB.backColor = cameraRcolor
				)--R mode
				
				#error:
				(
					ckbLcameraMode.checked = false
					ckbRcameraMode.checked = false
					btnCameraModeBorderU.backColor = errorColor
					btnCameraModeBorderL.backColor = errorColor
					btnCameraModeBorderR.backColor = errorColor
					btnCameraModeBorderB.backColor = errorColor
				)--error
			)--case
		)
		
		------------------------------------------------
		--@fn: undefined | initInterface | Rellena la información necesaria para trabajar y pinta el interface con esos datos
		------------------------------------------------
		fn initInterface =
		(
			------------------------------------------------
			--boton del color del color de camara R
			_flatStyle = (dotnetClass "System.Windows.Forms.FlatStyle").Flat
			
			btnCameraModeBorderU.FlatStyle = _flatStyle
			btnCameraModeBorderU.FlatAppearance.BorderSize = 0
			
			btnCameraModeBorderL.FlatStyle = _flatStyle
			btnCameraModeBorderL.FlatAppearance.BorderSize = 0			
			
			btnCameraModeBorderR.FlatStyle = _flatStyle
			btnCameraModeBorderR.FlatAppearance.BorderSize = 0
			
			btnCameraModeBorderB.FlatStyle = _flatStyle	
			btnCameraModeBorderB.FlatAppearance.BorderSize = 0
			
			------------------------------------------------
			
			------------------------------------------------
			--arbol de contenedores
			--showProperties trvContainers.Appearance.Row
			
			--establece las propiedades generales de apariencia, colores, fuentes...
			--trvContainers.OptionsView.ShowHorzLines = false
			trvContainers.OptionsView.ShowVertLines = false
			trvContainers.OptionsView.ShowColumns = false
			trvContainers.OptionsView.ShowIndicator = false
			trvContainers.OptionsView.ShowIndentAsRowStyle = true
			
			trvContainers.Appearance.Row.ForeColor = generalForeColor
			trvContainers.Appearance.SelectedRow.BackColor = selectedRowBackColor
			trvContainers.Appearance.SelectedRow.ForeColor = selectedRowForeColor
			trvContainers.Appearance.FocusedRow.BackColor = selectedRowBackColor
			trvContainers.Appearance.FocusedRow.ForeColor = selectedRowForeColor
			trvContainers.Appearance.FocusedCell.BackColor = selectedCellBackColor
			trvContainers.Appearance.FocusedCell.ForeColor = selectedCellForeColor
			trvContainers.Appearance.Empty.BackColor = generalBackColor
			trvContainers.Appearance.Empty.ForeColor = generalForeColor
			trvContainers.Appearance.Row.BackColor = generalBackColor
			trvContainers.Appearance.HorzLine.BackColor = generalGridColor --generalBackColor
			trvContainers.Appearance.VertLine.BackColor = generalBackColor
			trvContainers.Appearance.TreeLine.BackColor = treeLinesColor
			
			trvContainers.borderStyle = (dotnetClass "DevExpress.XtraEditors.Controls.BorderStyles").NoBorder
			
			trvContainers.OptionsBehavior.Editable = false --para que no se puedan editar las celdas
			
			--establece la fuente del treeview
			trvContainers.font = dotnetobject "system.drawing.font" (dotnetobject "System.Drawing.FontFamily" "Arial") 9
			
			--habilita la multiseleccion
			trvContainers.OptionsSelection.MultiSelect = true

			--habilita el drag and drop de elementos
			trvContainers.AllowDrop = true
			trvContainers.OptionsBehavior.DragNodes = true

			--añade imagenes personalizadas para el drag
			trvContainers.Painter.NodeDragImages.Images.Add dragIconArrow
			trvContainers.Painter.NodeDragImages.Images.Add dragIconForbidden

			--crea las columnas del treeview
			_col1 = trvContainers.Columns.Add()
			_col2 = trvContainers.Columns.Add()
			_col3 = trvContainers.Columns.Add() --columna para los subtipos del contenido, para poder hacer comparaciones despues de forma más agil
			_col4 = trvContainers.Columns.Add() --columna para los subSubTipos del contenido, para poder hacer comparaciones despues de forma más agil (por ejemplo overrides y overridesObligatorios)
			_col5 = trvContainers.Columns.Add() --columna para los estados (habilitado/deshabilitado), para poder hacer comparaciones despues de forma más agil
			_col6 = trvContainers.Columns.Add() --columna para los estados (ok/waring/error), para poder hacer comparaciones despues de forma más agil
			_col7 = trvContainers.Columns.Add() --columna para los estados (dark/light), para poder hacer comparaciones despues de forma más agil
			
			_col1.Visible = true
			_col2.Visible = true
			_col3.Visible = false
			_col4.Visible = false
			_col5.Visible = false
			_col6.Visible = false
			_col7.Visible = false
			
			--establece propiedades especiales al contenido de alguna columna
			_col2.AppearanceCell.TextOptions.HAlignment = (dotNetClass "DevExpress.Utils.HorzAlignment").Far --alineacion derecha en la columna 2
			--_col2.AppearanceCell.ForeColor = infoColumnForeColor --selectedRowForeColor --color mas oscuro para el texto de la columna 2
			
			------------------------------------------------
			--lee los iconos específicos de los overrides y los añade a sus arrays
			
			_overrideIconFiles = getFiles ((lb.config.getToolsIconsPath()) + "passManager\\override_*.png")
			containersLevelOrder += (for _ovic in _overrideIconFiles collect ((substituteString (getFileNameFile _ovic) "override_" "") as name)) --añade al orden de overrides en los iconos los overrides
			_overrideIconFiles = for _ovic in _overrideIconFiles collect dotnetObject "System.Drawing.Bitmap" _ovic
			treeIcons += _overrideIconFiles

			_overrideIconOffFiles = getFiles ((lb.config.getToolsIconsPath()) + "passManager\\overrideOff_*.png")
			_overrideIconOffFiles = for _ovic in _overrideIconOffFiles collect dotnetObject "System.Drawing.Bitmap" _ovic
			treeIconsOff += _overrideIconOffFiles

			_overrideIconLightFiles = getFiles ((lb.config.getToolsIconsPath()) + "passManager\\overrideLight_*.png")
			_overrideIconLightFiles = for _ovic in _overrideIconLightFiles collect dotnetObject "System.Drawing.Bitmap" _ovic
			treeIconsLight += _overrideIconLightFiles

			_overrideIconOffLightFiles = getFiles ((lb.config.getToolsIconsPath()) + "passManager\\overrideOffLight_*.png")
			_overrideIconOffLightFiles = for _ovic in _overrideIconOffLightFiles collect dotnetObject "System.Drawing.Bitmap" _ovic
			treeIconsOffLight += _overrideIconOffLightFiles

			
			--crea una coleccion de imagenes para los iconos del arbol
			_imageList = dotnetObject "System.Windows.Forms.ImageList"
			for _icon in treeIcons do _imageList.Images.Add _icon
			for _icon in treeIconsOff do _imageList.Images.Add _icon
			for _icon in treeIconsLight do _imageList.Images.Add _icon
			for _icon in treeIconsOffLight do _imageList.Images.Add _icon
			trvContainers.SelectImageList = _imageList			
			
			--crea una coleccion de imagenes para los iconos de estado del arbol
			_imageList2 = dotnetObject "System.Windows.Forms.ImageList"
			for _icon in stateIcons do _imageList2.Images.Add _icon
			trvContainers.StateImageList = _imageList2
			
			------------------------------------------------
			
			------------------------------------------------
			--menu  principal
			
			--añade el evento al menu			
			msMainMenu.rendermode = (dotnetclass "System.Windows.Forms.ToolStripRenderMode").system
			msMainMenu.BackColor = generalForeColor
			msMainMenu.ForeColor = generalBackColor
			
			createMainMenu() --rellena las opciones del menu
			------------------------------------------------
			
			------------------------------------------------
			--menu de boton derecho
			
			--añade el evento al menu
			dotnet.addEventHandler cmsRmenu "itemClicked" rollMainDef.rMenuItemclickedEvent
			------------------------------------------------
				
			------------------------------------------------
			--cuadro de edicion de nombres de contenedores
			
			--establece las propiedades iniciales del cuadro de edicion de nombres de contenedores
			rtbCaptionEditor.readonly = false
			rtbCaptionEditor.backcolor = (dotNetClass "System.Drawing.Color").white
			rtbCaptionEditor.parent = trvContainers
			dotnet.removeAllEventHandlers rtbCaptionEditor			
			rtbCaptionEditor.hide()
			------------------------------------------------
			
			/* _comboBox = dotnetObject "DevExpress.XtraEditors.Repository.RepositoryItemComboBox"
			_comboBox.Items.AddRange #("aaaa", "bbbb", "cccc")
			_comboBox.Items.AddRange #("dddd", "eeee", "ffff")
			trvContainers.RepositoryItems.Add _comboBox
			_col2.ColumnEdit = _comboBox */
			
		)		
		
		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--almacena posicion
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/pos") "x" (((getDialogPos rollMainDef).x) as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/pos") "y" (((getDialogPos rollMainDef).y) as string)
			
			--almacena tamaño
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/size") "width" (rollMainDef.width as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/size") "height" (rollMainDef.height as string)
			
			--almacena settings
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/settings/mode") "value" (parent.mode as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/settings/saveLogs") "save" (parent.saveLogs as string)

			--almacena visibles
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/view/overrides") "value" (parent.viewOverrides as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/view/lightSets") "value" (parent.viewLightSets as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/view/objectSets") "value" (parent.viewObjectSets as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/view/hiddenObjectSets") "value" (parent.viewHiddenObjectSets as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/view/lodSets") "value" (parent.viewLodSets as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/view/flatColorObjectSets") "value" (parent.viewFlatColorObjectSets as string)
			lb.xml.setAttribute parent.cfgFile ("passManager/rollMain/view/nodeSets") "value" (parent.viewNodeSets as string)
		)
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--aplica visibles
			parent.viewOverrides = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/view/overrides") "value") as booleanClass
			parent.viewLightSets = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/view/lightSets") "value") as booleanClass
			parent.viewObjectSets = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/view/objectSets") "value") as booleanClass
			parent.viewHiddenObjectSets = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/view/hiddenObjectSets") "value") as booleanClass
			parent.viewLodSets = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/view/lodSets") "value") as booleanClass
			parent.viewFlatColorObjectSets = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/view/flatColorObjectSets") "value") as booleanClass
			parent.viewNodeSets = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/view/nodeSets") "value") as booleanClass

			--settings
			parent.mode = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/settings/mode") "value")
			parent.mode = (if parent.mode == "" then #production else (parent.mode as name))
			lblMode.caption = "Mode: " + (if parent.mode == #production then "Production" else if parent.mode == #idi then "I+D+I" else "Unknown")
				
			parent.saveLogs = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/settings/saveLogs") "save") == "true"
			
			--tamaño
			_width = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/size") "width") as integer
			_height = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/size") "height") as integer
				
			--posicion
			_posX = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/pos") "x") as integer
			_posY = (lb.xml.getAttribute parent.cfgFile ("passManager/rollMain/pos") "y") as integer
				
			--establece minimos
			if _width < minRollWidth then _width = minRollWidth
			if _height < minRollHeight then _height = minRollHeight
			if _posX < 0 then _posX = 0
			if _posY < 0 then _posY = 0
				
			--aplica los valores
			rollMainDef.width = _width
			rollMainDef.height = _height
			setDialogPos rollMainDef [_posX,_posY]
		)
		
		fn submitCommandRenderNetwork jobInfoStruct _singlePass _passesList:""=
		(
			_maxFilePathName = maxFilePath + maxFileName
			if (_maxFilePathName != "") then
			(
				--Si el archivo no esta locked te da un aviso y para el proceso.
				_status = lb.svn.svnGetFileStatus _maxFilePathName
				if ((findString "U" _status)==undefined) then
				(
					--En el caso que este configurado el pase principal con el frame output en FRAMES da un aviso para continuar
					--_frameContinueProcess = lb.passManagerUI.timeOutputFramesOptionSelected()
					--if _frameContinueProcess do 
					--(
						--Si en el rollout de envio los parametros de Priority o Pool estan por defecto para el proceso y da mensaje de alerta
						if ( lb.cmdLauncher.rollMain._spn_priority.value != 0 ) and ( lb.cmdLauncher.rollMain._ddl_poollist.selection != 1 ) then 
						(
							--Como el render se realiza en local, deberemos realizar copias del fichero con el estado de la escena despues de hacer el preRender 
							--Por si se para el proceso, se realiza una copia de backup de la escena 
							_maxFilePathNameParts = filterString _maxFilePathName "."
							_maxBackupPathName = _maxFilePathNameParts[1] + "_Backup." + _maxFilePathNameParts[2]
							copyFile _maxFilePathName _maxBackupPathName

							_passTrees = #()
							_passTrees = lb.passManager.getContainerTrees()

							--Local var---
							_caRootOverrideTimeOutput = undefined
							_caRootOverrideOutputPath = undefined
							_caRootOverrideOutputFile = undefined
							_caRootOverrideOutputType = undefined
							_caPGOverrideTimeOutput = undefined
							_caPGOverrideOutputType = undefined
							_caOverrideTimeOutput = undefined
							_caOverrideOutputType = undefined
							--------------

							--A continuacion se recorre los pases buscando la configuracion de frames (timeOutput), salida (OutputPath,outputFile ), y el tipo (outputType) 
							for _passTree in _passTrees do
							(
								for _ch in _passTree.getChildren() where (_ch.getSubType()) == #overrides do
								(	
									_overrides = _ch.getOverrides()

									for _ov in _overrides where ((_ov.getSubtype() == "timeOutput") or  (_ov.getSubtype() == "outputFile") or (_ov.getSubtype() == "outputPath") or (_ov.getSubtype() == "outputType")) and (_ov.getEnabledState()) do
									(
										if (_ov.getSubtype() == "timeOutput")  then
										(
											_caRootOverrideTimeOutput = _ov.customOverride.infoNode.custAttributes["overrideTimeOutputInfo"]
										)
										if (_ov.getSubtype() == "outputPath")  then
										(
											_caRootOverrideOutputPath = _ov.customOverride.infoNode.custAttributes["overrideOutputPathInfo"]
										)
										if (_ov.getSubtype() == "outputFile")  then
										(
											_caRootOverrideOutputFile = _ov.customOverride.infoNode.custAttributes["overrideOutputFileInfo"]
										)
										if (_ov.getSubtype() == "outputType")  then
										(
											_caRootOverrideOutputType = _ov.customOverride.infoNode.custAttributes["overrideOutputTypeInfo"]
										)
									)
								)
								for _passGroup in _passTree.getChildren() where ((_passGroup.getSubType()) == #passGroup) and (_passGroup.getEnabledState()) do
								(
									for _over in _passGroup.getChildren() where ((_over.getSubType()) == #overrides) and (_over.getEnabledState()) do
									(
										_overrides = _over.getOverrides()

										_caPGOverrideTimeOutput = _caRootOverrideTimeOutput
										_caPGOverrideOutputType = _caRootOverrideOutputType

										for _ov in _overrides where (_ov.getEnabledState()) do 
										(
											if (_ov.getSubtype() == "timeOutput") and (_ov.getEnabledState()) then
											(
												_caPGOverrideTimeOutput = _ov.customOverride.infoNode.custAttributes["overrideTimeOutputInfo"]
											)
											if (_ov.getSubtype() == "outputType") and (_ov.getEnabledState()) then
											(
												_caPGOverrideOutputType = _ov.customOverride.infoNode.custAttributes["overrideOutputTypeInfo"]
											)
										)
									)
									for _pass in _passGroup.getChildren() where ((_pass.getSubType()) == #pass) and (_pass.getEnabledState()) do
									(
										for _over in _pass.getChildren() where ((_over.getSubType()) == #overrides) and (_over.getEnabledState()) do
										(
											_overrides = _over.getOverrides()
											
											_caOverrideTimeOutput = _caPGOverrideTimeOutput
											_caOverrideOutputType = _caPGOverrideOutputType	

											for _ov in _overrides where (_ov.getEnabledState()) do 
											(
												if (_ov.getSubtype() == "timeOutput") and (_ov.getEnabledState()) then
												(
													_caOverrideTimeOutput = _ov.customOverride.infoNode.custAttributes["overrideTimeOutputInfo"]
												)
												if (_ov.getSubtype() == "outputType") and (_ov.getEnabledState()) then
												(
													_caOverrideOutputType = _ov.customOverride.infoNode.custAttributes["overrideOutputTypeInfo"]
												)
											)
										)

										if (_pass.getEnabledState()) == true then
										(
											--Si se lanza mendiante el boton de la ui del passmanager Se lanzan todos los pases activos
											if (not _singlePass) then 
											(
												--Hacemos el backup de la escena antes del pase
												_pass.createBackup()
												--Configuramos la escena con el pase actual
												_pass.preRender()
												--Guardamos el fichero original y creamos una copia en la carpeta temporal \\lbdata002\deadline-tempCMD\ con el nombre del fichero + nombre del pase.
												saveMaxFile (maxFilePath + maxFileName)

												_from = maxFilePath + maxFileName
												_parsedName = filterString maxFileName "_"
												_to = "\\\\lbdata002\deadline-tempCMD\\" + _parsedName[1] + "_" + _parsedName[2]+ "_" + _parsedName[3] + "_" +  _parsedName[4]+ "_" + _pass.getCaption()+".max"
												--Controlaremos que si el fichero existe, se borre antes (por si acaso)
												if doesFileExist _to do deleteFile _to
												copyFile _from _to

												--Creamos el fichero de job con la información de lanzamiento usuario, pool, prioridad...  de la array jobInfoStruct, el nombre del fichero es igual al nombre del archivo copia + _jobInfo.job
												_jobsPattern = (filterString _to ".")[1]
												if doesFileExist (_jobsPattern + "_jobInfo.job") do deleteFile (_jobsPattern + "_jobInfo.job")
												lb.render.createTxtRenderFiles _caOverrideTimeOutput _to jobInfoStruct (_pass.getCaption())

												
												--print (_pass.getCaption())
												--print ("Render start: " + (_caOverrideTimeOutput.renderStart as string) + " - Render end: " + (_caOverrideTimeOutput.renderEnd as string))
												--print ("outputFile: "+ _caRootOverrideOutputPath.outputPath + _caRootOverrideOutputFile.outputFile + _caOverrideOutputType.outputType)	

												--preparamos el output path generando correctamente la ruta de las partes compuestas.
												_outputPath = (_caRootOverrideOutputPath.outputPath + _caRootOverrideOutputFile.outputFile + _caOverrideOutputType.outputType)
												_outputPath = substitutestring _outputPath "[pass]" (_pass.getCaption())
												if doesFileExist (_jobsPattern + "_pluginInfo.job") do deleteFile (_jobsPattern + "_pluginInfo.job")
												--Generamos el archivo de plugin con la información de configuración de render de la escena.
												SMTDFunctions.CreateJobInfoFile (_jobsPattern + "_pluginInfo.job") renderOutputOverride:(_outputPath) isPMjob:true 
												--Se genera la string/comando de DOS de lanzamiento. contiene la palabra clave deadline command archivo job archivo plugin fichero render
												_consoleOperation = "deadlinecommand \""+ (_jobsPattern + "_jobInfo.job") + "\" \""+ (_jobsPattern + "_pluginInfo.job") + "\" \"" + (_to) + "\""
												
												--print _consoleOperation
												--lanzamos el render
												hiddenDosCommand _consoleOperation

												--Se borran los archivos temporales generados en lbdata002
												deleteFile (_jobsPattern + "_jobInfo.job")
												deleteFile (_jobsPattern + "_pluginInfo.job")
												deleteFile _to

												--Restauramos el render.
												_pass.postRender()
												_pass.restoreBackup()
											)
											else 
											(
												--Si se lanza por boton derecho del raton sobre el pase o grupo , se renderizan la lista de pases que se envia.
												for _passtoRender in _passesList  do 
												(
													if _pass.getCaption() == _passtoRender.getCaption() do
													(
														_pass.createBackup()
														_pass.preRender()
														saveMaxFile (maxFilePath + maxFileName)

														_from = maxFilePath + maxFileName
														_parsedName = filterString maxFileName "_"
														_to = "\\\\lbdata002\deadline-tempCMD\\" + _parsedName[1] + "_" + _parsedName[2]+ "_" + _parsedName[3] + "_" +  _parsedName[4]+ "_" + _pass.getCaption()+".max"
														
														if doesFileExist _to do deleteFile _to
														copyFile _from _to

														_jobsPattern = (filterString _to ".")[1]
														if doesFileExist (_jobsPattern + "_jobInfo.job") do deleteFile (_jobsPattern + "_jobInfo.job")
														lb.render.createTxtRenderFiles _caOverrideTimeOutput _to jobInfoStruct (_pass.getCaption())

														
														--print (_pass.getCaption())
														--print ("Render start: " + (_caOverrideTimeOutput.renderStart as string) + " - Render end: " + (_caOverrideTimeOutput.renderEnd as string))
														--print ("outputFile: "+ _caRootOverrideOutputPath.outputPath + _caRootOverrideOutputFile.outputFile + _caOverrideOutputType.outputType)	

														_outputPath = (_caRootOverrideOutputPath.outputPath + _caRootOverrideOutputFile.outputFile + _caOverrideOutputType.outputType)
														_outputPath = substitutestring _outputPath "[pass]" (_pass.getCaption())
														if doesFileExist (_jobsPattern + "_pluginInfo.job") do deleteFile (_jobsPattern + "_pluginInfo.job")
														SMTDFunctions.CreateJobInfoFile (_jobsPattern + "_pluginInfo.job") renderOutputOverride:(_outputPath) isPMjob:true 

														_consoleOperation = "deadlinecommand \""+ (_jobsPattern + "_jobInfo.job") + "\" \""+ (_jobsPattern + "_pluginInfo.job") + "\" \"" + (_to) + "\""
														
														--print _consoleOperation

														hiddenDosCommand _consoleOperation

														deleteFile (_jobsPattern + "_jobInfo.job")
														deleteFile (_jobsPattern + "_pluginInfo.job")
														deleteFile _to

														_pass.postRender()
														_pass.restoreBackup()
													)
												)
											)
										)	
									)
								)	
							)
							--volvemos a guardar la escnena principal como estaba al principio.
							saveMaxFile (maxFilePath + maxFileName)
							-- una vez finalizados todos los pases se borra el archivo de backup y se cierra el dialogo de render. 
							deleteFile _maxBackupPathName
							lb.cmdLauncher.close()
						)
						else 
						(
							_errString = "File Cannot be sent with the following configuration: \n"
							if ( lb.cmdLauncher.rollMain._spn_priority.value == 0 ) do _errString+= "--->Priority:0\n" 
							if ( lb.cmdLauncher.rollMain._ddl_poollist.selection == 1 ) do _errString+= "--->pool: none\n" 
							_errString += "change the values"
							lb.message.show _errString
						)
					--)
				)
				else 
				(
					lb.message.show "The file is not locked, cannot proceed to Render"
				)
			)
			else
			(
				lb.message.show "A file has to be open to send to render"
			)
		)

		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--@event | KeyUp | Evento que se lanza al pulsar una tecla sobre el treeview.
		--@control: DevExpress.XtraTreeList.TreeList | trvContainers | Arbol de Contenedores.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		on trvContainers KeyUp events do
		(
			--obtiene los grupos seleccionados
			_trvSel = trvContainers.selection

			_key = events.keydata.tostring() --obtiene la tecla pulsada

			case _key of
			(
				"F2":	parent.menuItemClickedProcess "Rename"

				"E":
				(
					if _trvSel.count == 1 then parent.menuItemClickedProcess "Edit"					
				)--E

				"O":
				(
					if _trvSel.count == 1 then
					(
						_type = _trvSel.item[0].getValue 2
						if _type == "overrides" then parent.menuItemClickedProcess "New Override"
					)--if
				)--O

				"D":
				(
					if _trvSel.count == 1 then
					(
						_type = _trvSel.item[0].getValue 2
						case _type of
						(
							"override": parent.selectedOverridesEnabledStateToggle()
							"ObjectSet": parent.selectedConainersEnabledStateToggle()
							"nodeSet": parent.selectedNodeSetsEnabledStateToggle()
							"light": parent.selectedLightsEnabledStateToggle()
							"object": parent.selectedObjectsEnabledStateToggle()
							"flatColorObjectSet": parent.selectedFlatColorEnabledStateToggle()
							default: parent.selectedConainersEnabledStateToggle() --TO DO, que no desactive hijos
						)--case
					)--if
				)--D

				"Delete":
				(
					_pos = (getDialogPos parent.rollMain) + [(parent.rollMain.width/2 - 150),(parent.rollMain.height/2)]
					if _trvSel.count != 0 and (lb.message.show "Are you sure you want to remove selected items" type:#query pos:_pos) then
					(						
						_type = _trvSel.item[0].getValue 2
						case _type of
						(
							"overrides": parent.clearOverrides()
							"override": parent.removeSelectedOverrides()
							"nodeSet": parent.removeSelectedNodeSets()
							"light": parent.removeSelectedLights()
							"object": parent.removeSelectedObjects()
							default: parent.removeSelectedContainers()
						)--case
					)--if
				)
			)--case
		)
		
		------------------------------------------------
		--@event | MouseUp | Evento que se lanza al cambiar la seleccion del treeview. Se asegura de que no haya elementos de diferente nivel seleccionados al mismo tiempo.
		--@control: DevExpress.XtraTreeList.TreeList | trvContainers | Arbol de Contenedores.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		on trvContainers MouseUp events do
		(
			_button = events.button.ToString() --averigua si es boton izquierdo, derecho o central
			
			--si no se ha hecho click encima de ningun nodo y no se esta pulando Ctrl ni Shift, se deselecciona todo
			_clickedNode = (trvContainers.CalcHitInfo (trvContainers.PointToClient trvContainers.MousePosition)).node
			if _clickedNode == undefined and not keyboard.controlPressed and not keyboard.shiftPressed then trvContainers.Selection.Clear()

			--en función del boton pulsado ha de realizar unas operaciones u otras
			case _button of
			(
				"Left": --boton izquierdo
				(
					forceTrvContainersCorrectSelection()
				)--Left
				
				"Middle": --boton izquierdo
				(
					forceTrvContainersCorrectSelection()
				)--Middle
				
				"Right": --boton derecho
				(
					------------------------------------------------
					--averigua el tipo del nodeo en el que se ha hecho click para mostrar un menu u otro
					
					_currSel = trvContainers.selection --almacena la seleccion actual	
					--_level = -1 --nivel del arbol en el que se han seleccionado nodos
					_type = #empty --para saber a que menu llamar en funcion del tipo de la celda pulsada
					
					_clickedNode = (trvContainers.CalcHitInfo (trvContainers.PointToClient trvContainers.MousePosition)).node
					
					
					if _clickedNode != undefined then
					(
						------------------------------------------------
						--si se ha pulsado un nodo con el boton derecho y este no estaba en la seleccion actual, la seleccion debe cambiar y ser ese nodo
						_found = false
						for i=1 to _currSel.count where not _found and _clickedNode.item[0] == _currSel.item[i-1].item[0] do _found = true
							
						if not _found then --si no lo ha encontrado en la seleccion, hay que sustituir la seleccion
						(
							trvContainers.selection.clear()
							trvContainers.selection.add _clickedNode
						)
						------------------------------------------------
						
						------------------------------------------------
						--almacena el tipo para saber a que menu llamar
						_type = _clickedNode.item[2] as name
						------------------------------------------------
					)--if
					
					--lanza el menu de boton derecho en funcion del tipo de los nodos seleccionados
					createRMenu mouse.screenPos _type
					
					/*FORMA VIEJA
					_currSel = trvContainers.selection --almacena la seleccion actual	
					if _clickedNode != undefined then --si se ha hecho click en un nodo averigua el nivel del nodo
					(
						--si hay nodos seleccionados, comprueba de que nivel son para mostrar un menu u otro
						if _currSel.count != 0 then 
						(
							if _currSel.count == 1 then --si solo hay uno seleccionado comprueba que se ha hecho click en el y no fuera
							(
								if _clickedNode.item[0] == _currSel.item[0].item[0] then _level = _currSel.item[0].level --es el mismo nodo
							)
							else --si hay varios seleccionados averigua el nivel de la seleccion
							(
								_level = _currSel.item[0].level
							)--if
						)--if
					)--if
					
					_type = #empty --para saber a que menu llamar en funcion del tipo de la celda pulsada
					if _level != -1 then
					(
						--encuentra el nodo inicial en toda la jerarquia del arbol
						_firstLevelNode = _clickedNode
						while _firstLevelNode.ParentNode != undefined do _firstLevelNode = _firstLevelNode.ParentNode
						
						_clickedContainerTree = undefined
						for _contTree in parent.containerTrees where _contTree.getCaption() == (_firstLevelNode.getValue 0) do _clickedContainerTree = _contTree
						
						_clickedNodeContainer = (lb.passManager.getbyUiObj _clickedNode containerTree:_clickedContainerTree)[1]
						
						--si los nodos seleccionados son contenedores
						if _clickedNodeContainer != undefined then _type = _clickedNodeContainer.getSubType()
						else
						(
							
						)
					)--if
					
					case _level of
					(
						0: createRMenu mouse.screenPos _type --lanza el menu de boton derecho de arboles de pases
						1: createRMenu mouse.screenPos _type --lanza el menu de boton derecho de grupos de pases
						2: createRMenu mouse.screenPos _type --lanza el menu de boton derecho de pases
						3: createRMenu mouse.screenPos _type --lanza el menu de boton derecho de ObjectSets o lightSets
						
						default:
						(
							if _level == -1 then createRMenu mouse.screenPos _type --lanza el menu de boton derecho de la zona vacia
						)
					)--case*/
					------------------------------------------------
				)--Right
			)--case
		)
		
		------------------------------------------------
		--@event | MouseDoubleClick | Evento que se lanza al hacer doble click en un nodo.
		--@control: DevExpress.XtraTreeList.TreeList | trvContainers | Arbol de Contenedores.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		on trvContainers MouseDoubleClick events do
		(
			_clickedNode = (trvContainers.CalcHitInfo (trvContainers.PointToClient trvContainers.MousePosition)).node
				
			if _clickedNode != undefined then
			(
				_type = _clickedNode.item[2] as name --tipo del nodo en el que se ha hecho doble click
				
				case _type of
				(
					#override:
					(
						--antes de editar deshabilita los controles necesarios para que no se pieda el foco
						parent.setControlsStateOnEdit false

						--edita los overrides
						parent.editSelectedOverrides()
						
						--rehabilita los controles deshabilitados
						parent.setControlsStateOnEdit true
					)--override
				)--case
			)--if
		)
		
		------------------------------------------------
		--@event | DragOver | Evento que se lanza al hacer dragOver.
		--@control: DevExpress.XtraTreeList.TreeList | trvContainers | Arbol de Contenedores.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		/*on trvContainers DragOver event do
		(							
			--print "DragOver"
		)*/

		------------------------------------------------
		--@event | DragOver | Evento que se lanza al soltar el drag.
		--@control: DevExpress.XtraTreeList.TreeList | trvContainers | Arbol de Contenedores.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		on trvContainers DragDrop event do
		(					
			event.Effect = (dotNetClass "System.Windows.Forms.DragDropEffects").None

			_trvSel = trvContainers.selection --obtiene la seleccion actual
			_mode = (if keyboard.altPressed then #copy else #cut) --establece el tipo de drag, copia o corte

			setWaitCursor()
			if lastDropAllowed then (undo off (parent.dropNodes lastDragOverNode _trvSel mode:_mode)) --realiza la operacion de drop
			setArrowCursor()
		)

		------------------------------------------------
		--@event | DragOver | Evento que se lanza al hacer dragOver.
		--@control: DevExpress.XtraTreeList.TreeList | trvContainers | Arbol de Contenedores.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		on trvContainers CalcNodeDragImageIndex event do
		(					
			_node = event.Node --obtiene el nodo donde se ha hecho drag
			_trvSel = trvContainers.selection --obtiene la seleccion actual

			--averigua si el nodo sobre el que se ha hecho drag es un nodo válido para soltar los elementos seleccionados.
			_allowed = parent.isValidDropNode _node _trvSel
	
			event.ImageIndex = if _allowed then 3 else 4

			lastDragOverNode = _node --almacena el nodo de drag para usarlo luego en el drop
			lastDropAllowed = _allowed --almacena si se puede hacer drag o no si se suelta
		)

		------------------------------------------------
		--@event | NodeCellStyle | Evento que se lanza para cambiar el aspecto de una celda.
		--@control: DevExpress.XtraTreeList.TreeList | trvContainers | Arbol de Contenedores.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		/*on trvContainers NodeCellStyle event do
		(							
			if allowRedrawColors then
				updateTrvContainerAppearance mode:#color event:event
			
			--print (isProperty event #Handled)
			--print "------------------"
		)*/		
		
		------------------------------------------------
		--@event | GetSelectImage | Evento que se lanza para cambiar la imagen de una celda.
		--@control: DevExpress.XtraTreeList.TreeList | trvContainers | Arbol de Contenedores.
		--@gets: event | events | Evento de dotnet lanzado.
		------------------------------------------------
		/*on trvContainers GetSelectImage event do
		(
			if allowRedrawIcons then
				updateTrvContainerAppearance mode:#icon event:event
		)*/
		
		------------------------------------------------
		--@event | changed | Evento que se lanza al cambiar de estado el checkbutton.
		--@control: checkbutton | ckbLcameraMode | Checkbutton pulsado.	
		--@gets: boolean | state | Noevo estado del checkbutton.
		------------------------------------------------
		on ckbLcameraMode changed state do
		(
			parent.setRcameraMode false --desactiva el modo de camara R
			updateCameraMode() --actualiza el interface
		)
		
		------------------------------------------------
		--@event | changed | Evento que se lanza al cambiar de estado el checkbutton.
		--@control: checkbutton | ckbRcameraMode | Checkbutton pulsado.	
		--@gets: boolean | state | Noevo estado del checkbutton.
		------------------------------------------------
		on ckbRcameraMode changed state do
		(
			parent.setRcameraMode true --activa el modo de camara R
			updateCameraMode() --actualiza el interface
		)
		
		------------------------------------------------
		--@event | pressed | Evento que se lanza al pulsar el boton de render local.
		--@control: button | btnRenderLocal | Boton de render local.		
		------------------------------------------------
		on btnRenderLocal pressed do
		(
			--realiza los renders
			_success = parent.renderPasses #local useTreeSelection:false showMessageOnError:true saveLogs:(parent.saveLogs)
		)
		
		------------------------------------------------
		--@event | pressed | Evento que se lanza al pulsar el boton de render en red.
		--@control: button | btnRenderNetwork | Boton de render en red.
		------------------------------------------------
		on btnRenderNetwork pressed do
		(
			--llama al procedimiento de render con las opciones de render en red
			_success = parent.renderPasses #network useTreeSelection:false showMessageOnError:true saveLogs:(parent.saveLogs)
		)

		------------------------------------------------
		--@event | pressed | Evento que se lanza al pulsar el boton de render por comandos en red.
		--@control: button | btnRenderNetwork | Boton de render por cmomandos en red. (Faster)
		------------------------------------------------
		on btnCommandRenderNetwork pressed do
		(
			lb.cmdLauncher.run()
		)
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@event: resized | Evento que se lanza al redimensionar el rollout.
		--@control: rollout | rollMain | El elemento que sufre la redimensión. El rollout principal de la herramienta.
		--@gets: point2 | size | tamaño al que se ha redimensionado el rollout
		------------------------------------------------
		on rollMainDef resized size do
		(
			------------------------------------------------------------------------------
			--si la herramienta se redimensiona más pequeña que el mínimo, lo limita al minimo
			if size.x < minRollWidth then (size.x = minRollWidth; rollMainDef.width = size.x)
			if size.y < minRollHeight then (size.y = minRollHeight; rollMainDef.height = size.y)
			------------------------------------------------------------------------------
			
			--calcula el incremento en ancho y alto, respecto al mínimo.
			_increment = [size.x - minRollWidth, size.y - minRollHeight]
			
			------------------------------------------------------------------------------
			--redimension en horizontal
			if _increment.x != 0 then --si hay incremento
			(	
				msMainMenu.width = 400 + _increment.x
				
				btnCameraModeBorderU.width = 400 + _increment.x
				btnCameraModeBorderB.width = 400 + _increment.x
				
				trvContainers.width = 390 + _increment.x
				
				lblSeparator01.pos.x = 125 + _increment.x/3.5
				
				ckbLcameraMode.pos.x = 140 + _increment.x/2.4
				ckbRcameraMode.pos.x = 200 + _increment.x/1.7
				
				lblSeparator02.pos.x = 270 + _increment.x/1.4
				
				lblPreviewPercent.pos.x = 295 + _increment.x
				ddlPreviewPercent.pos.x = 352 + _increment.x
				
				lblRender.pos.x = 6 + _increment.x/2
				btnRenderLocal.pos.x = 50 + _increment.x/2
				btnRenderNetwork.pos.x = 165 + _increment.x/2
				btnCommandRenderNetwork.pos.x = 280 + _increment.x/2

				pbRender.pos.x = 48 + _increment.x/2
				
				btnCameraModeBorderR.pos.x = 395 + _increment.x
			)--if
			------------------------------------------------------------------------------
			
			------------------------------------------------------------------------------
			--redimension en vertical
			if _increment.y != 0 then --si hay incremento
			(
				btnCameraModeBorderL.height = 523 + _increment.y
				btnCameraModeBorderR.height = 523 + _increment.y
				
				trvContainers.height = 515 + _increment.y
				
				lblRender.pos.y = 578 + _increment.y
				btnRenderLocal.pos.y = 575 + _increment.y
				btnRenderNetwork.pos.y = 575 + _increment.y
				btnCommandRenderNetwork.pos.y = 575 + _increment.y

				pbRender.pos.y = 575 + _increment.y
				
				btnCameraModeBorderB.pos.y = 568 + _increment.y
			)--if
			------------------------------------------------------------------------------
		)
		
		------------------------------------------------
		--@event: open | Evento que se lanza al abrir el rollout.
		--@control: rollout | rollMain | El elemento que se abre. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMainDef open do
		(
			--lb.timeStamps.start()

			loadSettings()
			initInterface() --establece las propiedades iniciales del interface
			updateCameraMode() --actualiza el interface en funcion del modo de camara L o R que tenga puesto el arbol
						
			allowRedrawColors = true --permite el redibujado de colores de los nodos
			
			--lb.timeStamps.printTime message:"initInterface"

			trvContainers.BeginUpdate() --hace que no este redibujando el arbol
			
			--lb.timeStamps.printTime message:"BeginUpdate"

			updateTrvContainers() --rellena el arbol y el listado			
			
			--lb.timeStamps.printTime message:"updateTrvContainers"

			trvContainers.EndUpdate() --hace que se pueda redibujar el arbol
			
			--lb.timeStamps.printTime message:"EndUpdate"

			trvContainers.Refresh() --refresca los nodos visibles

			--lb.timeStamps.printTime message:"Refresh"
			
			allowRedrawColors = false --deshabilita el redibujado de colores de los nodos
						
			createSceneEvents() --crea los callbacks

			--lb.timeStamps.printTime message:"createSceneEvents"

			gc()

			--lb.timeStamps.printTime message:"gc"
		)
		
		------------------------------------------------
		--@event: close | Evento que se lanza al cerrar el rollout.
		--@control: rollout | rollMain | El elemento que se cierra. El rollout principal de la herramienta.
		------------------------------------------------
		on rollMainDef close do
		(
			lb.cmdLauncher.close()
			if lb.overridesPathTracker.isOpen() then lb.overridesPathTracker.close()
			removeSceneEvents() --elimina los callbacks
			parent.saveSettings()
			saveSettings()			
			
			parent.opened = false --indica que la herramienta está cerrada.
			updateToolbarButtons()
		)
	)--rollMainDef
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--@struct: passManagerUI | Contiene la herramienta del gestor de pases de render.
	------------------------------------------------------------------------------------------------------------------------------------------------
	struct tl_passManagerUI
	(
		------------------------------------------------------------------------------------------------
		--COMMON
		------------------------------------------------------------------------------------------------
		
		def = (classof this),				--@var: def | Almacena la definicion del struct.
		defFile = getThisScriptFilename(),	--@var: defFile | Almacena la ruta del propio archivo de script que contiene la definicion.
		
		category = #lighting,					--@var: category | Categoria de la tool.
		className = lb.getFileToolName (getThisScriptFilename() as string),	--@var: className | Nombre de la tool.
		description = "Tool de gestion de pases de render",		--@var: description | Descripcion de la tool.
		
		cfgFile = (lb.config.getToolsIniPath()) + (lb.getFileToolName (getThisScriptFilename() as string)) + ".cfg",	--@var: cfgFile | Archivo de configuracion de la tool.
			
		opened = false,			--@var: opened | Indica si la herramienta está abierta.
			
		------------------------------------------------------------------------------------------------
		--VARIABLES
		------------------------------------------------------------------------------------------------
		
		containerTrees = #(),		--@var: containerTrees | Arboles de contenedores con los que se está trabajando.
		
		captionEditing = false,		--@var: captionEditing | Para saber si se esta editando el nombre para mostrar de algun contenedor.
		
		choiceCandidates = #(),	--@var: choiceCandidates | Opciones candidatos elegidos para ser elegidas en el rollChoice.
		
		containerToAddOverride = undefined,	--@var: containerToAddOverride | Contenedor al que añadir un override desde el dialogo especifico para ello.
		--overrideCandidateType = undefined, --@var: overrideCandidateType | Nombre del override a añadir al contenedor candidato.
		overrideCandidateTypes = #(), --@var: overrideCandidateTypes | Tipos de los overrides a añadir al contenedor candidato.

		copyBufferItemsType = undefined, --@var: copyBufferItemsType | Tipo de los objetos almacenados en el buffer de copia.
		copyBuffer = #(), --@var: copyBuffer | Elementos que van a ser copiados.		
		copyMode = false, --@var: copyMode | Indica si la copia es en modo copiar o cortar, por tanto hay que eliminar los originales tras la copia.
		cutTrvSelection = #(), --@var: cutTrvSelection | Almacena la seleccion del arbol cuando se estén cortando elementos.
		cutOverridesParents = #(), --@var: cutOverridesParents | Padres de los overrides copiados para poder deseleccionarlo.

		saveLogs = false, --@var: saveLogs | indica si salvar los logs del proceso.
		mode = #production, --@var: mode | Modo de trabajo. Puede ser #production o #idi.
		netRenderManager = #deadline, --@var: netRenderManager | Manager de render en red elegido.

		viewOverrides = true, --@var:  | Indica si deben visualizarse los overrides
		viewLightSets = true, --@var:  | Indica si deben visualizarse los lightSets
		viewObjectSets = true, --@var:  | Indica si deben visualizarse los objectSets
		viewHiddenObjectSets = true, --@var:  | Indica si deben visualizarse los hiddenObjectSets
		viewLodSets = true, --@var:  | Indica si deben visualizarse los lodsets
		viewFlatColorObjectSets = true, --@var:  | Indica si deben visualizarse los flatColorObjectSets
		viewNodeSets = true, --@var:  | Indica si deben visualizarse los nodeSets
		
		dropTypes = #("passGroup", "pass", "overrides", "override", "ObjectSet", "nodeSet", "lightSet", "light", "flatColorObjectSet"), --@var: dropTypes | Tipos de nodo sobre los que se puede hacer drop.
		dropAllowedTypes = #(#("passGroup", "pass", "overrides"), #("pass", "overrides", "ObjectSet", "lightSet","flatColorObjectSet"), #("overrides", "override"), #("override"), #("ObjectSet", "nodeSet"), #("nodeSet"), #("lightSet", "light"), #("light"), #("flatColorObjectSet")), --@var: dropTypes | Tipos de nodo validos para hacer drop sobre cada uno de los tipos existentes.

		------------------------------------------------------------------------------------------------
		--LIBRARIES
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------------------------------------------------------
		--ROLLOUTS
		------------------------------------------------------------------------------------------------
		
		rollMain = rollMainDef,	--@var: rollMain | Almacena el rollout principal de la herramienta.
		rollMultiChoice = rollMultiChoiceDef, --@var: rollMultiChoice | Almacena el rollout de nodeSets para añadir.
		rollAddOverride = rollAddOverrideDef, --@var: rollAddOverrideDef | Almacena el rollout de overrides para añadir.
		rollRenamePassNode = rollRenamePassNodeDef, --@var: rollAddOverrideDef | Almacena el rollout de renombrado de pases para añadir.
		rollRenamePassGroupNode = rollRenamePassGroupNodeDef, --@var: rollAddOverrideDef | Almacena el rollout de renombrado de grupos de pases para añadir.
		
		------------------------------------------------------------------------------------------------
		--FUNCTIONS
		------------------------------------------------------------------------------------------------
			
		------------------------------------------------
		--GETS
		------------------------------------------------
		
		------------------------------------------------
		--SETS
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | setControlsStateOnEdit | Establece el estado de los controles a la hora de hacer edit de overrides, etc.
		--@gets: boolean | state | Estado deshabilitado o habilitado para los controles.
		------------------------------------------------
		fn setControlsStateOnEdit state =
		(
			this.rollMain.trvContainers.visible = state
			this.rollMain.trvContainers.enabled = state
		),

		------------------------------------------------
		--@fn: undefined | setRcameraMode | Pone la herramienta en modo de trabajo de camara R o L
		--@gets: boolean |state | TRUE si se quiere activar el modo R y FALSE si se quiere activar el modo L
		------------------------------------------------
		fn setRcameraMode state =
		(	
			_cameraOverrides = #() --array para los overrides de camara
			
			--recorre los arboles mirando el modo de camara en el que estan
			for i=1 to this.containerTrees.count do
			(
				_overridesNodes = (for _ch in this.containerTrees[i].getChildren() where _ch.getSubType() == #overrides collect _ch)[1] --obtiene el contenedor de overrides
				for _ov in _overridesNodes.getOverrides() where _ov.getSubType() == "camera" do append _cameraOverrides _ov --obtiene los overrides de camara
			)--for
			
			--si hay overrides de camara
			if _cameraOverrides.count != 0 then
			(
				_RcamerasOv = for _ovCam in _cameraOverrides where _ovCam.customOverride.infoNode.custAttributes[#overrideCameraInfo].useRcamera collect _ovCam
				_LcamerasOv = for _ovCam in _cameraOverrides where not _ovCam.customOverride.infoNode.custAttributes[#overrideCameraInfo].useRcamera collect _ovCam
				
				if state then --activa el modo R
				(	
					------------------------------------------------
					--Obtiene las camaras de la escena, sus nombres, las que son camras L y las camaras R
					
					--patrones de nombres de camaras que cumplen el NC
					_cameraPattern = "cam_???"
					_cameraRpattern = "cam_???-R"
					_cameraRnonNCpattern = "*-R"
					
					--recopila las camaras que cumplen el NC, luego las normales y descarta las camaras R
					_sceneCameras = for _c in cameras where superClassOf _c == camera collect _c
					_sceneCamerasNames = for _c in _sceneCameras collect _c.name
						
					_LsceneCameras = for _c in _sceneCameras where matchPattern _c.name pattern:_cameraPattern collect _c
					_LsceneCameras = lb.misc.sortNodesByName _LsceneCameras --las ordena por nombre
					
					_nonNCcameras = for _c in _sceneCameras where not (matchPattern _c.name pattern:_cameraPattern) and not (matchPattern _c.name pattern:_cameraRnonNCpattern) collect _c
					_LsceneCameras += (lb.misc.sortNodesByName _nonNCcameras) --las ordena por nombre
					
					_RsceneCameras = #() --array para almacenar la camara R de cada camara L
					for i=1 to _LsceneCameras.count do
					(
						_index = findItem _sceneCamerasNames (_LsceneCameras[i].name + "-R")
						_RsceneCameras[i] = if _index != 0 then _sceneCameras[_index] else undefined
					)--for
					------------------------------------------------
					
					--recorre los overrides de camara L y los pasa a R si se puede
					for _ovCam in _LcamerasOv do
					(
						_cam = _ovCam.customOverride.infoNode.custAttributes[#overrideCameraInfo].cameraNode
						_camName = _ovCam.customOverride.infoNode.custAttributes[#overrideCameraInfo].cameraName
						if not isValidNode _cam and _camName != "" then
						(
							_index = findItem _sceneCamerasNames _camName
							if _index != 0 then _cam = _sceneCameras[_index]
						)--if
						
						_Rcam = undefined
						if isValidNode _cam then
						(
							_index = findItem _sceneCamerasNames (_camName + "-R")
							if _index != 0 then _Rcam = _sceneCameras[_index]
						)--if
						
						if isValidNode _Rcam then
						(
							_ovCam.customOverride.infoNode.custAttributes[#overrideCameraInfo].useRcamera = true
							_ovCam.updateUIinfo()
						)--if
					)--for
				)
				else --activa el modo L. Pone todas las camaras en modo L
				(
					for _ovCam in _RcamerasOv do
					(
						_ovCam.customOverride.infoNode.custAttributes[#overrideCameraInfo].useRcamera = false
						_ovCam.updateUIinfo()
					)--for
				)--if else
			)--if
		),
		
		------------------------------------------------
		--OTHER
		------------------------------------------------
		
		------------------------------------------------
		--@fn: undefined | toggleProductionMode | Cambia de modo de trabajo de la herramienta.
		------------------------------------------------
		fn toggleProductionMode =
		(
			case this.mode of
			(
				--si esta en modo i+d+i cambia a modo produccion
				#idi:
				(
					this.mode = #production
				)--idi
				
				--si esta en modo produccion lo que hace es pasar a modo i+d+i
				#production:
				(
					------------------------------------------------
					global _authorized = false --variable global temporal
					
					------------------------------------------------
					--rollout de passwords
					rollout _rollIDIauthorizer "I+D+I Mode Authorizer" width:200
					(
						------------------------------------------------
						--variables
						
						local authCode = "aaae13"
						------------------------------------------------
						
						------------------------------------------------
						--controls
						
						dotNetControl edtPassword "System.Windows.Forms.textbox" pos:[5,5] width:190 height:10
						
						button btnOk "Ok" pos:[5,30] width:95 height:20
						button btnCancel "Cancel" pos:[100,30] width:95 height:20
						------------------------------------------------
						
						------------------------------------------------
						--functions
						
						fn checkPassword =
						(
							_authorized = (edtPassword.text == authCode)
							if not _authorized then
							(
								lb.message.show "Password Incorrect" pos:((getDialogPos _rollIDIauthorizer) - [50,0])
								edtPassword.text = ""
								setFocus edtPassword
							)
							else
								destroyDialog _rollIDIauthorizer
						)
						------------------------------------------------
						
						------------------------------------------------
						--events
						
						on edtPassword KeyUp events do
						(
							key = events.keydata.tostring()
							if key == "Return" then checkPassword()
						)
						
						on btnOk pressed do	checkPassword()
						on btnCancel pressed do
						(
							_authorized = false
							destroyDialog _rollIDIauthorizer
						)
						
						on _rollIDIauthorizer open do
						(
							edtPassword.passwordChar = "•"
							edtPassword.acceptsReturn = true
							setFocus edtPassword
						)
						------------------------------------------------
					)--rollout
					------------------------------------------------				
					
					------------------------------------------------
					--crea el dialogo
					_size = [200, 60]
					_pos = ((getDialogPos this.rollMain) + [this.rollMain.width, this.rollMain.height]/2) - (_size/2)
					createDialog _rollIDIauthorizer lockwidth:true lockheight:true pos:_pos width:_size.x height:_size.y modal:true style:#(#style_toolwindow, #style_titlebar, #style_sysmenu, #style_resizing)
					------------------------------------------------
					
					------------------------------------------------
					--si el password es correcto
					if _authorized then this.mode = #idi
					_authorized = false
					------------------------------------------------
				)--production
			)--case
			
			this.rollMain.lblMode.caption = "Mode: " + (if this.mode == #production then "Production" else if this.mode == #idi then "I+D+I" else "Unknown")
			this.rollMain.createMainMenu()
		),
		
		------------------------------------------------
		--@fn: undefined | refreshVisibility | (Des)Habilita la visibilidad de los nodos de forma recursiva
		------------------------------------------------
		fn refreshVisibility node =
		(
			case node.item[2] of
			(
				"overrides": node.visible = this.viewOverrides
				"lightSet": node.visible = this.viewLightSets
				"ObjectSet": node.visible = this.viewObjectSets
				"hiddenObjectSet": node.visible = this.viewHiddenObjectSets
				"lodSet": node.visible = this.viewLodSets
				"flatColorObjectSet": node.visible = this.viewFlatColorObjectSets
				"nodeSet": node.visible = this.viewNodeSets
			)
			if node.visible do
				for i=1 to node.nodes.count do refreshVisibility node.nodes.item[i-1]
		),

		------------------------------------------------
		--@fn: undefined | toggleViewOption | Indica si mostrar o no el tipo de parametro
		------------------------------------------------
		fn toggleViewOption type =
		(
			case type of
			(
				#overrides: this.viewOverrides = not this.viewOverrides
				#lightSets: this.viewLightSets = not this.viewLightSets
				#ObjectSets: this.viewObjectSets = not this.viewObjectSets
				#hiddenObjectSets: this.viewHiddenObjectSets = not this.viewHiddenObjectSets
				#lodSets: this.viewLodSets = not this.viewLodSets
				#flatColorObjectSets: this.viewFlatColorObjectSets = not this.viewFlatColorObjectSets
				#nodeSets: this.viewNodeSets = not this.viewNodeSets
			)
			for i=1 to this.rollMain.trvContainers.nodes.count do refreshVisibility this.rollMain.trvContainers.nodes.item[i-1]
			this.rollMain.createMainMenu()
		),	
		
		------------------------------------------------
		--@fn: undefined | toggleSaveLogsOption | Indica si salvar logs de proceso o no.
		------------------------------------------------
		fn toggleSaveLogsOption =
		(
			this.saveLogs = not this.saveLogs
			this.rollMain.createMainMenu()
		),	
		
		------------------------------------------------
		--@fn: undefined | fillContainerTrees | Rellena la propiedad containerTrees con los arboles de contenedores de la escena.
		------------------------------------------------
		fn fillContainerTrees =
		(
			this.containerTrees = lb.passManager.getContainerTrees()			
		),
		
		------------------------------------------------
		--@fn: undefined | rtbCaptionEditorChangesApply | Aplica el cambio de nombre a la seleccion.
		------------------------------------------------
		fn rtbCaptionEditorChangesApply =
		(
			--solo si estaba en modo edicion lo aplica
			if this.captionEditing then
			(
				this.captionEditing = false
				
				_process = true
				_newCaption = this.rollMain.rtbCaptionEditor.text --obtiene el nuevo nombre que aplicar
				
				--hay que averiguar si es un nombre válido o no. Se descartan los nombres con espacios y simbolos prohibidos.
				_allowedChars = "1234567890qwertyuiopasdfghjklzxcvbnm-_()"; _allowedChars = for i=1 to _allowedChars.count collect _allowedChars[i]
				for i=1 to _newCaption.count where _process and findItem _allowedChars (tolower _newCaption[i]) == 0 do _process = false
				
				if _process then
				(
					_trvSel = this.rollMain.trvContainers.selection --obtiene los nodos seleccionados

					for i=0 to this.rollMain.trvContainers.selection.count-1 do
					(
						------------------------------------------------
						--hay que obtener el contenedor equivalente al nodo seleccionado					
						--recorre la seleccion de arboles de contenedores en el ui y busca el nodo seleccionado para aplicarle el nuevo nombre
						_selectedElement = undefined
						for _contTree in this.containerTrees where (_selectedElement == undefined) do
						(
							_containers = lb.passManager.getbyUiObj _trvSel.item[i] containerTree:_contTree
							
							if _containers.count != 0 then _selectedElement = _containers[1]
						)--for
						------------------------------------------------
						
						--Si sigue siendo undefined entonces es un override
						if _selectedElement == undefined then
						(
							_parentContainer = undefined
							for _contTree in this.containerTrees where (_parentContainer == undefined) do
							(
								_containers = lb.passManager.getbyUiObj _trvSel.item[i].parentNode containerTree:_contTree
								if _containers.count != 0 then _parentContainer = _containers[1]
							)--for
							
							_index = finditem (_parentContainer.getOverrideNames()) _trvSel.item[i].item[0]
							_selectedElement = (_parentContainer.getOverrides())[_index]
						)
						
						--aplica el nuevo nombre, solo si no es el mismo que tenía antes
						if (_selectedElement.getCaption()) != _newCaption then
						(
							undo "Pass Manager Rename" on (_selectedElement.setCaption _newCaption)
							if _parentContainer == undefined then --Container
								this.rollMain.updateTrvContainers mode:#update specificContainer:_selectedElement
							else --Override
								this.rollMain.updateTrvContainers mode:#update specificContainer:_parentContainer
						)--if
					)
				)--if
				else
				(
					--Los valores de 150 y 37.5 son la mitad del tamaño de la ventana de error para centrarla respecto del passmanager.
					lb.message.show "Bad name, commas, spaces and special characters not allowed.\nList of valid characters: 0-9,a-z,A-Z,-_()" size:[300,75] pos:[((getDialogPos this.rollMain).x + (this.rollMain.width /2))-150,((getDialogPos this.rollMain).y + (this.rollMain.height/2))-37.5]
				)
				
				--oculta el editor  devuelve el foco al arbol
				this.rollMain.rtbCaptionEditor.hide()
				setfocus this.rollMain.trvContainers
			)--if
		),
		
		------------------------------------------------
		--@fn: undefined | rtbCaptionEditorLostFocusEvent | Se ejecuta cuando se pierde el foco del cuadro de edicion de nombres.
		------------------------------------------------
		fn rtbCaptionEditorLostFocusEvent self events =
		(
			this.rtbCaptionEditorchangesApply()
			dotnet.removeAllEventHandlers this.rollmain.rtbCaptionEditor
		),
		
		------------------------------------------------
		--@fn: undefined | rtbCaptionEditorKeyUpEvent | Cada vez que se pulsa una tecla en el cuadro de edicion de nombres.
		------------------------------------------------
		fn rtbCaptionEditorKeyUpEvent self events =
		(
			events.handled = true --para evitar perder el control del foco con teclas especiales como Alt y que lo coja el treeview
			
			key = events.keydata.tostring()

			case key of
			(
				"Return":
				(
					this.rtbCaptionEditorChangesApply()
					dotnet.removeAllEventHandlers this.rollmain.rtbCaptionEditor
				)
				
				"Escape":
				(
					this.captionEditing = false
					this.rollMain.rtbCaptionEditor.hide()
					setfocus this.rollMain.trvContainers
					dotnet.removeAllEventHandlers this.rollmain.rtbCaptionEditor
				)
			)
		),
		
		------------------------------------------------
		--@fn: undefined | rtbCaptionEditorShow | Muestra el cuadro de edicion de nombres de contenedores.
		------------------------------------------------
		fn rtbCaptionEditorShow =
		(
			dotnet.addEventHandler this.rollMain.rtbCaptionEditor "lostFocus" (fn losfFocusEvent self events = (lb.passManagerUI.rtbCaptionEditorLostFocusEvent self events))
			dotnet.addEventHandler this.rollMain.rtbCaptionEditor "keyUp" (fn keyUpEvent self events = (lb.passManagerUI.rtbCaptionEditorKeyUpEvent self events))

			_trvSel = this.rollMain.trvContainers.selection
			selectedNode = _trvSel.item[0]

			------------------------------------------------
			--averigua las propiedades de dibujado de la celda pulsada	
			this.rollMain.trvContainers.ViewInfo.CalcRowsInfo()
			_rectangle = (this.rollMain.trvContainers.ViewInfo.RowsInfo.item (selectedNode)).Bounds
				
			this.rollMain.rtbCaptionEditor.location = dotnetObject "System.Drawing.Point" (_rectangle.x + 16) _rectangle.y
			this.rollMain.rtbCaptionEditor.width = (this.rollMain.trvContainers.width - 16)/2.0
			this.rollMain.rtbCaptionEditor.height = _rectangle.height
			------------------------------------------------

			------------------------------------------------
			--hay que obtener el contenedor equivalente al nodo seleccionado					
			--recorre la seleccion de arboles de contenedores en el ui y busca el nodo seleccionado para aplicarle el nuevo nombre
			_selectedContainer = undefined
			for _contTree in this.containerTrees where (_selectedContainer == undefined) do
			(
				_containers = lb.passManager.getbyUiObj selectedNode containerTree:_contTree
				if _containers.count != 0 then _selectedContainer = _containers[1]
			)--for
			------------------------------------------------
			
			------------------------------------------------
			--solo si es un contenedor se permite renombrar
			--en un futuro igual se permite renombrar overrides (Juan: ese momento ha llegado :P)
			if _selectedContainer != undefined then
			(	
				--abre el cuadro de edicion con el nombre original
				this.rollMain.rtbCaptionEditor.text = _selectedContainer.getCaption()
				
				this.rollMain.rtbCaptionEditor.show()
				this.rollMain.rtbCaptionEditor.selectAll()
				setfocus this.rollMain.trvContainers
				this.rollMain.rtbCaptionEditor.focus()
			)
			else --Si es un override buscamos el contenedor que contiene nuestro override
			(
				case (selectedNode.item[2]) of
				(
					"override":
					(
						_parentContainer = undefined
						for _contTree in this.containerTrees where (_parentContainer == undefined) do
						(
							_containers = lb.passManager.getbyUiObj selectedNode.parentNode containerTree:_contTree
							if _containers.count != 0 then _parentContainer = _containers[1]
						)--for
						
						if _parentContainer != undefined then
						(
							--indice_override_que_necesito = finditem Nombres de overrides, nombre del seleccionado en el árbol
							_overrideIndex = findItem (_parentContainer.getOverrideNames()) selectedNode.item[0]
							_override = (_parentContainer.getOverrides())[_overrideIndex]
							
							this.rollMain.rtbCaptionEditor.text = _override.getCaption()
							this.rollMain.rtbCaptionEditor.show()
							this.rollMain.rtbCaptionEditor.selectAll()
							setfocus this.rollMain.trvContainers
							this.rollMain.rtbCaptionEditor.focus()
						)
						else
						(
							this.captionEditing = true --desactiva la edicion
						)
					)--override

					default: this.captionEditing = true --desactiva la edicion
				)--case
			)--if else
			------------------------------------------------
		),

		------------------------------------------------
		--@fn: undefined | showRenamePassNodeUI | Muestra un diálogo modal para renombrar un pase.
		------------------------------------------------
		fn showRenamePassNodeUI =
		(
			_size = [350, 90]
			_pos = (GetDialogPos this.rollMain) + ([this.rollMain.width, this.rollMain.height]/2) - (_size/2)
			createDialog this.rollRenamePassNode lockwidth:true lockheight:true pos:_pos width:_size.x height:_size.y modal:true style:#(#style_toolwindow, #style_titlebar, #style_sysmenu, #style_resizing)
		),

		------------------------------------------------
		--@fn: undefined | showRenamePassGroupNodeUI | Muestra un diálogo modal para renombrar un grupo pase.
		------------------------------------------------
		fn showRenamePassGroupNodeUI =
		(
			_size = [266, 90]
			_pos = (GetDialogPos this.rollMain) + ([this.rollMain.width, this.rollMain.height]/2) - (_size/2)
			createDialog this.rollRenamePassGroupNode lockwidth:true lockheight:true pos:_pos width:_size.x height:_size.y modal:true style:#(#style_toolwindow, #style_titlebar, #style_sysmenu, #style_resizing)
		),
		
		------------------------------------------------
		--@fn: undefined | renameSelectedContainers | Muestra el cuadro de edicion de nombres los contenedores seleccionados en el arbol.
		------------------------------------------------
		fn renameSelectedContainers =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			if _trvSel.count > 0 do
			(
				_type = _trvSel.item[0].item[2] --obtiene el tipo de contenedor
				
				this.captionEditing = true
				if _type == "pass" and this.mode != #idi then
					this.showRenamePassNodeUI()
				else if _type == "passGroup" and this.mode != #idi then
					this.showRenamePassGroupNodeUI()
				else
					this.rtbCaptionEditorShow()
			)
		),
		
		------------------------------------------------
		--@fn: undefined | newContainer | Crea un nuevo contenedor en el arbol.
		--@gets: string | type | Tipo del container que se solicita. (#pass, #passGroup, #passTree, #ObjectSet, #lightSet)
		------------------------------------------------
		fn newContainer type =
		(
			_undoText = "New Container"
			
			case type of
			(
				#passTree: _undoText = "New Pass Tree"
				#passGroup: _undoText = "New Pass Group"
				#pass: _undoText = "New Pass"
				#objectSet: _undoText = "New ObjectSet"
				#ObjectSet: _undoText = "New ObjectSet"
				#lightSet: _undoText = "New LightSet"
				#hiddenObjectSet: _undoText = "New HiddenObjectSet"
				#lodSet: _undoText = "New LODSet"
				#flatColorObjectSet: _undoText = "New FlatColorObjectSet"
			)

			_nodesToSelect = #() --para almacenar los nodos que deben ser seleccionados despues del redibujado
			case type of
			(
				#passTree:
				(
					undo _undoText on
					(
						_newContainerTree = lb.passManager.newContainer caption:(type as string) subType:type --crea un nuevo arbol de contenedores
						_settingsContainer = lb.passManager.newContainer caption:(lb.time.getCurrentTimeId()) subType:#overrides --crea el nuevo contenedor de tipo settings generales	
					)--undo
					
					_newContainerTree.addChild _settingsContainer --añade el container de settings al nuevo contenedor del tipo solicitado
					_settingsContainer.setCaption "settings" --renombra el contenedor como settings
					_settingsContainer.createRequiredOverrides() --crea los overrides obligatorios del contenedor
					append this.containerTrees _newContainerTree --lo añadae al array de arboles de contenedores					
					this.rollMain.updateTrvContainers specificContainer:_newContainerTree --redibuja el arbol de contenedores
					append _nodesToSelect (_newContainerTree.getUiObj())
				)--passTree
				
				default:
				(				
					--obtiene los arboles seleccionados
					_trvSel = this.rollMain.trvContainers.selection
					
					--recorre la seleccion de arboles de contenedores en el ui y busca su equivalente en los arboles de contenedores para crearles un grupo nuevo
					for i=1 to _trvSel.count do
						for _contTree in this.containerTrees do
						(
							_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
							
							for _cont in _containers do
							(
								undo _undoText on
								(
									_newContainer = lb.passManager.newContainer caption:(lb.time.getCurrentTimeId()) subType:type --crea el nuevo contenedor del tipo solicitado
									
									if type != #overrides and type != #lightSet and type != #hiddenObjectSet then
									(
										_newOverrides = lb.passManager.newContainer caption:(lb.time.getCurrentTimeId()) subType:#overrides --cera un nodo de overrides
										_newContainer.addChild _newOverrides --añade el nodo de overrides al que se acabade crear
										_newOverrides.setCaption "overrides" --renombra el contenedor como overrides
										_newOverrides.createRequiredOverrides() --crea los overrides obligatorios del contenedor
									)--if
								)--undo
								
								(_cont.getUiObj()).Expanded = true --expande el padre antes de añadirle un hijo
								
								_cont.addChild _newContainer
								_newContainer.setCaption (type as string) --renombra el contenedor como su tipo
								this.rollMain.updateTrvContainers specificContainer:_newContainer
								
								--TO DO: AQUI, intentar que actualice el color de los nodos nada mas añadirlos
								--this.rollMain.updateTrvContainerAppearance mode:#color node:(_newContainer.getUiObj())								
								append _nodesToSelect (_newContainer.getUiObj())
							)--if for														
						)--for
				)--deafault
			)--case
			
			--elimina la seleccion , selecciona los nuevos nodos y los despliega
			this.rollMain.trvContainers.selection.clear()
			for _nts in _nodesToSelect do
			(
				_nts.selected = true
				_nts.Expanded = true
			)--for
			
			--abre el cuado de renombrado para que le pongamos un nombre
			if type != #overrides do this.renameSelectedContainers()
		),

		
		------------------------------------------------
		--@fn: undefined | newPassFromPreset | Crea un nuevo contenedor en el arbol.
		--@gets: string | type | Tipo del container que se solicita. (#pass, #passGroup, #passTree, #ObjectSet, #lightSet)
		------------------------------------------------
		fn newPassFromPreset type =
		(
			_undoText = "New Pass from preset"
			
			case type of
			(
				#AO: _undoText = "New AO Pass"
				#Y: _undoText = "New Y Pass"
				#Z: _undoText = "New Z Pass"
				#XYZ: _undoText = "New XYZ Pass"
				#ETS: _undoText = "New ETS Pass"
				#Pupil: _undoText = "New Pupil Pass"
				#UV: _undoText = "New UV Pass"
				#SMV: _undoText = "New SMV Pass"
			)

			_nodesToSelect = #() --para almacenar los nodos que deben ser seleccionados despues del redibujado
				
			--obtiene los arboles seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de arboles de contenedores en el ui y busca su equivalente en los arboles de contenedores para crearles un grupo nuevo
			for i=1 to _trvSel.count do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					for _cont in _containers do
					(
						undo _undoText on
						(
							_newContainer = lb.passManager.newContainer caption:(lb.time.getCurrentTimeId()) subType:#pass --crea el nuevo contenedor del tipo solicitado
							
							_newOverrides = lb.passManager.newContainer caption:(lb.time.getCurrentTimeId()) subType:#overrides --cera un nodo de overrides
							_newContainer.addChild _newOverrides --añade el nodo de overrides al que se acabade crear
							_newOverrides.setCaption "overrides" --renombra el contenedor como overrides
							_newOverrides.createRequiredOverrides() --crea los overrides obligatorios del contenedor
							case (type) of
							(
								#AO:
								(
									_customMatOv = _newOverrides.addOverride "customMaterial"
									_customMatOv.infoNode.custAttributes[#overrideCustomMaterialInfo].customMaterialOverrideType = "Pass AO"
									_customMatOv.infoNode.custAttributes[#overrideCustomMaterialInfo].passAO_aoColor = color 255 255 255
									_environOv = _newOverrides.addOverride "environmentAndEffects"
									_environOv.infoNode.custAttributes[#overrideEnvironmentAndEffectsInfo].overrideEnvironmentCommonProperties = true
									_environOv.infoNode.custAttributes[#overrideEnvironmentAndEffectsInfo].backgroundColor = color 255 255 255
								)
								#Y:
								(
									_customMatOv = _newOverrides.addOverride "customMaterial"
									_customMatOv.infoNode.custAttributes[#overrideCustomMaterialInfo].customMaterialOverrideType = "Pass Y"
									_outputTypeOv = _newOverrides.addOverride "outputType"
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].outputType = ".exr"
									fopenexr.setLayerOutputFormat 0 0

								)
								#Z:
								(
									_customMatOv = _newOverrides.addOverride "customMaterial"
									_customMatOv.infoNode.custAttributes[#overrideCustomMaterialInfo].customMaterialOverrideType = "Pass Z"
									_outputTypeOv = _newOverrides.addOverride "outputType"
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].outputType = ".exr"
									fopenexr.setLayerOutputFormat 0 0							
								)
								#XYZ:
								(
									_customMatOv = _newOverrides.addOverride "customMaterial"
									_customMatOv.infoNode.custAttributes[#overrideCustomMaterialInfo].customMaterialOverrideType = "Pass Mask XYZ"
									_outputTypeOv = _newOverrides.addOverride "outputType"
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].outputType = ".rpf"
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].colorDepth = 32
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].alpha = false
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].premultAlpha = false
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].uvChannel = true

									_rendererSetOv = _newOverrides.addOverride "rendererSettings"
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].currentRenderer = "mental_ray_renderer"
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].overrideMentalSamplingQuality = true
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].MinimumSamples = 0
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].MaximumSamples = 2
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].FrameBufferType = 1
								)
								#ETS:
								(
									_customMatOv = _newOverrides.addOverride "customMaterial"
									_customMatOv.infoNode.custAttributes[#overrideCustomMaterialInfo].customMaterialOverrideType = "Pass ETS"
								)
								#Pupil:
								(
									_customMatOv = _newOverrides.addOverride "customMaterial"
									_customMatOv.infoNode.custAttributes[#overrideCustomMaterialInfo].customMaterialOverrideType = "Pass Pupil"

									_rendererSetOv = _newOverrides.addOverride "rendererSettings"
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].currentRenderer = "mental_ray_renderer"
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].overrideMentalRenderingAlgorithms = true
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].ReflectionsEnable = false
								)
								#UV:
								(
									_outputSizeOv = _newOverrides.addOverride "outputSize"
									_outputSizeOv.infoNode.custAttributes[#overrideOutputSizeInfo].width = 4096
									_outputSizeOv.infoNode.custAttributes[#overrideOutputSizeInfo].height = 1744
									_outputTypeOv = _newOverrides.addOverride "outputType"
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].outputType = ".rpf"
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].colorDepth = 16
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].alpha = true
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].premultAlpha = true
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].uvChannel = true
								)
								#SMV:
								(
									_noOutputOv = _newOverrides.addOverride "noOutput"
									_customMatOv = _newOverrides.addOverride "customMaterial"
									_customMatOv.infoNode.custAttributes[#overrideCustomMaterialInfo].passFC_flatColor = color 0 0 0 
									_rendererSetOv = _newOverrides.addOverride "rendererSettings"
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].currentRenderer = "mental_ray_renderer"
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].overrideMentalSamplingQuality = true
									_rendererSetOv.infoNode.custAttributes[#overrideRendererSettingsInfo].FrameBufferType = 1
									_outputTypeOv = _newOverrides.addOverride "outputType"
									_outputTypeOv.infoNode.custAttributes[#overrideOutputTypeInfo].outputType = ".exr"
									fopenexr.setLayerOutputFormat 0 0
									_renderElemOv = _newOverrides.addOverride "renderElements"

									--Configuraremos la escena para añadir el renderElement.
									_re = MaxOps.GetCurRenderElementMgr ()
									_reCount = 0
									_theSpotMaskVel = undefined
									for i = 0 to _re.numRenderElements() do 
									(
										_temp = _re.getRenderElement i
										if classOf _temp == Spotmask_Velocity then 
										(
											_reCount = _reCount+1
											_theSpotMaskVel = _temp
										)
									)
									if _reCount == 0 then
									(
										_re.addrenderelement (Spotmask_Velocity())
										_theSpotMaskVel = _re.getRenderElement (_re.numRenderElements()-1)
									)
								
									_theSpotMaskVel.enabledOn = false
									_theSpotMaskVel.filterOn = true
									_theSpotMaskVel.elementName = "smv"
									--Fin de la config del renderElement.

									_renderElemOv.infoNode.custAttributes[#overrideRenderElementsInfo].selectedRenderElements = #("smv")

								)
							)
						)--undo
						
						(_cont.getUiObj()).Expanded = true --expande el padre antes de añadirle un hijo
						
						_cont.addChild _newContainer
						--------------------------------------
						-- Intentar generar el nombre correcto
						_suggestedContent = _cont.getCaption()
						_suggestedContent = toLower _suggestedContent
						_suggestedContent = lb.re.match _suggestedContent ".*(bg|fg|all|fx).*"
						if _suggestedContent == false do _suggestedContent = "bg"
						_replaces = dotNetObject "System.Collections.Hashtable"
						_replaces.add "contents" _suggestedContent
						_replaces.add "type" "pass"
						if type == #xyz then
						(
							_replaces.add "subtype" "mask"
							_replaces.add "free" "xyz"
						)
						else
						(
							_replaces.add "subtype" (toUpper (type as string))
							_replaces.add "free" "set"
						)
						_suggested = (lb.re.replaceGroupsInPattern (lb.nc.NC_PMpassRegExp) _replaces)
						--------------------------------------
						if type == #SMV then
						(
							_suggested = substituteString _suggested "-set" "-smv"
						)
						_newContainer.setCaption _suggested --renombra el contenedor
						this.rollMain.updateTrvContainers specificContainer:_newContainer
						
						--TO DO: AQUI, intentar que actualice el color de los nodos nada mas añadirlos
						--this.rollMain.updateTrvContainerAppearance mode:#color node:(_newContainer.getUiObj())								
						append _nodesToSelect (_newContainer.getUiObj())
					)--if for														
				)--for
			
			--elimina la seleccion , selecciona los nuevos nodos y los despliega
			this.rollMain.trvContainers.selection.clear()
			for _nts in _nodesToSelect do
			(
				_nts.selected = true
				_nts.Expanded = true
			)--for
			
			--abre el cuado de renombrado para que le pongamos un nombre
			this.renameSelectedContainers()
		),
		
		------------------------------------------------
		--@fn: undefined | importFromFile | Importa datos de otro fichero
		--@gets: name | type | Tipo del container que se solicita. (#pass, #passGroup, #passTree, #ObjectSet, #lightSet)
		------------------------------------------------
		fn importFromFile type =
		(
			this.rollMain.removeSceneEvents()

			_undoText = "Impoty from file"
			
			case type of
			(
				#passTree: _undoText = "Import Pass Tree from file"
				#passGroup: _undoText = "Import Pass Group from file"
				#pass: _undoText = "Import Pass from file"
				#objectSet: _undoText = "Import ObjectSet from file"
				#ObjectSet: _undoText = "Import ObjectSet from file"
				#lightSet: _undoText = "Import LightSet from file"
				#hiddenObjectSet: _undoText = "Import HiddenObjectSet from file"
				#lodSet: _undoText = "Import LODSet from file"
				#flatColorObjectSet: _undoText = "Import FlatColorObjectSet from file"
			)

			_nodesToSelect = #() --para almacenar los nodos que deben ser seleccionados despues del redibujado
				
			--obtiene los arboles seleccionados
			_trvSel = this.rollMain.trvContainers.selection

			_fileName = getOpenFileName caption:_undoText filename:maxfilepath types:"max file(*.max)|*.max"
			if _fileName != undefined do
			(
				_replaces = dotNetObject "System.Collections.Hashtable"
				_replaces.add "type" (type as string)
				_typeRegExp = lb.re.replaceGroupsInPattern (lb.passManager.infoNodeRegExp) _replaces
				_replaces.add "name" ""
				_beautyRegExp = lb.re.replaceGroupsInPattern (lb.passManager.infoNodeRegExp) _replaces
				_allObjectNames = getMAXFileObjectNames _fileName quiet:true
				_treeNodes = for _name in _allObjectNames where (lb.re.matchObj _name lb.passManager.infoNodeRegExp).success collect _name
				_overNodes = for _name in _allObjectNames where matchPattern _name pattern:(lb.overrides.infoNodePrefix + "*") collect _name
				_choices = for _name in _treeNodes where (lb.re.matchObj _name _typeRegExp).success collect _name
				_beautyChoices = for _name in _choices collect (substituteString _name _beautyRegExp "")
				this.showMultiChoiceUI _beautyChoices
				_selected = for _name in this.choiceCandidates collect _choices[findItem _beautyChoices _name]
				if (_selected.count > 0) do
				(
					--recorre la seleccion de arboles de contenedores en el ui y busca su equivalente en los arboles de contenedores
					for i=_trvSel.count to 1 by -1 do
						for _contTree in this.containerTrees do
						(
							_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
							for _cont in _containers do
							(
								(_cont.getUiObj()).Expanded = true --expande el padre antes de añadirle hijos
								undo _undoText on
								(
									_prevobjCount = objects.count --para obtener los nodos importados
									_importedNodes = #()
									if (mergeMAXFile _fileName (_treeNodes+_overNodes) #autoRenameDups #useSceneMtlDups #neverReparent quiet:true) and objects.count > _prevobjCount do
									(
										_importedNodes = for i=_prevobjCount+1 to objects.count collect (objects[i]) --estos son los nodos importados
										_importedNodesNames = for _impNode in _importedNodes collect _impNode.name
										_importedNodesToKeep = #()
										for _selectedName in _selected do
										(
											_importedIndex = findItem _importedNodesNames _selectedName
											for i=1 to _importedNodes.count where _importedIndex == 0 do if (findString _importedNodesNames[i] _selectedName) != undefined do _importedIndex = i
											_selectedImportedIN = _importedNodes[_importedIndex]
											_selectedImported = undefined
											for _containerTree in lb.passManager.getContainerTrees() where _selectedImported == undefined do
											(
												_selectedImported = lb.passManager.getByInfoNode _selectedImportedIN containerTree:_containerTree
											)
											----intenta traerse nodesets y luces que no están en la escena
											_needToBeImported = #()
											for _lightName in (_selectedImported.getLightNamesRecursive purge:false) where (getNodeByName _lightName exact:true) == undefined do appendIfUnique _needToBeImported _lightName
											for _nodeSetName in (_selectedImported.getNodeSetNamesRecursive()) where (getNodeByName (lb.nodeSets.infoNodePrefix+_nodeSetName) exact:true) == undefined do appendIfUnique _needToBeImported (lb.nodeSets.infoNodePrefix+_nodeSetName)
											if _needToBeImported.count > 0 do
												mergeMAXFile _fileName _needToBeImported #skipDups #useSceneMtlDups #neverReparent quiet:true
											----emparenta
											_selectedImported.setParent _cont
											_importedNodesToKeep += (lb.misc.getNodeAndDescendants _selectedImportedIN)
											--this.rollMain.updateTrvContainers specificContainer:_selectedImported mode:#add
											append _nodesToSelect _selectedImported
										)
										for _in in _importedNodes where (findItem _importedNodesToKeep _in) == 0 do delete _in
									)
								)--undo
								this.rollMain.updateTrvContainers specificContainer:_cont mode:#add useParentToAdd:false
							)--if for
						)
				)
			)

			----elimina la seleccion , selecciona los nuevos nodos y los despliega
			this.rollMain.trvContainers.selection.clear()
			for _nts in _nodesToSelect do
			(
				_ui = _nts.getUiObj()
				_ui.selected = true
				_ui.Expanded = true
			)--for
			this.rollMain.createSceneEvents()
		),
		
		------------------------------------------------
		--@fn: undefined | removeSelectedContainers | Elimina los contenedores seleccionados en el arbol.
		------------------------------------------------
		fn removeSelectedContainers =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para eliminarlos
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_contParent = _cont.getParent()
						
						if _contParent == undefined then --si es un arbol completo de contenedores tiene que además eliminarlo del array de arboles
						(
							_index = findItem this.containerTrees _cont
							if _index != 0 then deleteItem this.containerTrees _index
						)--if
						
						this.rollMain.updateTrvContainers mode:#remove specificContainer:_cont
						undo "Remove Pass Manager Item" on (_cont.remove())
					)--if for					
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | duplicateSelectedContainers | duplica los contenedores seleccionados en el arbol.
		------------------------------------------------
		fn duplicateSelectedContainers =
		(
			setWaitCursor() --cursor de espera
			
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection

			_contToSelect = #() --para almacenar los nodos que deben ser seleccionados despues del redibujado
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para duplicarlos
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_contParent = _cont.getParent() --averigua quien es el padre del contenedor para luego hacer operaciones con este dato
						
						undo "Duplicate Pass Manager Item" on 
						(
							_duplicatedContainer = lb.passManager.duplicateContainer _cont
							append _contToSelect _duplicatedContainer
						)
						
						if _contParent == undefined then --si es un arbol completo de contenedores tiene que añadirlo al array de arboles
						(
							_index = findItem this.containerTrees _cont
							if _index != 0 then append this.containerTrees _duplicatedContainer
						)
						else --si es un contenedor normal, hay que asignarle al duplicado el mismo padre que el original
						(
							_duplicatedContainer.setParent _contParent
						)--if else if
						
						this.rollMain.updateTrvContainers mode:#add specificContainer:_duplicatedContainer
					)--if for					
				)--for

			if _contToSelect.count > 0 do
			(
				type = (_contToSelect[1].getUiObj()).item[2] as name

				--elimina la seleccion , selecciona los nuevos nodos y los despliega
				this.rollMain.trvContainers.selection.clear()
				for _cts in _contToSelect do
				(
					_nts = _cts.getUiObj()
					_nts.selected = true
					_nts.Expanded = true
				)--for
				
				--abre el cuado de renombrado para que le pongamos un nombre si es un pase
				if type == #pass do this.renameSelectedContainers()
			)
				
			setArrowCursor() --cursor de flecha
		),
		
		------------------------------------------------
		--@fn: undefined | showAddNodeSetsUI | Muestra el listado de nodeSets disponibles. Es un dialogo modal, la funcion que llame a esta quedara parada hasta que el dialogo se cierre.
		------------------------------------------------
		fn showMultiChoiceUI options =
		(
			this.choiceCandidates = options
			_size = [200, 300]
			_pos = (GetDialogPos this.rollMain) + ([this.rollMain.width, this.rollMain.height]/2) - (_size/2)
			createDialog this.rollMultiChoice lockwidth:false lockheight:false pos:_pos width:_size.x height:_size.y modal:true style:#(#style_toolwindow, #style_titlebar, #style_sysmenu, #style_resizing)
		),
		
		------------------------------------------------
		--@fn: undefined | showAddNodeSetsUI | Muestra el listado de nodeSets disponibles. Es un dialogo modal, la funcion que llame a esta quedara parada hasta que el dialogo se cierre.
		------------------------------------------------
		fn showAddNodeSetsUI =
		(
			showMultiChoiceUI (for _ns in lb.nodeSets.getAll() collect _ns.getCaption())
		),
		
		------------------------------------------------
		--@fn: undefined | showAddLightsUI | Muestra el listado de luces disponibles. Es un dialogo modal, la funcion que llame a esta quedara parada hasta que el dialogo se cierre.
		------------------------------------------------
		fn showAddLightsUI =
		(
			showMultiChoiceUI (for _light in lb.lights.getSceneLights() collect _light.name)
		),
		
		------------------------------------------------
		--@fn: undefined | addNodeSets | Añade los nodeSets que se elijan a los objectSets seleccionados
		------------------------------------------------
		fn addNodeSets =
		(
			--obtiene la seleccion
			_trvSel = this.rollMain.trvContainers.selection
			
			--solo si hay ObjectSets seleccionados
			if _trvSel.count != 0 then
			(
				this.showAddNodeSetsUI() --muestra el dialogo para elegir nodeSets
				
				--si se han elegido nodeSets los añade
				if this.choiceCandidates.count != 0 then
				(
					--addNodeSetByName
					
					--recorre la seleccion de arboles de contenedores en el ui y busca su equivalente en los arboles de contenedores para crearles los nodeSets
					for i=1 to _trvSel.count do
						for _contTree in this.containerTrees do
						(
							_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
							
							if _containers.count != 0 then for _cont in _containers do
							(								
								(_cont.getUiObj()).Expanded = true --expande el padre antes de añadirle un hijo
								
								for _nsc in this.choiceCandidates do _cont.addNodeSetByName _nsc
								this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
							)--if for			
						)--for
				)--if
			)--if		
		),
		
		------------------------------------------------
		--@fn: undefined | selectSelectedObjectSetsObjects | Selecciona en la escena los objetos de los ObjectSets seleccionados.
		------------------------------------------------
		fn selectSelectedObjectSetsObjects =
		(
			_trvSel = this.rollMain.trvContainers.selection --obtiene la seleccion
			_nodesToSelect = #() --array para almacenar los objetos que hay que seleccionar
			
			--recorre la seleccion de arboles de contenedores en el ui y busca su equivalente en los arboles de contenedores
			for i=1 to _trvSel.count do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_nodeSets = _cont.getNodeSets()
						for j=1 to _nodeSets.count where (_cont.getNodeSetEnabledState j) do _nodesToSelect += _nodeSets[j].getNodes() --obtiene los objetos del nodeSet
					)--if for					
				)--for
			
			clearSelection()
			select _nodesToSelect --realiza la seleccion
		),
		
		------------------------------------------------
		--@fn: undefined | selectSelectedNodeSetsObjects | Selecciona en la escena los objetos de los nodeSets seleccionados.
		------------------------------------------------
		fn selectSelectedNodeSetsObjects =
		(
			_trvSel = this.rollMain.trvContainers.selection --obtiene la seleccion
			_nodesToSelect = #() --array para almacenar los objetos que hay que seleccionar
			
			--obtiene todos los objetos de los nodeSets seleccionados
			for i=1 to _trvSel.count do
			(
				_nodeSets = lb.nodeSets.getByCaption (_trvSel.item[i-1].item[0])
				for _ns in _nodeSets do _nodesToSelect += _ns.getNodes()
			)--for
			
			clearSelection()
			select _nodesToSelect --realiza la seleccion
		),
	
		------------------------------------------------
		--@fn: undefined | clearSelectedObjectSetsNodeSets | Elimina los nodeSets de los ObjectSets seleccionados en el arbol.
		------------------------------------------------
		fn clearSelectedObjectSetsNodeSets =
		(
			_trvSel = this.rollMain.trvContainers.selection --obtiene la seleccion
				
			--recorre la seleccion de arboles de contenedores en el ui y busca su equivalente en los arboles de contenedores
			for i=1 to _trvSel.count do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_cont.removeNodeSets() --elimina sus nodeSets
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
					)
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | removeSelectedNodeSets | Elimina los nodeSets seleccionados en el arbol.
		------------------------------------------------
		fn removeSelectedNodeSets =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--variables para almacenar los contenedores y los bloques de nodeSets a eliminar
			_parentContainersUi = #()
			_nodeSetsToDelete = #()
			
			--variables temporales para crear los bloques de nodeSets a eliminar y 
			_currentNodeSetNames = #()
			_currentParentUi = undefined
			
			--recorre la seleccion y hace eliminaciones de nodeSets por bloques, en funcion del contenedor padre de cada mpdp seleccionado
			for i=1 to _trvSel.count do
			(
				--obtiene el objeto de UI e l contendor padre del nodeSet
				_containerUiNode = _trvSel.item[i-1].ParentNode
				
				--si el padre no es el mismo, hay que empezar una nueva recoleccion para eliminar y justo antes hay que eliminar el bloque anterior de nodeSets
				if (_containerUiNode != _currentParentUi) then
				(
					--almacena los contenedores y los nodeSets en un bloque nuevo definitivo para eliminarlo tras el for
					append _parentContainersUi _currentParentUi
					append _nodeSetsToDelete _currentNodeSetNames
					
					--cambia de bloque
					_currentParentUi = _containerUiNode
					_currentNodeSetNames = #((_trvSel.item[i-1].item[0]))
				)
				else
				(
					append _currentNodeSetNames (_trvSel.item[i-1].item[0]) --sigue apilando nodeSets
				)--if else
				
				--si es el ultimo nodo en el recorrido de la selecicon, apila el ultimo bloque
				if i==_trvSel.count then
				(
					append _parentContainersUi _currentParentUi
					append _nodeSetsToDelete _currentNodeSetNames
				)--if
			)--for
			
			--recorre los contenedores de los que eliminar nodeSets
			for i=1 to _parentContainersUi.count do
			(
				--recorre los arboles de contenedores buscando el contenedor que tenga el uiObj del parametro
				for _contTree in this.containerTrees do
				( 
					_containers = lb.passManager.getbyUiObj _parentContainersUi[i] containerTree:_contTree
						
					if _containers.count != 0 then for _cont in _containers do
					(					
						for _nsn in _nodeSetsToDelete[i] do _cont.removeNodeSetByName _nsn
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
					)--if for
				)--for
			)--for
		),
		
		------------------------------------------------
		--@fn: undefined | selectedConainersEnabledStateToggle | Cambia el estado (habilitado/deshabilitado) de los contenedores seleccionados.
		------------------------------------------------
		fn selectedConainersEnabledStateToggle =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para cambiarles el estado
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_type = _trvSel.item[i-1].item[2] --obtiene el tipo de contenedor
						
						--en funcion del tipo de contenedor la operacion tiene mas o menos pasos
						case _type of
						(
							"passTree":
							(
								--si es un arbol de pases y se quiere desactivar, hay que desactivar los subgrupos y subpases
								
								_state = (_trvSel.item[i-1].item[4] == "on") --obtiene el estado actual
								
								_trvSel.item[i-1].setValue 4 (if _state then "off" else "on")
								_cont.setEnabledState (not _state)
								this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
								this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
									
								--subgrupos
								_groups = for _ch in _cont.getChildren() where (_ch.getSubType() == #passGroup) collect _ch --recolecta los grupos hijos del arbol de pases
								for _group in _groups do
								(
									(_group.getUiObj()).setValue 4 (if _state then "off" else "on")
									_group.setEnabledState (not _state)
									this.rollMain.updateTrvContainerAppearance mode:#icon node:(_group.getUiObj())
									this.rollMain.updateTrvContainerAppearance mode:#state node:(_group.getUiObj())
										
									_passes = for _ch in _group.getChildren() where (_ch.getSubType() == #pass) collect _ch --recolecta los pases hijos del grupo
									for _pass in _passes do
									(
										(_pass.getUiObj()).setValue 4 (if _state then "off" else "on")
										_pass.setEnabledState (not _state)
										this.rollMain.updateTrvContainerAppearance mode:#icon node:(_pass.getUiObj())
										this.rollMain.updateTrvContainerAppearance mode:#state node:(_pass.getUiObj())
									)--for	
								)--for									
							)--passTree
							
							"passGroup":
							(
								--si es un grupo y se quiere desactivar, debe desactivar tambien sus subpases
								
								_state = (_trvSel.item[i-1].item[4] == "on") --obtiene el estado actual
								
								_trvSel.item[i-1].setValue 4 (if _state then "off" else "on")
								_cont.setEnabledState (not _state)
								this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
								this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
									
								-- pases
								_passes = for _ch in _cont.getChildren() where (_ch.getSubType() == #pass) collect _ch --recolecta los pases hijos del grupo
								for _pass in _passes do
								(
									(_pass.getUiObj()).setValue 4 (if _state then "off" else "on")
									_pass.setEnabledState (not _state)
									this.rollMain.updateTrvContainerAppearance mode:#icon node:(_pass.getUiObj())
									this.rollMain.updateTrvContainerAppearance mode:#state node:(_pass.getUiObj())
								)--for
							)--passGroup
							
							"pass":
							(
								--si es un pase simplemente debe cambiar su estado
								
								_state = _trvSel.item[i-1].item[4] --obtiene el estado actual
								
								_trvSel.item[i-1].setValue 4 (if _state == "on" then "off" else "on")
								_cont.setEnabledState (not (_state == "on"))
								this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
								this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
							)--pass
							
							default:
							(
								--si es cualquier otro tipo de contenedor solo debe cambiar su estado
								
								_state = _trvSel.item[i-1].item[4] --obtiene el estado actual
								
								_trvSel.item[i-1].setValue 4 (if _state == "on" then "off" else "on")
								_cont.setEnabledState (not (_state == "on"))
								this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
								this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
							)
							
						)--case
					)--if for					
				)--for
		),

		------------------------------------------------
		--@fn: undefined | selectedFlatColorEnabledStateToggle | Cambia el estado (habilitado/deshabilitado) de los FlatColorObjectSets
		------------------------------------------------
		fn selectedFlatColorEnabledStateToggle =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para cambiarles el estado
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_type = _trvSel.item[i-1].item[2] --obtiene el tipo de contenedor
						
						--en funcion del tipo de contenedor la operacion tiene mas o menos pasos
						case _type of
						(
							"flatColorObjectSet":
							(
								_state = (_trvSel.item[i-1].item[4] == "on") --obtiene el estado actual
								
								_trvSel.item[i-1].setValue 4 (if _state then "off" else "on")
								_cont.setEnabledState (not _state)
								this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
								this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
									
								
								_overrides = for _ch in _cont.getChildren() where (_ch.getSubType() == #overrides) collect _ch --recolecta los pases hijos del grupo
								for _override in _overrides do
								(
									(_override.getUiObj()).setValue 4 (if _state then "off" else "on")
									_override.setEnabledState (not _state)
									this.rollMain.updateTrvContainerAppearance mode:#icon node:(_override.getUiObj())
									this.rollMain.updateTrvContainerAppearance mode:#state node:(_override.getUiObj())
								)--for
							)
							default:
							(
								--si es cualquier otro tipo de contenedor solo debe cambiar su estado
								
								_state = _trvSel.item[i-1].item[4] --obtiene el estado actual
								
								_trvSel.item[i-1].setValue 4 (if _state == "on" then "off" else "on")
								_cont.setEnabledState (not (_state == "on"))
								this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
								this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
							)
							
						)--case
					)--if for					
				)--for
		),

		------------------------------------------------
		--@fn: undefined | selectedNodeSetsEnabledStateToggle | Cambia el estado (habilitado/deshabilitado) de los nodeSets seleccionados.
		------------------------------------------------
		fn selectedNodeSetsEnabledStateToggle =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para cambiarles el estado a sus nodeSets seleccionados
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_nodeSetNames = _cont.getNodeSetNames() --obtiene los nombres de los nodeSets del contenedor
						_nodeSetName = _trvSel.item[i-1].item[0] --obtiene el nombre del nodeSet actual
						_index = findItem _nodeSetNames _nodeSetName
						
						if _index != 0 then --si el nodeSet esta presente en el contenedor
						(
							_state = _cont.getNodeSetEnabledState _index --
							
							_trvSel.item[i-1].setValue 4 (if _state then "off" else "on")
							_cont.setNodeSetEnabledState _index (not _state)
							this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
							this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
						)--if
					)--if
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | showAddOverrideUI | Muestra el listado de overrides permitidos. Es un dialogo modal, la funcion que llame a esta quedara parada hasta que el dialogo se cierre.
		------------------------------------------------
		fn showAddOverrideUI =
		(
			_size = [260, 300]
			_pos = (GetDialogPos this.rollMain) + ([this.rollMain.width, this.rollMain.height]/2) - (_size/2)
			createDialog this.rollAddOverride lockwidth:true lockheight:true pos:_pos width:_size.x height:_size.y modal:true style:#(#style_toolwindow, #style_titlebar, #style_sysmenu, #style_resizing)
		),
		
		------------------------------------------------
		--@fn: undefined | addOverride | Añade un override del tipo que se elija en el listado, al contenedor actual..
		------------------------------------------------
		fn addOverride =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			_containersToAddOverride = #() --array para almacenar los contenedores donde añadir el override
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para añadirle un override a los seleccionados
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
					_containersToAddOverride += lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
				
			--recorre los contenedores recopilados y muestra el dialogo de eleccion de overrides disponibles
			for _cont in _containersToAddOverride do
			(
				this.containerToAddOverride = _cont --almacena el contenedor al que se quiere añadir un override para que el dialogo de eleccion pueda operar con el
				--this.overrideCandidateType = undefined --vacia el nombre de la ejecucion anterior
				this.overrideCandidateTypes = #() --vacía los tipos de la ejecucion anterior

				this.showAddOverrideUI() --muestra el dialogo para elegir overrides
				
				--si se ha elegido un tipo de override que añadir lo intenta
				/*if this.overrideCandidateType!= undefined then
				(
					_cont.addOverride (this.overrideCandidateType) --añade un override nuevo del tipo solicitado al contenedor
					
					this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
				)--if*/

				--si se han elegido tipos de overrides que añadir
				if this.overrideCandidateTypes.count != 0 then
				(
					for _ovType in this.overrideCandidateTypes do _cont.addOverride _ovType --añade un override nuevo del tipo solicitado al contenedor
					this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
				)--if

				----------------------------------------------------------------
				--Refrescamos el estado de los padres
				_parentContainer = _cont
				while _parentContainer != undefined do
				(_parentContainer
					_uiObj = _parentContainer.getUiObj()
					_uiObj.setValue 5 (_parentContainer.getState() as string)
					this.rollMain.updateTrvContainerAppearance mode:#state node:(_uiObj)
					_parentContainer = _parentContainer.parent
				)
				----------------------------------------------------------------
				
				this.containerToAddOverride = undefined --vacia el contenedor de la ejecucion actual para np dejar residuo
				--this.overrideCandidateType = undefined --vacia el nombre de la ejecucion actual para no dejar residuo
				this.overrideCandidateTypes = #() --vacía los tipos de la ejecucion actual para no dejar residuos
			)--for				
		),

		------------------------------------------------
		--@fn: undefined | clearOverrides | Elimina los overrides de un contenedor de overrides.
		------------------------------------------------
		fn clearOverrides excludeRequired:true =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para duplicarlos
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					for _cont in _containers do
					(
						_requiredOverrides = _cont.getRequiredOverrideTypes()
						_overrides = _cont.getOverrides()

						for j=_overrides.count to 1 by -1 where ((findItem _requiredOverrides (_overrides[j].getSubType())) == 0 or not excludeRequired) do
						(
							_cont.removeOverrideByName (_overrides[j].getCaption())
						)--for

						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont

						----------------------------------------------------------------
						--Refrescamos el estado de los padres
						_parentContainer = _cont
						while _parentContainer != undefined do
						(_parentContainer
							_uiObj = _parentContainer.getUiObj()
							_uiObj.setValue 5 (_parentContainer.getState() as string)
							this.rollMain.updateTrvContainerAppearance mode:#state node:(_uiObj)
							_parentContainer = _parentContainer.parent
						)
						----------------------------------------------------------------
					)--if
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | selectedOverridesEnabledStateToggle | Cambia el estado (habilitado/deshabilitado) de los overrides seleccionados.
		------------------------------------------------
		fn selectedOverridesEnabledStateToggle =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para cambiarles el estado a sus overrides seleccionados
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_overrideNames = _cont.getOverrideNames() --obtiene los nombres de los overrides del contenedor
						_overrideName = _trvSel.item[i-1].item[0] --obtiene el nombre del override actual
						_index = findItem _overrideNames _overrideName
						
						if _index != 0 then --si el override esta presente en el contenedor
						(
							_state = ((_cont.getOverrides())[_index]).getEnabledState() --obtiene el estado del override
								
							_trvSel.item[i-1].setValue 4 (if _state then "off" else "on")
							((_cont.getOverrides())[_index]).setEnabledState (not _state)
							this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
							this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
						)--if
					)--if
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | removeSelectedOverrides | Elimina los overrides seleccionados en el arbol.
		------------------------------------------------
		fn removeSelectedOverrides =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--variables para almacenar los contenedores y los bloques de overrides a eliminar
			_parentContainersUi = #()
			_overridesToDelete = #()
			
			--variables temporales para crear los bloques de overrides a eliminar
			_currentOverrideNames = #()
			_currentParentUi = undefined
			
			--recorre la seleccion y hace eliminaciones de overrides por bloques, en funcion del contenedor padre de cada nodo seleccionado
			for i=1 to _trvSel.count do
			(
				--obtiene el objeto de UI e l contendor padre del override
				_containerUiNode = _trvSel.item[i-1].ParentNode
				
				_isRequired = (_trvSel.item[i-1].getValue 3) == "required" --averigua si es un override obligatorio, en cuyo caso no se puede eliminar
				
				--si el padre no es el mismo, hay que empezar una nueva recoleccion para eliminar y justo antes hay que eliminar el bloque anterior de overrides
				if (_containerUiNode != _currentParentUi) then
				(
					--almacena los contenedores y los overrides en un bloque nuevo definitivo para eliminarlo tras el for
					append _parentContainersUi _currentParentUi
					append _overridesToDelete _currentOverrideNames
					
					--cambia de bloque
					_currentParentUi = _containerUiNode
					_currentOverrideNames = if not _isRequired then #((_trvSel.item[i-1].item[0])) else #()
				)
				else
				(
					if not _isRequired then (append _currentOverrideNames (_trvSel.item[i-1].item[0])) --sigue apilando overrides
				)--if else
				
				--si es el ultimo nodo en el recorrido de la selecicon, apila el ultimo bloque
				if i==_trvSel.count then
				(
					append _parentContainersUi _currentParentUi
					append _overridesToDelete _currentOverrideNames
				)--if
			)--for
			
			--recorre los contenedores de los que eliminar overrides
			for i=1 to _parentContainersUi.count do
			(
				--recorre los arboles de contenedores buscando el contenedor que tenga el uiObj del parametro
				for _contTree in this.containerTrees do
				( 
					_containers = lb.passManager.getbyUiObj _parentContainersUi[i] containerTree:_contTree
						
					for _cont in _containers do
					(					
						for _ovn in _overridesToDelete[i] do _cont.removeOverrideByName _ovn
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont

						----------------------------------------------------------------
						--Refrescamos el estado de los padres
						_parentContainer = _cont
						while _parentContainer != undefined do
						(_parentContainer
							_uiObj = _parentContainer.getUiObj()
							_uiObj.setValue 5 (_parentContainer.getState() as string)
							this.rollMain.updateTrvContainerAppearance mode:#state node:(_uiObj)
							_parentContainer = _parentContainer.parent
						)
						----------------------------------------------------------------
					)--if for
				)--for
			)--for
		),

		------------------------------------------------
		--@fn: undefined | editSelectedOverride | edita el override seleccionado.
		------------------------------------------------
		fn editSelectedOverrides =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para editar sus overrides seleccionados
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_overrideNames = _cont.getOverrideNames() --obtiene los nombres de los overrides del contenedor
						_overrideName = _trvSel.item[i-1].item[0] --obtiene el nombre del override actual
						_index = findItem _overrideNames _overrideName
						
						if _index != 0 then --si el override esta presente en el contenedor
						(
							_pos = (GetDialogPos this.rollMain) + ([this.rollMain.width, this.rollMain.height]/2)
							
							_override = (_cont.getOverrides())[_index]								
							_override.edit pos:_pos --modal:true --no se indica si debe ser modal o no, esto lo debe saber cada override
							
							--NO SE PUEDE HACER LA ACTUALIZACION DESDE AQUI, YA QUE SI EL OVERRIDE NO ES MODAL SE ACTUALIZARIA ANTES DE SU EDICION
							--this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
						)--if
					)--if
				)--for			
		),
		
		------------------------------------------------
		--@fn: undefined | showOverrideStateMessage | Muestra en la ventana de logs los errores y warnings de los overrides seleccionados.
		------------------------------------------------
		fn showOverrideStateMessage =
		(
			_logStore = false --flag para saber si se han almacenado logs
			
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection				
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para editar sus overrides seleccionados
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_overrideNames = _cont.getOverrideNames() --obtiene los nombres de los overrides del contenedor
						_overrideName = _trvSel.item[i-1].item[0] --obtiene el nombre del override actual
						_index = findItem _overrideNames _overrideName
						
						if _index != 0 then --si el override esta presente en el contenedor
						(
							_override = (_cont.getOverrides())[_index]
								
							_state = _override.getState()
							_message = _override.getStateMessage()
								
							if _state != #ok then
							(
								if not lb.logManager.isOpen() then lb.logManager.run sender:#all type:#all time:#current
								if not _logStore then
								(
									lb.logManager.clear()
									lb.log.rollback()
									lb.log.beginTransaction()
									_logStore = true
								)--if
								
								case _state of
								(
									#warning: lb.log.add _message sender:"lb.passManagerUI.showOverrideStateMessage" type:#warning
									#error: lb.log.add _message sender:"lb.passManagerUI.showOverrideStateMessage" type:#error
								)--case
							)--if
						)--if
					)--if
				)--for
				
			if _logStore then (if not (lb.log.commit()) then lb.log.rollback())
		),
		
		------------------------------------------------
		--@fn: undefined | addSelectedLights | Añade las luces seleccionadas en la escena a los lightSets seleccionados.
		------------------------------------------------
		fn addSelectedLights =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			_currSel = getCurrentSelection()
			_selLights = for _o in _currSel where superClassOf _o == light collect _o
				
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para añadirles las luces
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						for _li in _selLights do _cont.addLight _li --añade las luces
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
					)--if
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | clearSelectedLightSetsLights | Vacia el arrayde luces de los contenedores seleccionados.
		------------------------------------------------
		fn clearSelectedLightSetsLights =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			_currSel = getCurrentSelection()
			_selLights = for _o in _currSel where superClassOf _o == light collect _o
				
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para eliminarles las luces
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_cont.removeLights()
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
					)--if
				)--for
		),

		------------------------------------------------
		--@fn: undefined | selectSelectedLightSetsLights | Selecciona en la escena las luces de los Lightsets seleccionados.
		------------------------------------------------
		fn selectSelectedLightSetsLights =
		(
			_trvSel = this.rollMain.trvContainers.selection --obtiene la seleccion
			_lightsToSelect = #() --array para almacenar los objetos que hay que seleccionar
			
			--recorre la seleccion de arboles de contenedores en el ui y busca su equivalente en los arboles de contenedores
			for i=1 to _trvSel.count do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_lightsToSelect += _cont.getLightNodes()
					)--if for					
				)--for
			
			clearSelection()
			select _lightsToSelect --realiza la seleccion
		),
		
		------------------------------------------------
		--@fn: undefined | selectSelectedLights | Selecciona en la escena las luces seleccionadas.
		------------------------------------------------
		fn selectSelectedLights =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			_lightsToSelect = #() --array para almacenar los objetos que hay que seleccionar
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para obtener sus luces seleccionadas
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_lightNames = _cont.getLightNames() --obtiene los nombres de las luces del contenedor
						_lightName = _trvSel.item[i-1].item[0] --obtiene el nombre de la luz actual
						_index = findItem _lightNames _lightName
						
						if _index != 0 then --si la luz esta presente en el contenedor
						(
							_lightsObjs = _cont.getLightNodes()
							append _lightsToSelect _lightsObjs[_index]
						)--if
					)--if
				)--for
			
			clearSelection()
			select _lightsToSelect --realiza la seleccion
		),
		
		------------------------------------------------
		--@fn: undefined | selectedLightsEnabledStateToggle | Cambia el estado (habilitado/deshabilitado) de las luces seleccionadas.
		------------------------------------------------
		fn selectedLightsEnabledStateToggle =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para cambiarles el estado a sus luces seleccionadas
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_lightNames = _cont.getLightNames() --obtiene los nombres de las luces del contenedor
						_lightName = _trvSel.item[i-1].item[0] --obtiene el nombre de la luz actual
						_index = findItem _lightNames _lightName
						
						if _index != 0 then --si la luz esta presente en el contenedor
						(
							_state = _cont.getLightEnabledState _index
								
							_trvSel.item[i-1].setValue 4 (if _state then "off" else "on")
							_cont.setLightEnabledState _index (not _state)
							this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
							this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
						)--if
					)--if
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | removeSelectedLights | Elimina las luces seleccionadas en el arbol.
		------------------------------------------------
		fn removeSelectedLights =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--variables para almacenar los contenedores y los bloques de luces a eliminar
			_parentContainersUi = #()
			_lightsIndexToDelete = #()
			
			--variables temporales para crear los bloques de luces a eliminar
			_currentLightIndexes = #()
			_currentParentUi = undefined
			
			--recorre la seleccion y hace eliminaciones de luces por bloques, en funcion del contenedor padre de cada nodo seleccionado
			for i=1 to _trvSel.count do
			(
				--obtiene el objeto de UI del contenedor padre del nodeSet
				_containerUiNode = _trvSel.item[i-1].ParentNode
				
				--obtiene el indice de la luz seleccionada dentro del contenedor
				_currentLightIndex = 0
				_stop = false
				for j=1 to _containerUiNode.nodes.count where not _stop and _containerUiNode.nodes.item[j-1].item[2] == "light" do
				(
					_currentLightIndex += 1
					if _containerUiNode.nodes.item[j-1] == (_trvSel.item[i-1]) then _stop = true						
				)--for
				if not _stop then _currentLightIndex = 0
				
				--si el padre no es el mismo, hay que empezar una nueva recoleccion para eliminar y justo antes hay que eliminar el bloque anterior de luces
				if (_containerUiNode != _currentParentUi) then
				(
					--almacena los contenedores y las luces en un bloque nuevo definitivo para eliminarlo tras la iteracion
					append _parentContainersUi _currentParentUi
					append _lightsIndexToDelete _currentLightIndexes
					
					--cambia de bloque
					_currentParentUi = _containerUiNode
					_currentLightIndexes = #(_currentLightIndex)
				)
				else
				(
					append _currentLightIndexes _currentLightIndex --sigue apilando luces
				)--if else
				
				--si es el ultimo nodo en el recorrido de la selecicon, apila el ultimo bloque
				if i==_trvSel.count then
				(
					append _parentContainersUi _currentParentUi
					append _lightsIndexToDelete _currentLightIndexes
				)--if
			)--for
			
			--recorre los contenedores de los que eliminar luces
			for i=1 to _parentContainersUi.count do
			(
				--recorre los arboles de contenedores buscando el contenedor que tenga el uiObj del parametro
				for _contTree in this.containerTrees do
				( 
					_containers = lb.passManager.getbyUiObj _parentContainersUi[i] containerTree:_contTree
						
					if _containers.count != 0 then for _cont in _containers do
					(						
						for j=_lightsIndexToDelete[i].count to 1 by -1 do _cont.removeLightByIndex _lightsIndexToDelete[i][j]
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
					)--if for
				)--for
			)--for
		),	

		------------------------------------------------
		--@fn: undefined | addSelectedObjects | Añade los objetos seleccionados en la escena a los hiddenObjectSet/lodSet seleccionados.
		------------------------------------------------
		fn addSelectedObjects =
		(
			--obtiene los grupos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			_currSel = getCurrentSelection()
			_validObjs = (shapes as array) + (geometry as array)
			_selObj = for _o in _currSel where findItem _validObjs _o != 0 collect _o
				
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para añadirles las luces
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						for _ob in _selObj do _cont.addNode _ob --añade las luces
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
					)--if
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | clearSelectedHiddenNodeSetsObjects | Vacia el array de objetos de los contenedores seleccionados.
		------------------------------------------------
		fn clearSelectedHiddenNodeSetsObjects =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
				
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para eliminarles las luces
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_cont.removeNodes()
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
					)--if
				)--for
		),

		------------------------------------------------
		--@fn: undefined | selectSelectedHiddenNodeSetsObjects | Selecciona en la escena los objetos de los hiddenObjectSets/lodSets seleccionados.
		------------------------------------------------
		fn selectSelectedHiddenNodeSetsObjects =
		(
			_trvSel = this.rollMain.trvContainers.selection --obtiene la seleccion
			_nodesToSelect = #() --array para almacenar los objetos que hay que seleccionar
			
			--recorre la seleccion de arboles de contenedores en el ui y busca su equivalente en los arboles de contenedores
			for i=1 to _trvSel.count do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_nodeSets = _cont.getNodeSets()
						for j=1 to _nodeSets.count where (_cont.getNodeSetEnabledState j) do _nodesToSelect += _nodeSets[j].getNodes() --obtiene los objetos del nodeSet
						_nodesToSelect += _cont.getNodes()
					)--if for					
				)--for
			
			clearSelection()
			select _nodesToSelect --realiza la seleccion
		),

		
		------------------------------------------------
		--@fn: undefined | selectSelectedObjects | Selecciona en la escena las luces seleccionadas.
		------------------------------------------------
		fn selectSelectedObjects =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			_objectsToSelect = #() --array para almacenar los objetos que hay que seleccionar
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para obtener sus luces seleccionadas
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_objectNames = _cont.getNodesNames() --obtiene los nombres de las luces del contenedor
						_objectName = _trvSel.item[i-1].item[0] --obtiene el nombre de la luz actual
						_index = findItem _objectNames _objectName
						
						if _index != 0 then --si la luz esta presente en el contenedor
						(
							_nodes = _cont.getNodes()
							append _objectsToSelect _nodes[_index]
						)--if
					)--if
				)--for
			
			clearSelection()
			select _objectsToSelect --realiza la seleccion
		),
		
		------------------------------------------------
		--@fn: undefined | selectedObjectsEnabledStateToggle | Cambia el estado (habilitado/deshabilitado) de las luces seleccionadas.
		------------------------------------------------
		fn selectedObjectsEnabledStateToggle =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para cambiarles el estado a sus luces seleccionadas
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_objectNames = _cont.getNodesNames() --obtiene los nombres de las luces del contenedor
						_objectName = _trvSel.item[i-1].item[0] --obtiene el nombre de la luz actual
						_index = findItem _objectNames _objectName
						
						if _index != 0 then --si la luz esta presente en el contenedor
						(
							_state = _cont.getNodeEnabledState _index
								
							_trvSel.item[i-1].setValue 4 (if _state then "off" else "on")
							_cont.setNodeEnabledState _index (not _state)
							this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1]
							this.rollMain.updateTrvContainerAppearance mode:#state node:_trvSel.item[i-1]
						)--if
					)--if
				)--for
		),
		
		------------------------------------------------
		--@fn: undefined | removeSelectedObjects | Elimina las luces seleccionadas en el arbol.
		------------------------------------------------
		fn removeSelectedObjects =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			--variables para almacenar los contenedores y los bloques de luces a eliminar
			_parentContainersUi = #()
			_objectsIndexToDelete = #()
			
			--variables temporales para crear los bloques de luces a eliminar
			_currentObjectIndexes = #()
			_currentParentUi = undefined
			
			--recorre la seleccion y hace eliminaciones de luces por bloques, en funcion del contenedor padre de cada nodo seleccionado
			for i=1 to _trvSel.count do
			(
				--obtiene el objeto de UI del contenedor padre del nodeSet
				_containerUiNode = _trvSel.item[i-1].ParentNode
				
				--obtiene el indice de la luz seleccionada dentro del contenedor
				_currentObjectIndex = 0
				_stop = false
				for j=1 to _containerUiNode.nodes.count where not _stop and _containerUiNode.nodes.item[j-1].item[2] == "object" do
				(
					_currentObjectIndex += 1
					if _containerUiNode.nodes.item[j-1] == (_trvSel.item[i-1]) then _stop = true						
				)--for
				if not _stop then _currentObjectIndex = 0
				
				--si el padre no es el mismo, hay que empezar una nueva recoleccion para eliminar y justo antes hay que eliminar el bloque anterior de luces
				if (_containerUiNode != _currentParentUi) then
				(
					--almacena los contenedores y las luces en un bloque nuevo definitivo para eliminarlo tras la iteracion
					append _parentContainersUi _currentParentUi
					append _objectsIndexToDelete _currentObjectIndexes
					
					--cambia de bloque
					_currentParentUi = _containerUiNode
					_currentObjectIndexes = #(_currentObjectIndex)
				)
				else
				(
					append _currentObjectIndexes _currentObjectIndex --sigue apilando luces
				)--if else
				
				--si es el ultimo nodo en el recorrido de la selecicon, apila el ultimo bloque
				if i==_trvSel.count then
				(
					append _parentContainersUi _currentParentUi
					append _objectsIndexToDelete _currentObjectIndexes
				)--if
			)--for
			
			--recorre los contenedores de los que eliminar luces
			for i=1 to _parentContainersUi.count do
			(
				--recorre los arboles de contenedores buscando el contenedor que tenga el uiObj del parametro
				for _contTree in this.containerTrees do
				( 
					_containers = lb.passManager.getbyUiObj _parentContainersUi[i] containerTree:_contTree
						
					if _containers.count != 0 then for _cont in _containers do
					(						
						for j=_objectsIndexToDelete[i].count to 1 by -1 do _cont.removeNodeByIndex _objectsIndexToDelete[i][j]
						this.rollMain.updateTrvContainers mode:#update specificContainer:_cont
					)--if for
				)--for
			)--for
		),	
		
		------------------------------------------------
		--@fn: undefined | restoreCutBufferItemsStyle | Restaura el aspecto de los nodos cortados.
		--@opt: boolean | emptyBuffer | true | Indica si vaciar el buffer tras la restauracion.
		------------------------------------------------
		fn restoreCutBufferItemsStyle emptyBuffer:true =
		(
			------------------------------------------------
			--si se había dado a cortar pero no a pegar, hay que restablecer el aspecto de los nodos cortados antes de proceder con la siguiente operacion
			if this.cutTrvSelection.count != 0 then
			(
				for i=this.cutTrvSelection.count to 1 by -1 where (this.cutTrvSelection[i]) != undefined do
				(
					(this.cutTrvSelection[i]).SetValue 6 "dark"
					this.rollMain.updateTrvContainerAppearance mode:#icon node:this.cutTrvSelection[i] --actualiza el icono
					this.rollMain.updateTrvContainerAppearance mode:#cut node:this.cutTrvSelection[i] --actualiza el color del texto
				)--for

				for i=this.cutOverridesParents.count to 1 by -1 do
				(
					(this.cutOverridesParents[i]).SetValue 6 "dark"
					this.rollMain.updateTrvContainerAppearance mode:#icon node:this.cutOverridesParents[i] --actualiza el icono
					this.rollMain.updateTrvContainerAppearance mode:#cut node:this.cutOverridesParents[i] --actualiza el color del texto
				)--for
			)--if

			if emptyBuffer then
			(
				this.copyBufferItemsType = undefined
				this.copyBuffer = #()
				this.copyMode = #copy
				this.cutTrvSelection = #()
				this.cutOverridesParents = #()
			)--if
			------------------------------------------------
		),

		------------------------------------------------
		--@fn: undefined | fillCopyBuffer | Rellena el buffer de copia de elementos del árbol.
		--@opt: name | mode | #copy | Indica si la copia es en modo copy o cut, para pintar los nodos en modo claro indicando que es un corte.
		------------------------------------------------
		fn fillCopyBuffer mode:#copy =
		(
			------------------------------------------------
			--si se había dado a cortar pero no a pegar, hay que restablecer el aspecto de los nodos cortados antes de proceder con la siguiente operacion
			--this.restoreCutBufferItemsStyle()
			------------------------------------------------

			------------------------------------------------
			--primero vacía el buffer de copia
			this.copyBufferItemsType = undefined
			this.copyBuffer = #()
			this.copyMode = mode
			this.cutTrvSelection = #()
			this.cutOverridesParents = #()
			------------------------------------------------

			------------------------------------------------
			--obtiene la seleccion
			_trvSel = this.rollMain.trvContainers.selection
			
			--solo si hay ObjectSets seleccionados
			if _trvSel.count != 0 then
			(
				_containerTypes = #("passTree", "settings", "passGroup", "pass", "lightSet", "ObjectSet", "hiddenObjectSet", "lodSet", "flatColorObjectSet")
				--"overrides" lo dejamos fuera del array porque es un caso especial de copia, ya que solo hay que copiar sus overrides, no el contenedor entero

				this.copyBufferItemsType = _trvSel.item[0].item[2] --almacena el tipo de elementos a copiar
				
				------------------------------------------------				
				--si la seleccion esta formada por containers los almacena
				if findItem _containerTypes this.copyBufferItemsType != 0 then
				(
					for i=1 to _trvSel.count do
						for _contTree in this.containerTrees do
						(
							_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
							this.copyBuffer += _containers
						)--for				
				)--if 
				else
				(
					case this.copyBufferItemsType of
					(
						------------------------------------------------
						"overrides":
						(
							for i=_trvSel.count to 1 by -1 do
								for _contTree in this.containerTrees do
								(
									_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
									
									if _containers.count != 0 then for _cont in _containers do
									(
										_contOverrides = _cont.getOverrides()
										if _contOverrides.count != 0 then this.copyBuffer += _contOverrides

										--almacena tambien el contenedor de overrides para poder deseleccionarlo mas tarde
										append this.cutOverridesParents (_cont.getUiObj())
									)--if
								)--for

							--como es un caso especial, en el que no se ha copiado el contenedor sino los overrides que contiene hay que cambiar el tipo de los elementos copiados.
							this.copyBufferItemsType = "override"
						)--overrides
						------------------------------------------------

						------------------------------------------------
						"override":
						(
							for i=_trvSel.count to 1 by -1 do
								for _contTree in this.containerTrees do
								(
									_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
									
									if _containers.count != 0 then for _cont in _containers do
									(
										_overrideNames = _cont.getOverrideNames() --obtiene los nombres de los overrides del contenedor
										_overrideName = _trvSel.item[i-1].item[0] --obtiene el nombre del override actual
										_index = findItem _overrideNames _overrideName
										
										--si el override existe lo almacena
										if _index != 0 then append this.copyBuffer (_cont.getOverrides())[_index]
									)--if
								)--for
						)--override
						------------------------------------------------
						
						------------------------------------------------
						"light":
						(
							for i=_trvSel.count to 1 by -1 do
								for _contTree in this.containerTrees do
								(
									_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
									
									if _containers.count != 0 then for _cont in _containers do
									(
										_lightNames = _cont.getLightNames() --obtiene los nombres de las luces del contenedor
										_lightName = _trvSel.item[i-1].item[0] --obtiene el nombre de la luz actual
										_index = findItem _lightNames _lightName
										
										--si la luz existe lo almacena
										if _index != 0 then append this.copyBuffer (_cont.getLightNodes())[_index]
									)--if
								)--for
						)--light
						------------------------------------------------
						
						------------------------------------------------
						"nodeSet":
						(
							for i=_trvSel.count to 1 by -1 do
								for _contTree in this.containerTrees do
								(
									_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
									
									if _containers.count != 0 then for _cont in _containers do
									(
										_nodeSetNames = _cont.getNodeSetNames() --obtiene los nombres de las luces del contenedor
										_nodeSetName = _trvSel.item[i-1].item[0] --obtiene el nombre de la luz actual
										_index = findItem _nodeSetNames _nodeSetName
										
										--si la luz existe lo almacena
										if _index != 0 then append this.copyBuffer (_cont.getNodeSets())[_index]
									)--if
								)--for
						)--nodeSet
						------------------------------------------------

						------------------------------------------------
						"object":
						(
							for i=_trvSel.count to 1 by -1 do
								for _contTree in this.containerTrees do
								(
									_containers = lb.passManager.getbyUiObj _trvSel.item[i-1].ParentNode containerTree:_contTree
									
									if _containers.count != 0 then for _cont in _containers do
									(
										_objectNames = _cont.getNodesNames() --obtiene los nombres de las luces del contenedor
										_objectName = _trvSel.item[i-1].item[0] --obtiene el nombre de la luz actual
										_index = findItem _objectNames _objectName
										
										--si la luz existe lo almacena
										if _index != 0 then append this.copyBuffer (_cont.getNodes())[_index]
									)--if
								)--for
						)--object
						------------------------------------------------
					)--case
				)--if else
				------------------------------------------------

				------------------------------------------------
				if mode == #cut then
				(
					this.copyMode = #cut --establece el modo de copia como CUT

					this.cutTrvSelection = for i=1 to _trvSel.count collect _trvSel.item[i-1] --almacena la seleccion actual para luego eliminarla tras la operacion paste.

					if _trvSel.item[0].item[2] == "overrides" then
					(
						this.cutTrvSelection = #()
						for i=1 to _trvSel.count do
							for j=1 to _trvSel.item[i-1].Nodes.count do
								append this.cutTrvSelection _trvSel.item[i-1].Nodes.item[j-1]
					)

					for i=_trvSel.count to 1 by -1 where (_trvSel.item[i-1]) != undefined do
					(
						(_trvSel.item[i-1]).SetValue 6 "light"
						this.rollMain.updateTrvContainerAppearance mode:#icon node:_trvSel.item[i-1] --actualiza el icono
						this.rollMain.updateTrvContainerAppearance mode:#cut node:_trvSel.item[i-1] --actualiza el color del texto
					)--for
				)--if
				------------------------------------------------			
			)--if			
		),
		
		------------------------------------------------
		--@fn: undefined | pasteCopyBuffer | Crea una copia de los elementos del buffer y los pega en los elementos seleccionados.
		--@opt: name | mode | #copy | Indica si la copia es en modo copy o cut, para pintar eliminar los nodos cortados en un corte.
		--@opt: boolean | showMessageOnError | false | Indica si mostrar un mensaje en caso de error.
		--@opt: boolean | saveLogs | false | Indica si salvar logs.
		------------------------------------------------
		fn pasteCopyBuffer mode:#copy showMessageOnError:false saveLogs:false =
		(
			_pasteFail = false --flag para ver si falla la copia
			
			--obtiene la seleccion
			_trvSel = this.rollMain.trvContainers.selection
			
			--inicia una transaccion de edicion de logs
			if saveLogs then
			(
				lb.log.rollback()
				saveLogs = lb.log.beginTransaction()
			)
			
			--obtiene un id unico en funcion del tiempo de sistema actual, a aprtir del cual mostrar los logs en caso de error
			_currentTimeId = lb.time.getCurrentTimeId()
			
			if saveLogs then lb.log.add ("Paste Items Start") sender:"lb.passManagerUI.pasteCopyBuffer" type:#info
			
			--solo si hay objetos seleccionados
			if _trvSel.count != 0 then
			(
				_containerTypes = #("passTree", "settings", "overrides", "passGroup", "pass", "lightSet", "ObjectSet", "hiddenObjectSet", "lodSet", "flatColorObjectSet")
				_selItemType = _trvSel.item[0].item[2] --almacena el tipo de elementos a copiar
					
				------------------------------------------------				
				--si la seleccion esta formada por containers los almacena
				if findItem _containerTypes _selItemType != 0 then
				(
					_processMessage = "" --mensaje que mostrar si algo falla					
					
					for i=1 to _trvSel.count do
						for _contTree in this.containerTrees do
						(
							_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
							
							if _containers.count != 0 then for _cont in _containers do
							(
								_uiUpdateMode = #update --modo de actualizacion del interface
								_updateContainer = _cont
								
								case _selItemType of
								(
									--TO DO: AQUI - queda hacer que el duplicado de overrides permita nombres iguales

									"overrides":
									(
										_allowedOvs = _cont.getAllowedOverrideTypes()
										
										for _item in this.copyBuffer do
										(
											if findItem _allowedOvs (_item.getSubType()) != 0 then
											(
												_oldCaption = (filterString (_item.getCaption()) "#")[1]
												
												_newOverride = lb.overrides.duplicateOverride _item keepCaption:true --(mode == #cut) --duplica el override
												if _newOverride != undefined then
												(
													_cont.appendOverride _newOverride
													_newOverride.setCaption _oldCaption
												)--if
											)
											else
											(
												if saveLogs then lb.log.add ("NOT ALLOWED OVERRIDE: " + (_item.getSubType()) + " override not allowed in " + ((_cont.getParent()).getSubType())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
												_pasteFail = true
											)--if else

											----------------------------------------------------------------
											--Refrescamos el estado de los padres
											_parentContainer = _cont
											while _parentContainer != undefined do
											(
												_uiObj = _parentContainer.getUiObj()
												_uiObj.setValue 5 (_parentContainer.getState() as string)
												this.rollMain.updateTrvContainerAppearance mode:#state node:(_uiObj)
												_parentContainer = _parentContainer.parent
											)
											----------------------------------------------------------------
										)--for
									)--"overrides"
									
									"ObjectSet":
									(
										for _item in this.copyBuffer do
										(
											if findItem (_cont.getNodeSetNames()) (_item.getCaption()) == 0 then
												_cont.addNodeSetByName (_item.getCaption())
											else
											(
												if saveLogs then lb.log.add ("NODESET ALREADY ADDED: " + (_item.getCaption()) + " already in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
												_pasteFail = true
											)--if else
										)--for
									)--"ObjectSet"
									
									"lightSet":
									(
										for _item in this.copyBuffer do
										(
											if findItem (_cont.getLightNodes()) _item == 0 then
												_cont.addLight _item
											else
											(
												if saveLogs then lb.log.add ("LIGHT ALREADY ADDED: " + (_item.name) + " already in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
												_pasteFail = true	
											)
										)--for
									)--"lightSet"

									"hiddenObjectSet":
									(
										for _item in this.copyBuffer do
										(
											if (this.copyBufferItemsType == "nodeSet") do
											(
												if findItem (_cont.getNodeSetNames()) (_item.getCaption()) == 0 then
													_cont.addNodeSetByName (_item.getCaption())
												else
												(
													if saveLogs then lb.log.add ("NODESET ALREADY ADDED: " + (_item.getCaption()) + " already in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
													_pasteFail = true
												)--if else
											)--if

											if (this.copyBufferItemsType == "object") do
											(
												if findItem (_cont.getNodesNames()) _item == 0 then
													_cont.addNode _item
												else
												(
													if saveLogs then lb.log.add ("NODE ALREADY ADDED: " + (_item.name) + " already in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
													_pasteFail = true	
												)
											)
										)--for
									)--"hiddenObjectSet"
									
									"lodSet":
									(
										for _item in this.copyBuffer do
										(
											if (this.copyBufferItemsType == "nodeSet") do
											(
												if findItem (_cont.getNodeSetNames()) (_item.getCaption()) == 0 then
													_cont.addNodeSetByName (_item.getCaption())
												else
												(
													if saveLogs then lb.log.add ("NODESET ALREADY ADDED: " + (_item.getCaption()) + " already in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
													_pasteFail = true
												)--if else
											)--if

											if (this.copyBufferItemsType == "object") do
											(
												if findItem (_cont.getNodesNames()) _item == 0 then
													_cont.addNode _item
												else
												(
													if saveLogs then lb.log.add ("NODE ALREADY ADDED: " + (_item.name) + " already in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
													_pasteFail = true	
												)
											)
										)--for
									)--"lodSet"
									"flatColorObjectSet":
									(
										for _item in this.copyBuffer do
										(
											if (this.copyBufferItemsType == "nodeSet") do
											(
												if findItem (_cont.getNodeSetNames()) (_item.getCaption()) == 0 then
													_cont.addNodeSetByName (_item.getCaption())
												else
												(
													if saveLogs then lb.log.add ("NODESET ALREADY ADDED: " + (_item.getCaption()) + " already in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
													_pasteFail = true
												)--if else
											)--if

											if (this.copyBufferItemsType == "object") do
											(
												if findItem (_cont.getNodesNames()) _item == 0 then
													_cont.addNode _item
												else
												(
													if saveLogs then lb.log.add ("NODE ALREADY ADDED: " + (_item.name) + " already in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
													_pasteFail = true	
												)
											)
										)--for
									)--"flatColorObjectSet"
									default: --containers
									(										
										for _item in this.copyBuffer do
										(											
											_oldCaption = (filterString (_item.getCaption()) "#")[1]

											_duplicatedItem = lb.passManager.duplicateContainer _item keepCaption:true --(mode == #cut)
											
											if _duplicatedItem != undefined then
											(
												_cont.addChild _duplicatedItem
												_duplicatedItem.setParent _cont
												_duplicatedItem.setCaption _oldCaption
											)
											else
											(
												if saveLogs then lb.log.add ("ITEM COPY ERROR: " + (_item.getCaption()) + " not pasted in " + (_cont.getCaption())) sender:"lb.passManagerUI.pasteCopyBuffer" type:#error level:2
												_pasteFail = true
											)--if else
										)--for
										
										_uiUpdateMode = #add --cambia el modo de actualizacion del interface
										_updateContainer = if (_cont.getChildren()).count != 0 then (_cont.getChildren())[1] else _cont
									)--default
								)--case
									
								this.rollMain.updateTrvContainers mode:_uiUpdateMode specificContainer:_updateContainer
							)--if
							--_selItemType
						)--for					
				)--if 
				else
				(
					--TO DO: De momento solo hay casos en los que se puede hacer paste en un contenedor, por tanto esta parte se reserva por si sale algun caso especial.
				)--if else
				------------------------------------------------

				------------------------------------------------
				--si esta en modo cut tiene que eliminar los originales una vez copiados y limpiar el buffer
				if this.copyMode == #cut then
				(
					_currentSelItems = for i=1 to _trvSel.count collect _trvSel.item[i-1] --almacena la seleccion actual
					this.restoreCutBufferItemsStyle emptyBuffer:false --reastaura el aspecto original
					
					if not _pasteFail then --si antes ha conseguido hacer la copia
					(
						this.rollMain.trvContainers.selection.clear() --limpia la seleccion actual
						for i=1 to this.cutTrvSelection.count do this.rollMain.trvContainers.selection.Add (this.cutTrvSelection[i]) --selecciona los elementos cortados

						--una vez reseleccionados hay que llamar al proceso de eliminar de cada tipo de nodos						
						case this.copyBufferItemsType of
						(
							"override":this.removeSelectedOverrides()
							"light":this.removeSelectedLights()
							"nodeSet":this.removeSelectedNodeSets()
							"object":this.removeSelectedObjects()
							default:this.removeSelectedContainers()
						)--case
					)--if

					--restaura la seleccion guardada
					for i=1 to _currentSelItems.count do this.rollMain.trvContainers.selection.Add (_currentSelItems[i])

					--limpiar el buffer
					this.copyBufferItemsType = undefined
					this.copyBuffer = #()
					this.cutTrvSelection = #()
					this.cutOverridesParents = #()
				)--if
				------------------------------------------------
			)--if

			--termina la transaccion de logs y salva los cambios
			if saveLogs then
			(
				if not _pasteFail then lb.log.add ("Paste Items End") sender:"lb.passManagerUI.pasteCopyBuffer" type:#info
				else lb.log.add ("Paste Items ERROR") sender:"lb.passManagerUI.pasteCopyBuffer" type:#error
				
				if not (lb.log.commit()) then lb.log.rollback()
			)
			
			if _pasteFail and showMessageOnError and saveLogs and not lb.logManager.isOpen() then lb.logManager.run sender:#all type:#all time:#current refTimeId:_currentTimeId			

			if _pasteFail then lb.message.show "ERROR: Some items could not be copied" pos:((getDialogPos this.rollMain) + [(this.rollMain.width/2 - 150),(this.rollMain.height/2)])
		),
		
		------------------------------------------------
		--@fn: boolean | isValidDropNode | Devuelve TRUE si el nodo de drop es una nodo valido donde soltar la seleccion.
		--@gets: treeNode | dropNode | Nodo sobre el que se esta haciendo drag y es un candidato a drop.
		--@gets: array{treeNode} | selectedNodes | Nodos seleccionados en el arbol y que estan siendo arrastrados.
		------------------------------------------------
		fn isValidDropNode dropNode selectedNodes =
		(
			_isValid = false

			--obtiene el tipo del nodo de drop sobre el que se está y de la selección.
			_dropType = dropNode.getValue 2
			_selectionType = selectedNodes.item[0].getValue 2

			_index = findItem this.dropTypes _dropType --averigua si es un nodo sobe el que se puede hacer drop
			if _index != 0 then
			(
				_index = findItem this.dropAllowedTypes[_index] _selectionType --averigua si los nodos son del tipo aceptado
				_isValid = (_index != 0)

				--si se esta arrastrando sobre un nodo del mismo tipo, para reordenar, no permite hacerlo si no tienen todos el mismo padre
				if _isValid and (_dropType == _selectionType) then
				(
					--no permite cambiar de orden overrides porque eso ya esta establecido
					if _selectionType == "override" then _isValid = false

					--si algun nodo seleccionado tiene el mismo padre no es valido el drop
					for i=1 to selectedNodes.count where _isValid and (selectedNodes.item[i-1].ParentNode != dropNode.ParentNode) do _isValid = false
				)--if

				--si se esta arrastrando sobre un nodo de distinto tipo, no se permite arrastrar sobre el padre actual
				if _isValid and (_dropType != _selectionType) then
				(					
					--si algun nodo seleccionado no tiene el mismo padre no es valido el drop
					for i=1 to selectedNodes.count where _isValid and (selectedNodes.item[i-1].ParentNode == dropNode) do _isValid = false
				)--if
			)--if

			_isValid
		),

		------------------------------------------------
		--@fn: undefined | dropNodes | Operaciones al soltar los nodos arrastrados sobre otro.
		--@gets: treeNode | dropNode | Nodo sobre el que se esta haciendo drop.
		--@gets: array{treeNode} | selectedNodes | Nodos seleccionados en el arbol y que estan siendo arrastrados.
		--@opt: name | mode | #cut | Indica si el drop corta los nodos o los pega.
		------------------------------------------------
		fn dropNodes dropNode selectedNodes mode:#cut =
		(			
			--obtiene el tipo del nodo de drop sobre el que se está y de la selección.
			_dropType = dropNode.getValue 2
			_selectionType = selectedNodes.item[0].getValue 2

			_itemsToUpate = #() --elementos del passTree que actualizar debido a que pierden hijos
			_dropItemToUpdate = undefined --elemento del passTree sobre el que se ha hecho drop y que hay que actualizar porque gana hijos

			--si los tipos son diferentes quiere decir que el drop se está haciendo para cambiar un elemento de padre
			if _selectionType != _dropType then
			(
				case _selectionType of
				(
					--si el contenedor arrastrado es de overrides, se debe copiar o cortar su contenido
					"overrides":
					(
						--obtiene los overrides de los contenedores
						_overrideNodes = #()
						for i=1 to selectedNodes.count do (for j=1 to selectedNodes.item[i-1].Nodes.count do append _overrideNodes selectedNodes.item[i-1].Nodes.item[j-1])

						for i=selectedNodes.count to 1 by -1 do this.rollMain.trvContainers.selection.Remove selectedNodes.item[i-1] --elimina la selección actual
						for _ovNode in _overrideNodes do this.rollMain.trvContainers.selection.Add _ovNode --selecciona los overrides individules
						this.fillCopyBuffer mode:mode --rellena el buffer de copia

						for i=selectedNodes.count to 1 by -1 do this.rollMain.trvContainers.selection.Remove selectedNodes.item[i-1] --elimina la selección actual
						
						--obtiene el nodo de overrides hijo donde pegar los overrides
						_overrideContainerNode = undefined
						for i=1 to dropNode.Nodes.count where _overrideContainerNode == undefined and (dropNode.Nodes.item[i-1].getValue 2 == "overrides") do
							_overrideContainerNode = dropNode.Nodes.item[i-1]

						if _overrideContainerNode != undefined then 
						(
							this.rollMain.trvContainers.selection.Add _overrideContainerNode --selecciona el nodo de drop
							this.rollMain.forceTrvContainersCorrectSelection()
							this.pasteCopyBuffer showMessageOnError:true saveLogs:this.saveLogs mode:mode --pega el buffer de copia	
						)--if					
					)--overrides

					--casos por defecto, copia o corte de contenedores
					default:
					(
						this.fillCopyBuffer mode:mode --rellena el buffer de copia
						for i=selectedNodes.count to 1 by -1 do this.rollMain.trvContainers.selection.Remove selectedNodes.item[i-1] --elimina la selección actual
						this.rollMain.trvContainers.selection.Add dropNode --selecciona el nodo de drop
						this.rollMain.forceTrvContainersCorrectSelection()
						this.pasteCopyBuffer showMessageOnError:true saveLogs:this.saveLogs mode:mode --pega el buffer de copia
					)--default
				)--case				
			)
			else --si los tipos son iguales se trata de una reordenación, excepto si son contenedores de overrides que lo que hacen es mover su contenido
			(
				case _selectionType of
				(
					--si son contenedores de overrides lo que hay que mover o copiar es el contenido
					"overrides":
					(
						--obtiene los overrides de los contenedores
						_overrideNodes = #()
						for i=1 to selectedNodes.count do (for j=1 to selectedNodes.item[i-1].Nodes.count do append _overrideNodes selectedNodes.item[i-1].Nodes.item[j-1])

						for i=selectedNodes.count to 1 by -1 do this.rollMain.trvContainers.selection.Remove selectedNodes.item[i-1] --elimina la selección actual
						for _ovNode in _overrideNodes do this.rollMain.trvContainers.selection.Add _ovNode --selecciona los overrides individules
						this.fillCopyBuffer mode:mode --rellena el buffer de copia
						for i=selectedNodes.count to 1 by -1 do this.rollMain.trvContainers.selection.Remove selectedNodes.item[i-1] --elimina la selección actual
						this.rollMain.trvContainers.selection.Add dropNode --selecciona el nodo de drop
						this.rollMain.forceTrvContainersCorrectSelection()
						this.pasteCopyBuffer showMessageOnError:true saveLogs:this.saveLogs mode:mode --pega el buffer de copia
					)--overrides

					--casos por defecto, reordenaciones
					default:
					(
						------------------------------------------------
						--averigua el id minimo y maximo de la seleccion para ver si se puede hacer drop

						_dropIndex = this.rollMain.trvContainers.GetNodeIndex dropNode
						_minIndex = 1000000
						_maxIndex = -1000000

						for i=1 to selectedNodes.count do 
						(
							_index = this.rollMain.trvContainers.GetNodeIndex selectedNodes.item[i-1]
							if _index < _minIndex then _minIndex = _index
							if _index > _maxIndex then _maxIndex = _index
						)--for
						------------------------------------------------

						--reordena los nodos del arbol
						for i=1 to selectedNodes.count do this.rollMain.trvContainers.SetNodeIndex selectedNodes.item[i-1] (_dropIndex)
						
						--reordena los containers o hijos segun la nueva ordenación de nombres
						case _selectionType of
						(
							"override":
							(
								--esta operacion no esta permitida
								--los overrides se ordenan automaticamente por precedencia
							)

							"nodeSet":
							(
								--obtiene el contenedor padre de los nodeSets
								_objectSetNode = selectedNodes.item[0].ParentNode
								_objectSetContainer = undefined
								for _contTree in this.containerTrees where _objectSetContainer == undefined do
								(
									_containers = lb.passManager.getbyUiObj _objectSetNode containerTree:_contTree
									if _containers.count != 0 then _objectSetContainer = _containers[1]
								)--for

								--sustituye los nodeSetNames y sus estados por el nuevo orden
								if _objectSetContainer != undefined then
								(
									_sortNodeSetsNames = #()
									_sortNodeSetsNamesEnabledStates = #()
									for i=1 to _objectSetNode.Nodes.count where (_objectSetNode.Nodes.item[i-1].getValue 2 == "nodeSet") do
									(
										append _sortNodeSetsNames (_objectSetNode.Nodes.item[i-1].getValue 0)
										append _sortNodeSetsNamesEnabledStates ((_objectSetNode.Nodes.item[i-1].getValue 4) == "on")
									)--for

									_objectSetContainer.setNodeSetNames _sortNodeSetsNames
									_objectSetContainer.setNodeSetEnabledStates _sortNodeSetsNamesEnabledStates
								)--if
							)--nodeSet

							"light":
							(
								--obtiene el contenedor padre de las luces
								_lightSetNode = selectedNodes.item[0].ParentNode
								_lightSetContainer = undefined
								for _contTree in this.containerTrees where _objectSetContainer == undefined do
								(
									_containers = lb.passManager.getbyUiObj _lightSetNode containerTree:_contTree
									if _containers.count != 0 then _lightSetContainer = _containers[1]
								)--for

								--sustituye las luces y sus estados por el nuevo orden
								if _lightSetContainer != undefined then
								(
									_sortLightNames = #()
									_sortLightNamesEnabledStates = #()
									for i=1 to _lightSetNode.Nodes.count where (_lightSetNode.Nodes.item[i-1].getValue 2 == "light") do
									(
										append _sortLightNames (_lightSetNode.Nodes.item[i-1].getValue 0)
										append _sortLightNamesEnabledStates ((_lightSetNode.Nodes.item[i-1].getValue 4) == "on")
									)--for

									_lightNodes = #()
									_tempLightNodes = _lightSetContainer.getLightNodes()
									for _ln in _sortLightNames do (for _li in _tempLightNodes where _li.name == _ln do append _lightNodes _li)

									_lightSetContainer.setLightNodes _lightNodes
									_lightSetContainer.setLightEnabledStates _sortLightNamesEnabledStates
								)--if
							)--nodeSet

							default:
							(
								_uiNode = selectedNodes.item[0].ParentNode
								_parentContainer = undefined
								for _contTree in this.containerTrees where _parentContainer == undefined do
								(
									_containers = lb.passManager.getbyUiObj _uiNode containerTree:_contTree
									if _containers.count != 0 then _parentContainer = _containers[1]
								)--for

								--sustituye los objectSets y sus estados por el nuevo orden
								if _parentContainer != undefined then
								(
									_children = _parentContainer.getChildren()
									
									_sortedItemsNames = #()
									for i=1 to _uiNode.Nodes.count where (_uiNode.Nodes.item[i-1].getValue 2 == _selectionType) do
									(
										_uiCaption = (_uiNode.nodes.item[i-1].getValue 0)
										if _children[i].getSubType() == #passGroup do
											_uiCaption = substituteString _uiCaption "----------" ""
										append _sortedItemsNames _uiCaption
									)
									
									_infoNode = _parentContainer.getInfoNode() --obtiene el nodo de la escena con la informaión del contenedor padre
									_childrenContainers = for ch in _children where (ch.getSubType() as string) == _selectionType collect ch --obtiene los contenedores hijos del contenedor padre
																		
									--reordena los hijos segun el listado
									if _sortedItemsNames.count == _childrenContainers.count then
									(
										for _name in _sortedItemsNames do
											for _ch in _childrenContainers where _ch.getCaption() == _name do
											(
												_parentContainer.removeChild _ch
												_parentContainer.addChild _ch sortChildrenByTypes:false
											)--for

										_parentContainer.sortChildrenByType() --ordena los hijos por tipos
									)
								)--if
							)--objectSet
						)--case
					)--default			
				)--case
			)--if else
		),	

		------------------------------------------------
		--@fn: undefined | expandTree | Expande el subarbol de pases solicitado. Expande arboles de pases, grupos de pases y pases.
		------------------------------------------------
		fn expandTree _invert:false level:-1 =
		(
			--obtiene los nodos seleccionados
			_trvSel = this.rollMain.trvContainers.selection
			
			------------------------------------------------
			--funcion recursiva global temporal para obtener todos los subnodos a partir de uno dado
			global _getAllSubNodes
			fn _getAllSubNodes node limitLevel:-9999 =
			(
				_subnodes = #()
					
				if limitLevel < -9998 or limitLevel > 0 then
				(
					_subnodes = for i=1 to node.nodes.count collect node.nodes.item[i-1]
						
					for i=1 to node.nodes.count where (node.nodes.item[i-1]).nodes.count != 0 do
						_subnodes += _getAllSubNodes (node.nodes.item[i-1]) limitLevel:(limitLevel - 1)
				)--if
				
				_subnodes
			)--fn
			------------------------------------------------
			
			--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para expandirlos o contraerlos
			for i=_trvSel.count to 1 by -1 do
				for _contTree in this.containerTrees do
				(				
					_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
					
					if _containers.count != 0 then for _cont in _containers do
					(
						_type = _cont.getSubType() --obtiene el tipo del contenedor
						
						if not _invert then --caso de expandir
						(
							--primero colapsa el arbol entero
							if level != -1 then this.expandTree _invert:true
							
							--despues expande los niveles indicados
							_allNodes = _getAllSubNodes (_cont.getUiObj()) limitLevel:(level-1)
							for _n in _allNodes do _n.Expanded = true
							(_cont.getUiObj()).Expanded = true
						)
						else --caso de colapsar
						(
							_allNodes = _getAllSubNodes (_cont.getUiObj())
							for _n in _allNodes do _n.Expanded = false
							(_cont.getUiObj()).Expanded = false					
						)--if else
					)--if
				)--for
				
			--_getAllSubNodes = undefined --elimina la funcion global recursiva temporal
		),
		
		------------------------------------------------
		--@fn: undefined | collapseTree | Colapsa el subarbol de pases solicitado. Colapsa arboles de pases, grupos de pases y pases.
		------------------------------------------------
		fn collapseTree =
		(
			expandTree _invert:true
		),
		
		------------------------------------------------
		--@fn: undefined | openOverridesPathTracker | Abre el override de paths
		------------------------------------------------
		fn openOverridesPathTracker =
		(
			_tool = (lb.getTool "overridesPathTracker")
			if not _tool.isOpen() then
			(
				_tool.run passTrees:this.containerTrees
			)
		),


		------------------------------------------------
		--@fn: undefined | searchInPasses | Muestra un listado de objetos del tipo pasado por parámetro y selecciona los pases en los que se encuentre
		------------------------------------------------
		fn searchInPasses type =
		(
			_searchElements = #()
			parentType = ""
			case type of
			(
				#light:
				(
					this.showAddLightsUI() --muestra el dialogo para elegir nodeSets
					_searchElements = this.choiceCandidates
					parentType = #lightSet
					_childrenFunction = "getLightNames"
				)
				#nodeSet:
				(
					this.showAddNodeSetsUI() --muestra el dialogo para elegir nodeSets
					_searchElements = this.choiceCandidates
					parentType = #ObjectSet
					_childrenFunction = "getNodeSetNames"
				)
			)
			if _searchElements.count > 0 do
			(
				this.rollMain.trvContainers.selection.clear()
				for _passTree in this.containerTrees where (_passTree.getSubType() == #passTree) do
					for _passGroup in _passTree.getChildren() where (_passGroup.getSubType() == #passGroup) do
						for _pass in _passGroup.getChildren() where (_pass.getSubType() == #pass) do
						(
							_passUI = _pass.getUiObj()
							for _parent in _pass.getChildren() where (_parent.getSubType() == parentType) and (_passUI.selected == false) do
								(
									global _parent = _parent
									_children = execute ("_parent."+ _childrenFunction +"()")
									_parent = undefined
									_found = false
									for _searching in _searchElements where findItem _children _searching != 0 and _found == false do
									(
										_found = true
										_passUI.selected = true
									)
								)
						)
			)
		),
		
		------------------------------------------------
		--@fn: undefined | menuItemClickedProcess | Ejecuta las acciones todos los menús de la herramienta.
		------------------------------------------------
		fn menuItemClickedProcess menuText =
		(
			this.rollMain.trvContainers.BeginUpdate()
			--------------------------------------------------
			--si se había dado a cortar pero no a pegar, hay que restablecer el aspecto de los nodos cortados antes de proceder con la siguiente operacion
			if menuText != "Paste" then this.restoreCutBufferItemsStyle()

			case menuText of
			(				
				------------------------------------------------
				--EMPTY options
				"New Pass Tree": this.newContainer #passTree				
				------------------------------------------------
				
				------------------------------------------------
				--PASS TREE options
				"Enable/Disable Pass Tree/s": this.selectedConainersEnabledStateToggle()
				"Duplicate Pass Tree/s": this.duplicateSelectedContainers()
				"New Pass Group": this.newContainer #passGroup 
				"Remove Pass Tree/s": this.removeSelectedContainers()
				------------------------------------------------
				
				------------------------------------------------
				--GROUPS options
				"Enable/Disable Group/s": this.selectedConainersEnabledStateToggle()
				"Duplicate Group/s": this.duplicateSelectedContainers()
				"New Pass": this.newContainer #pass
				"New AO Pass": this.newPassFromPreset #AO
				"New Y Pass": this.newPassFromPreset #Y
				"New Z Pass": this.newPassFromPreset #Z
				"New Mask-XYZ Pass": this.newPassFromPreset #XYZ
				"New ETS Pass": this.newPassFromPreset #ETS
				"New Pupil Pass": this.newPassFromPreset #Pupil
				"New UV Pass": this.newPassFromPreset #UV
				"New SMV Pass": this.newPassFromPreset #SMV
				"Remove Pass Group/s": this.removeSelectedContainers()
				"Import Pass from file": this.importFromFile #pass
				------------------------------------------------
				
				------------------------------------------------
				--PASS options
				"Enable/Disable Pass/es": this.selectedConainersEnabledStateToggle()
				"Isolate": this.isolatePass()
				"Show all": this.showAll()
				"Duplicate Pass/es": this.duplicateSelectedContainers()
				"New ObjectSet": this.newContainer #ObjectSet
				"New LightSet": this.newContainer #lightSet
				"New HiddenObjectSet": this.newContainer #hiddenObjectSet
				"New LODSet": this.newContainer #lodSet
				"New FlatColorObjectSet": this.newContainer #flatColorObjectSet
				"Remove Pass/es": this.removeSelectedContainers()
				------------------------------------------------
				
				------------------------------------------------
				--TOOLS options.printAllElements
				"Overrides Path Tracker": this.openOverridesPathTracker() --TODO
				"Find nodeSet": this.searchInPasses #nodeSet
				"Find light": this.searchInPasses #light
				
				------------------------------------------------
				--SETTINGS options
				"Enable/Disable Settings": this.selectedConainersEnabledStateToggle()
				"New Setting/Override": this.addOverride()
				--"Clear Settings/Overrides":
				------------------------------------------------
				
				------------------------------------------------
				--OVERRIDES options
				"Enable/Disable Overrides": this.selectedConainersEnabledStateToggle()
				"New Override": this.addOverride()
				"Clear Overrides": this.clearOverrides()
				------------------------------------------------
				
				------------------------------------------------
				--OVERRIDE options
				"Enable/Disable Override/s": this.selectedOverridesEnabledStateToggle()
				"Edit": this.editSelectedOverrides()
				"Show override warning/error": this.showOverrideStateMessage()
				"Remove Override/s": this.removeSelectedOverrides()
				------------------------------------------------
				
				------------------------------------------------
				--OBJECTSET options
				"Enable/Disable ObjectSet/s": this.selectedConainersEnabledStateToggle()
				"Duplicate ObjectSet/s": this.duplicateSelectedContainers()
				"Select ObjectSet/s objects": this.selectSelectedObjectSetsObjects()
				"Add Node Set/s": this.addNodeSets()
				"Clear NodeSet/s": this.clearSelectedObjectSetsNodeSets()
				"Remove ObjectSet/s": this.removeSelectedContainers()
				------------------------------------------------
				
				------------------------------------------------
				--NODESET options
				"Enable/Disable NodeSet/s": this.selectedNodeSetsEnabledStateToggle()
				"Select NodeSet/s objects": this.selectSelectedNodeSetsObjects()
				"Remove NodeSet/s": this.removeSelectedNodeSets()
				------------------------------------------------
				
				------------------------------------------------
				--LIGHTSET options
				"Enable/Disable LightSet/s": this.selectedConainersEnabledStateToggle()
				"Duplicate LightSet/s": this.duplicateSelectedContainers()
				"Add Selected Scene Lights": this.addSelectedLights()
				"Clear Lights": this.clearSelectedLightSetsLights()
				"Select LightSet/s lights": this.selectSelectedLightSetsLights()
				"Remove LightSet/s": this.removeSelectedContainers()
				------------------------------------------------
				
				------------------------------------------------
				--LIGHT options
				"Enable/Disable Light/s": this.selectedLightsEnabledStateToggle()
				"Select Light/s": this.selectSelectedLights()
				"Remove Light/s": this.removeSelectedLights()
				------------------------------------------------

				------------------------------------------------
				--HIDDENNODESETS options
				"Enable/Disable HiddenNodeSets/s": this.selectedConainersEnabledStateToggle()
				"Duplicate HiddenNodeSets/s": this.duplicateSelectedContainers()
				"Select HiddenNodeSets/s objects": this.selectSelectedHiddenNodeSetsObjects()
				"Add Selected Scene objects": this.addSelectedObjects()
				--"Add Node Set/s": this.addNodeSets() 						--compartido con OBJECTSET
				"Clear objects": (this.clearSelectedHiddenNodeSetsObjects(); this.clearSelectedObjectSetsNodeSets())
				"Remove HiddenNodeSets/s": this.removeSelectedContainers()
				------------------------------------------------

				------------------------------------------------
				--LODSETS options
				"Enable/Disable LODSet/s": this.selectedConainersEnabledStateToggle()
				"Duplicate LODSet/s": this.duplicateSelectedContainers()
				"Select LODSet/s objects": this.selectSelectedHiddenNodeSetsObjects()
				--"Add Selected Scene objects": this.addSelectedObjects()	--compartido con HIDDENNODESETS
				--"Add Node Set/s": this.addNodeSets() 						--compartido con OBJECTSET, HIDDENNODESETS
				--"Clear objects": (this.clearSelectedHiddenNodeSetsObjects(); this.clearSelectedObjectSetsNodeSets()) --compartido con HIDDENNODESETS
				"Remove LODSet/s": this.removeSelectedContainers()
				------------------------------------------------

				------------------------------------------------
				--FLATCOLOROBJECTSETS options
				"Enable/Disable FlatColorObjectSet/s": this.selectedFlatColorEnabledStateToggle()
				"Duplicate FlatColorObjectSet/s": this.duplicateSelectedContainers()
				"Add Selected Scene objects": this.addSelectedObjects()	--compartido con HIDDENNODESETS
				"Select FlatColorObject/s objects": this.selectSelectedHiddenNodeSetsObjects()
				--"Add Node Set/s": this.addNodeSets() 						--compartido con OBJECTSET, HIDDENNODESETS
				"Clear FlatColorNodeSet/s": this.clearSelectedObjectSetsNodeSets()
				"Clear Selected Object/s":  this.clearSelectedHiddenNodeSetsObjects()
				"Clear all": (this.clearSelectedHiddenNodeSetsObjects(); this.clearSelectedObjectSetsNodeSets())
				"Remove FlatColorObjectSet/s": this.removeSelectedContainers()
				------------------------------------------------

				------------------------------------------------
				--OBJECTS options
				"Enable/Disable Object/s": this.selectedObjectsEnabledStateToggle()
				"Select Object/s": this.selectSelectedObjects()
				"Remove Object/s": this.removeSelectedObjects()
				------------------------------------------------
					
				------------------------------------------------
				--SETTINGS options
				"I+D+I": this.toggleProductionMode()
				"Production": this.toggleProductionMode()
				"Save/Show Logs": this.toggleSaveLogsOption()
				------------------------------------------------

				------------------------------------------------
				--VIEW options
				"Overrides": this.toggleViewOption #overrides
				"Lightsets": this.toggleViewOption #lightSets
				"ObjectSets": this.toggleViewOption #ObjectSets
				"HiddenObjectSets": this.toggleViewOption #hiddenObjectSets
				"LODSets": this.toggleViewOption #lodSets
				"FlatColorObjectSets": this.toggleViewOption #flatColorObjectSet
				"NodeSets": this.toggleViewOption #nodeSets
				------------------------------------------------

				------------------------------------------------
				--COMMON options
				"Rename": this.renameSelectedContainers()
				"Render Preview": this.renderPasses #preview useTreeSelection:true previewPercentSize:(this.rollMain.ddlPreviewPercent.selected as integer) showMessageOnError:true saveLogs:this.saveLogs --(this.rollMain.chkShowLogs.checked)
				"Render Local": this.renderPasses #local useTreeSelection:true showMessageOnError:true saveLogs:this.saveLogs --(this.rollMain.chkShowLogs.checked)
				"Render Network": this.renderPasses #network useTreeSelection:true showMessageOnError:true saveLogs:this.saveLogs --(this.rollMain.chkShowLogs.checked)
				"Console Network": this.renderCMDPass()
				"Cut": this.fillCopyBuffer mode:#cut
				"Copy": this.fillCopyBuffer()
				"Paste": this.pasteCopyBuffer showMessageOnError:true saveLogs:this.saveLogs mode:this.copyMode
				"View Level 1": this.expandTree level:1
				"View Level 2": this.expandTree level:2
				"Expand All": this.expandTree level:9999
				"Collapse All": this.collapseTree()
				------------------------------------------------
			)--case
			
			this.rollMain.trvContainers.EndUpdate()
			this.rollMain.trvContainers.Refresh()
		),
		
		------------------------------------------------
		--@fn: array{container} | collectPassesToRender | Devuelve un array con los pases solicitados que esten activos.
		--@gets: name | selecOption | Indica la forma de obtener los pases, por seleccion del arbol #selected, o todos los existentes #all.
		------------------------------------------------
		fn collectPassesToRender selecOption =
		(
			_passes = #() --array de pases de render a devolver
			
			case selecOption of
			(
				#all:
				(
					--recopila todos los pases que esten habilitados
					for _passTree in this.containerTrees where (_passTree.getSubType() == #passTree) and (_passTree.getEnabledState()) do
						for _passGroup in _passTree.getChildren() where (_passGroup.getSubType() == #passGroup) and (_passGroup.getEnabledState()) do
							for _pass in _passGroup.getChildren() where (_pass.getSubType() == #pass) and (_pass.getEnabledState()) do
								append _passes _pass
					
				)--all
				
				#selected:
				(
					--obtiene los pases seleccionados
					_trvSel = this.rollMain.trvContainers.selection
					
					--recorre la seleccion de contenedores en el ui y busca su equivalente en los arboles de contenedores para recopilarlos si son pases o buscar dentro de ellos.
					for i=_trvSel.count to 1 by -1 do
						for _contTree in this.containerTrees do
						(
							_containers = lb.passManager.getbyUiObj _trvSel.item[i-1] containerTree:_contTree
							
							--recorre los contenedores seleccionados
							if _containers.count != 0 then for _cont in _containers /*where (_cont.getEnabledState())*/ do
							(
								_type = _trvSel.item[i-1].item[2] --obtiene el tipo de contenedor
								
								case _type of
								(
									"passTree":
									(
										_groups = for _ch in _cont.getChildren() where (_ch.getSubType() == #passGroup) and (_ch.getEnabledState()) collect _ch --recolecta los grupos hijos del arbol de pases
										for _group in _groups do _passes += for _ch in _group.getChildren() where (_ch.getSubType() == #pass) and (_ch.getEnabledState()) collect _ch --recolecta los pases hijos del grupo
									)--passTree
									
									"passGroup":
									(
										_passes += for _ch in _cont.getChildren() where (_ch.getSubType() == #pass) and (_ch.getEnabledState()) collect _ch --recolecta los pases hijos del grupo
									)--passGroup
									
									"pass":
									(
										append _passes _cont --añade el pase
									)--pass
								)--case
							)--if
						)--for						
				)--selected
			)--case
			
			_passes --devuelve los pases recopilados
		),
		
		------------------------------------------------
		--@fn: boolean | renderPasses | Realiza el render de los arboles de pases, grupos de pases o pases seleccionados o de todos los existentes segun se indique. Devuelve TRUE si hace el render y FALSE si no lo consigue o se cancela.
		--@gets: name | type | Tipo de render que se quiere realizar, #preview, #local, #network.
		--@opt: boolean | useTreeSelection | false | Indica si trabajar con la seleccion del arbol de pases o con todos los existentes.
		--@opt: boolean | saveLogs | false | Indica si salvar logs.
		------------------------------------------------
		fn renderPasses type useTreeSelection:false previewPercentSize:100 showMessageOnError:false saveLogs:false =
		(
			_success = true

			--ProgressBar
			_pbIncrease = 0
			this.rollMain.pbRender.value = 0
			this.rollMain.pbRender.visible = true
			this.rollMain.btnRenderLocal.visible = false
			this.rollMain.btnRenderNetwork.visible = false
			this.rollMain.btnCommandRenderNetwork.visible = false
			
			--inicia una transaccion de edicion de logs
			if saveLogs then
			(
				lb.log.rollback()
				saveLogs = lb.log.beginTransaction()
			)
			--if saveLogs then lb.log.add "RENDER START ------------------------------------------------------------" sender:"lb.passManagerUI" type:#sep

			this.rollMain.pbRender.value = 10
				
			--obtiene un id unico en funcion del tiempo de sistema actual, a aprtir del cual mostrar los logs en caso de error
			_currentTimeId = lb.time.getCurrentTimeId()
			
			--recolecta los pases de render de los que tiene que hacer render	
			_passesToRender = this.collectPassesToRender (if useTreeSelection then #selected else #all)

			this.rollMain.pbRender.value = 20
			_pbIncrease = 70.0 / _passesToRender.count
			
			--TO DO: si hay que hacer comprobaciones para saber si permitir realizar el render o no, este es el lugar
			
			------------------------------------------------
			--desactiva el command panel y los viewports
			_previousMode = getCommandPanelTaskMode()
			_wasMaterialOpened = MatEditor.isOpen()
			MatEditor.close()
			setCommandPanelTaskMode #create
			suspendEditing()
			disableSceneRedraw()
			this.rollMain.removeSceneEvents()
			------------------------------------------------

			------------------------------------------------
			--En funcion del tipo de render que se elija hay que renderizar o hay que enviar a una granja en red
			with undo off
			(
				with animate off
				(
					case type of
					(
						#preview:
						(
							if saveLogs then lb.log.add "RENDER PREVIEW process start" sender:"lb.passManagerUI.renderPasses" type:#info

							lb.passManager.setNetworkRenderMode false --indica al sistema que no es un render en red
							lb.passManager.setPreviewRenderMode true --indica al sistema que es un render de preview

							--llama a la funcion render de cada pase
							for _pass in _passesToRender where _success do
							(
								_pos = (getDialogPos this.rollMain) + [(this.rollMain.width/2 - 150),(this.rollMain.height/2)]
								--if keyboard.escPressed then _success = not (lb.message.show "Render process will stop. Do you really want to cancel?" type:#query pos:_pos)
								if keyboard.escPressed then
								(
									_success = false
									lb.passManager.addErrorMessage "User cancelled"
								)
								if _success then _success = (_pass.renderPass type previewPercentSize:previewPercentSize saveLogs:saveLogs logLevel:2)
								this.rollMain.pbRender.value += _pbIncrease
							)--for
							
							------------------------------------------------
							--rellena los logs
							if saveLogs then
							(
								if _success then lb.log.add "RENDER PREVIEW process completed" sender:"lb.passManagerUI.renderPasses" type:#ok
								else lb.log.add "RENDER PREVIEW process error" sender:"lb.passManagerUI.renderPasses" type:#error
							)--if
							------------------------------------------------
						)--preview
						
						#local:
						(
							if saveLogs then lb.log.add "RENDER LOCAL process start" sender:"lb.passManagerUI.renderPasses" type:#info

							lb.passManager.setNetworkRenderMode false --indica al sistema que no es un render en red
							lb.passManager.setPreviewRenderMode false --indica al sistema que no es un render de preview

							--llama a la funcion render de cada pase
							for _pass in _passesToRender where _success do
							(
								_pos = (getDialogPos this.rollMain) + [(this.rollMain.width/2 - 150),(this.rollMain.height/2)]
								--if keyboard.escPressed then _success = not (lb.message.show "Render process will stop. Do you really want to cancel?" type:#query pos:_pos)
								if keyboard.escPressed then
								(
									_success = false
									lb.passManager.addErrorMessage "User cancelled"
								)
								if _success then _success = (_pass.renderPass type previewPercentSize:previewPercentSize saveLogs:saveLogs logLevel:2)
								this.rollMain.pbRender.value += _pbIncrease
							)--for
							
							------------------------------------------------
							--rellena los logs
							if saveLogs then 
							(
								if _success then lb.log.add "RENDER LOCAL process completed" sender:"lb.passManagerUI.renderPasses" type:#ok
								else lb.log.add "RENDER LOCAL process error" sender:"lb.passManagerUI.renderPasses" type:#error
							)--if
							------------------------------------------------
						)--local
						
						#network:
						(
							_booleanProcess = lb.passManagerUI.timeOutputFramesOptionSelected()
							if (_booleanProcess == true) then
							(

								lb.passManager.setNetworkRenderMode true --indica al sistema que es un render en red
								lb.passManager.setPreviewRenderMode false --indica al sistema que no es un render de preview

								case this.netRenderManager of
								(
									#deadline:
									(
										if saveLogs then lb.log.add "RENDER NETWORK dialog open" sender:"lb.passManagerUI.renderPasses" type:#info
										
										------------------------------------------------
										--intenta abrir el plugin de lanzamiento a deadline
										try
										(
											macros.run "lbTools: lighting" "lbTools_passManagerDeadlineManager"
											if saveLogs then lb.log.add "RENDER NETWORK dialog opened" sender:"lb.passManagerUI.renderPasses" type:#info level:2
										)
										catch (_success = false)
										------------------------------------------------
										
										------------------------------------------------
										--si se ha conseguido abrir la herramienta de envio a Deadline
										if SMTD_MainRollout != undefined and SMTD_MainRollout.rolloutOpen then
										(
											--TO DO: saveLogs:saveLogs -- pasar este parametro al rollout  de Deadline
											
											SMTD_MainRollout.openedFromPM = true --indica que el Deadline se ha abierto desde PM
											SMTD_MainRollout.pmPassesToRender = _passesToRender --rellena los pases de PM que se deben hacer desde deadline
											if saveLogs then lb.log.add "RENDER NETWORK dialog variables initialize" sender:"lb.passManagerUI.renderPasses" type:#info level:2
											
											--llama a una funcion que personaliza el interface de deadline para su uso desde PM
											--deshabilitara si es necesario partes del interface.
											SMTD_MainRollout.customizeForPM isBatchRender:false
											if saveLogs then lb.log.add "RENDER NETWORK dialog UI customization" sender:"lb.passManagerUI.renderPasses" type:#info level:2
										)
										else _success = false
										------------------------------------------------
										
										------------------------------------------------
										--rellena los logs
										if saveLogs then 
										(
											if _success then lb.log.add "RENDER NETWORK dialog opened" sender:"lb.passManagerUI.renderPasses" type:#ok
											else lb.log.add "RENDER NETWORK dialog open error" sender:"lb.passManagerUI.renderPasses" type:#error
										)--if
										------------------------------------------------
									)--deadeLine						
								)--case
							)

						)--network
					)--case
				)--with
			)--with
			------------------------------------------------
			this.rollMain.pbRender.value = 90 --aseguramos el valor

			------------------------------------------------
			--desactiva el command panel y los viewports
			this.rollMain.createSceneEvents()
			resumeEditing()
			enableSceneRedraw()
			if _wasMaterialOpened do
				MatEditor.open()
			setCommandPanelTaskMode _previousMode
			------------------------------------------------

			--termina la transaccion de logs y salva los cambios
			if saveLogs then
			(
				--lb.log.add "RENDER END ------------------------------------------------------------" sender:"lb.passManagerUI" type:#sep
				if not (lb.log.commit()) then lb.log.rollback()
			)
			
			--si el render se ha cancelado o se ha parado por algun motivo lo indica
			_errorMessages = (lb.passManager.getErrorMessages() As String)
			if not _success and _errorMessages != "" then lb.message.show (lb.passManager.getErrorMessages() As String) size:[this.rollMain.width,400] pos:((getDialogPos this.rollMain) + [0,(this.rollMain.height/2)-200])
			if showMessageOnError and saveLogs and not lb.logManager.isOpen() then lb.logManager.run sender:#all type:#all time:#current refTimeId:_currentTimeId
			
			lb.passManager.clearErrorMessages()

			--ProgressBar
			this.rollMain.pbRender.value = 100
			this.rollMain.pbRender.visible = false
			this.rollMain.btnRenderLocal.visible = true
			this.rollMain.btnRenderNetwork.visible = true
			this.rollMain.btnCommandRenderNetwork.visible = true
			
			_success
		),
		
		fn renderCMDPass =
		(
			_passesToRender = this.collectPassesToRender #selected
			lb.cmdLauncher.run()
			lb.cmdLauncher.isSinglePass = true
			lb.cmdLauncher.passesToRender = _passesToRender
		),
		------------------------------------------------
		--@fn: undefined | timeOutputFramesOptionSelected | si el timeOutput esta en modo frames, pregunta al usuario si desea continuar la operacion de render
		------------------------------------------------
		fn timeOutputFramesOptionSelected = 
		(
			_process = true
			passTrees = lb.passManager.getContainerTrees()
			for _passTree in passTrees do
			(
				_children = _passTree.getChildren()
		
				for _ch in _children where (_ch.getSubType()) == #overrides do
				(	
					_overrides = _ch.getOverrides()
		
					for _ovr in _overrides where _ovr.getSubtype() == "timeOutput" do
					(					
						_custom = _ovr.customOverride.infoNode.custAttributes["overrideTimeOutputInfo"]
		
						if _custom.renderTimeType == 4 then
						(
							_process = lb.message.show "timeOutput override set to Frames, do you want to continue?" type:#query
						)
						
					)					
				)
			)
			return _process
		), 

		------------------------------------------------
		--@fn: undefined | isolatePass | Muestra los objetos que se renderizarían en la escena
		------------------------------------------------
		fn isolatePass =
		(
			_passes = this.collectPassesToRender #selected
			_passes[1].showOnlyObjectsInSets()
			_passes[1].showOnlyMyLights()
			_passes[1].hideHiddenObjects()
			_passes[1].showOnlyFlatColorObjectSets()
		),

		fn showAll =
		(
			for o in objects where (superclassof o == Light) do o.isHidden = false
			for o in objects where (superclassof o == GeometryClass) do o.isHidden = false
			for o in objects where (superclassof o == Camera) do o.isHidden = false

			-- Pasamos los fixes del Asset Checker de visibilidad
			lb.misc.passAssetCheck CHK_hairNiceProperties type:#sequenceRender fix:true
		),
		
		------------------------------------------------
		--COMMON
		------------------------------------------------
		
		------------------------------------------------
		--@fn: boolean | isOpen | Devuelve información true o false, si la herramienta está abierta o cerrada.
		------------------------------------------------
		fn isOpen =
		(
			this.opened
		),
			
		------------------------------------------------
		--@fn: undefined | refreshInterface | Refresca el interface inicial de la herramienta
		------------------------------------------------
		fn refreshInterface =
		(
			--refresca el interface de la herramienta
		),
		
		------------------------------------------------
		--@fn: undefined | saveSettings | Salva los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn saveSettings =
		(
			--almacena el gestor de render en red
			lb.xml.setAttribute this.cfgFile ("passManager/tool/netRenderManager") "name" (this.netRenderManager as string)
		),
		
		------------------------------------------------
		--@fn: undefined | loadSettings | Carga los settings de la herramienta en el documento de configuración de la misma.
		------------------------------------------------
		fn loadSettings =
		(
			--carga el gestod e render en red
			_netRenderManager = (lb.xml.getAttribute this.cfgFile ("passManager/tool/netRenderManager") "name")
				
			--aplica los valores
			if _netRenderManager != "" then (this.netRenderManager = _netRenderManager as name)
		),
		
		------------------------------------------------
		--@fn: undefined | createInterface | Crea el interface inicial de la herramienta
		------------------------------------------------
		fn createInterface =
		(
			--crea el interface, lo redimensiona y lo reposiciona
			createDialog this.rollMain lockwidth:false lockheight:false pos:[-10000,0] style:#(#style_titlebar, #style_border, #style_sysmenu, #style_minimizebox, #style_resizing)
		),
		
		------------------------------------------------
		--@fn: undefined | destroyInterface | Destruye el interface de la herramienta.
		------------------------------------------------
		fn destroyInterface =
		(
			destroyDialog this.rollMain --cierra la herramienta.			
		),--destroyInterface
		
		------------------------------------------------
		--@fn: undefined | run | Lanza la herramienta.
		------------------------------------------------
		fn run =
		(	
			setWaitCursor()

			this.loadSettings() --carga settings del archivo de configuracion

			lb.passmanager.fixInfoNodesNames() --Arregla los nombres antiguos de los infonodes

			this.fillContainerTrees() --rellena los arboles de contenedores con los que trabajar

			this.createInterface() --crea el interface
			for i=1 to this.rollMain.trvContainers.nodes.count do refreshVisibility this.rollMain.trvContainers.nodes.item[i-1] --muestra solo los visibles
			this.expandTree level:2 --hace que se vean solo dos niveles del arbol

			if lb.developerModeOn then
			(
				lb.passManager.placeInScene() --recoloca los elementos del arbol en la escena.
				lb.overrides.placeInScene() --recoloca los overrides en su posicion en la escena respecto a su elemento relacionado del arbol.
			)

			this.opened = true --indica que la herramienta está abierta

			setArrowCursor()
		),--execute
		
		------------------------------------------------
		--@fn: undefined | close | Cierra la herramienta.
		------------------------------------------------
		fn close =
		(
			this.saveSettings() --salva settings en el arvhivo de configuracion
			this.destroyInterface() --destruye el interface.

			this.opened = false --indica que la herramienta está cerrada.
		),
		
		------------------------------------------------
		--@fn: undefined | initSubLibraries | Inicializa todas las sublibrerías en el orden establecido.
		------------------------------------------------
		fn initSubLibraries =
		(
			_subLibraries = #()
			
			for sl in _subLibraries do sl.init()
		),
		
		------------------------------------------------
		--@fn: undefined | init | Inicializa la librería.
		------------------------------------------------
		fn init =
		(		
			this.initSubLibraries() --inicialza las librerías hijas
		),		
		
		------------------------------------------------------------------------------------------------
		--EVENTS
		------------------------------------------------------------------------------------------------
		
		------------------------------------------------
		--@event: create | Ejecución al crearse la instancia del struct.
		------------------------------------------------
		on create do
		(
			lb.addTool this --añade la tool a la libreria principal
		)
		
	)--tl_passManagerUI
	
	------------------------------------------------------------------------------------------------------------------------------------------------
	--EJECUCION
	------------------------------------------------------------------------------------------------------------------------------------------------	
	
	tl_passManagerUI() --crea la herramienta
	
	ok
)